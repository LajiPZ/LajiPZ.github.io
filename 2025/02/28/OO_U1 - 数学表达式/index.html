<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>OO_U1 - 数学表达式 - Position 0 - LajiPZ的随想屋</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Position 0 - LajiPZ的随想屋"><meta name="msapplication-TileImage" content="/img/pz13.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Position 0 - LajiPZ的随想屋"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Hw1这本是一个描述本人思路的草稿，后决定还是整理一下，发到公屏交流一下）） 要求读入一个含：  加，减 乘 乘方 至多一层括号（建议考虑多层的拓展）的 单变量（e.g. 字母x） 表达式。  输出：  展开所有括号 结果尽可能短"><meta property="og:type" content="blog"><meta property="og:title" content="OO_U1 - 数学表达式"><meta property="og:url" content="http://lajipz.top/2025/02/28/OO_U1%20-%20%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><meta property="og:site_name" content="Position 0 - LajiPZ的随想屋"><meta property="og:description" content="Hw1这本是一个描述本人思路的草稿，后决定还是整理一下，发到公屏交流一下）） 要求读入一个含：  加，减 乘 乘方 至多一层括号（建议考虑多层的拓展）的 单变量（e.g. 字母x） 表达式。  输出：  展开所有括号 结果尽可能短"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://lajipz.top/img/og_image.png"><meta property="article:published_time" content="2025-02-28T02:44:00.000Z"><meta property="article:modified_time" content="2025-04-14T15:43:59.656Z"><meta property="article:author" content="LajiPZ"><meta property="article:tag" content="面向对象"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://lajipz.top/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://lajipz.top/2025/02/28/OO_U1%20-%20%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},"headline":"OO_U1 - 数学表达式","image":["http://lajipz.top/img/og_image.png"],"datePublished":"2025-02-28T02:44:00.000Z","dateModified":"2025-04-14T15:43:59.656Z","author":{"@type":"Person","name":"LajiPZ"},"publisher":{"@type":"Organization","name":"Position 0 - LajiPZ的随想屋","logo":{"@type":"ImageObject","url":"http://lajipz.top/img/pz13.png"}},"description":"Hw1这本是一个描述本人思路的草稿，后决定还是整理一下，发到公屏交流一下）） 要求读入一个含：  加，减 乘 乘方 至多一层括号（建议考虑多层的拓展）的 单变量（e.g. 字母x） 表达式。  输出：  展开所有括号 结果尽可能短"}</script><link rel="canonical" href="http://lajipz.top/2025/02/28/OO_U1%20-%20%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><link rel="icon" href="/img/pz13.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link data-pjax rel="stylesheet" href="https://unpkg.com/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://unpkg.com/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://unpkg.com/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://unpkg.com/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Position 0 - LajiPZ的随想屋" type="application/atom+xml">
</head><body class="is-$3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/pz13.png" alt="Position 0 - LajiPZ的随想屋" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-02-28T02:44:00.000Z" title="2/28/2025, 10:44:00 AM">2025-02-28</time>发表</span><span class="level-item"><time dateTime="2025-04-14T15:43:59.656Z" title="4/14/2025, 11:43:59 PM">2025-04-14</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B%E7%9B%B8%E5%85%B3/">课程相关</a></span><span class="level-item">38 分钟读完 (大约5640个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">OO_U1 - 数学表达式</h1><div class="content"><h1 id="Hw1"><a href="#Hw1" class="headerlink" title="Hw1"></a>Hw1</h1><p>这本是一个描述本人思路的草稿，后决定还是整理一下，发到公屏交流一下））</p>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>读入一个含：</p>
<ul>
<li>加，减</li>
<li>乘</li>
<li>乘方</li>
<li>至多一层括号（建议考虑多层的拓展）<br>的 <strong>单变量（e.g. 字母x）</strong> 表达式。</li>
</ul>
<p>输出：</p>
<ul>
<li>展开所有括号</li>
<li>结果尽可能短<span id="more"></span></li>
</ul>
<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>我们可以继续沿用先前的逻辑，不过需要针对乘方进行优化（用一个我看得懂，杂揉了RegEx的写法，严谨定义请参阅参考书）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- Expr：(+|-)&#123;0,1&#125;term | expr(+|-)term</span><br><span class="line">- Term：Term * Factor | (+|-)&#123;0,1&#125;Factor</span><br><span class="line">- Factor：**变量** | 常数 | Expr</span><br><span class="line">- 变量：x(^【一个正数，可能有前导0和+】)&#123;0,&#125;</span><br><span class="line">- 常数：(+|-)&#123;0,1&#125;\d+</span><br></pre></td></tr></table></figure>


<p>为了处理幂函数，我们引入Factor的下一级SubFactor：当前定义下，为<code>^</code>两端的对象，可为数字，变量或表达式。</p>
<p>此时，我们的指数一定为一个正数，这里SubFactor涵盖指数会不会有问题？在Parser标记的过程，不会；但在后面由标记好的Expr，得到多项式的过程中，就有可能出问题了。</p>
<h2 id="多层括号嵌套"><a href="#多层括号嵌套" class="headerlink" title="多层括号嵌套"></a>多层括号嵌套</h2><p>看了OOpre.hw7的都知道，那边的实现之所以不能处理多层嵌套，是因为在最低层次中引入了SubExpr；我们只需把SubExpr换成Expr，就可以处理多层括号嵌套了。</p>
<h2 id="发病"><a href="#发病" class="headerlink" title="发病"></a>发病</h2><p>这是一个在参考书的定义下不可能出现的情况，但仍然值得考虑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+-++---+++-009+b</span><br></pre></td></tr></table></figure>
<p>对应regex：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\+|-)&#123;0,1&#125;((\d|\+|-)+)</span><br></pre></td></tr></table></figure>

<p>实际情况中，至多只可能出现三个连续的符号，但考虑一下也好。</p>
<h2 id="继续构造"><a href="#继续构造" class="headerlink" title="继续构造"></a>继续构造</h2><h2 id="lexer"><a href="#lexer" class="headerlink" title="lexer"></a>lexer</h2><p>将输入tokenize。<br>分以下几类：</p>
<ul>
<li><code>+</code></li>
<li><code>-</code></li>
<li><code>*</code></li>
<li><code>^</code></li>
<li><code>(</code></li>
<li><code>)</code></li>
<li>数字：调用parseNum()，分析出数字。此时我们先不考虑符号数的问题。</li>
</ul>
<p>空字符直接跳过，毕竟在我们的定义中，空格不存在语义；不关心其数量而直接跳过，并无影响。</p>
<p>为什么在parse前要tokenize？这对后续拓展其实是有利的，比如说，变量名字不是一个字符x，而是多个字符时。</p>
<h2 id="符号化简"><a href="#符号化简" class="headerlink" title="符号化简"></a>符号化简</h2><p>我们认为，此时各个Term的连接应该都是加号。因此，我们需要想一个处理正负的方法。</p>
<p>我们需要对符号进行简化，得到唯一的正负标识<code>reversed</code>。</p>
<p>这个<code>reversed</code>标记该放到哪一层呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">此时，我们应在最小单元处，进行加减号的化简；因此，我们决定，在parseSubFactor()过程中进行加减号的吞并，同时使用一标识符，指示SubFactor是否取反。</span><br><span class="line"></span><br><span class="line">事实上，我们只需要对Num，Var记录这一取反符号</span><br></pre></td></tr></table></figure>

<p>仔细思考发现，上述思路对于以下样例处理存在问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+-5+-x^5</span><br></pre></td></tr></table></figure>

<p>幂函数整体是一个正值。因此，我们处理正负的问题，应该停留在Factor层次。处理连续符号的过程，因此也放在Factor处进行。</p>
<p>为此，我们还需修改Factor类的构成：除SubFactor容器外，还需记录一个<code>boolean reversed</code>.</p>
<p>具体实现为：</p>
<ul>
<li>Expr：parse方法需提供<code>reversed</code>，指示默当前正负；直接向下parse，并传递<code>reversed</code>。</li>
<li>Term：符号可认为只对第一个乘数有影响，故只将该<code>reversed</code>传递到第一个Factor，其余Factor的reversed全设为false；继续向下parse</li>
<li>Factor：<strong>先处理符号。</strong> 当前读到+保持<code>reversed</code>不变，读到-对<code>reversed</code>取反。完成处理后，使用处理好的<code>reversed</code>新建Factor对象，再进行下一层的parse（方法同现有的类似，不再赘述）。</li>
<li>SubFactor：分三类情况，数字，变量和表达式。仿照现有思路处理即可。<strong>不过</strong>，对于表达式，我们此时调用parseExpr()时，传入的<code>reserved</code>应为false，因为我们已经在其上一级Factor处理好了符号。</li>
</ul>
<p>这样一来，我们逐层向下传递了各个Factor的正负属性，从而为下文进行多项式转换提供便利。</p>
<h2 id="多项式转换"><a href="#多项式转换" class="headerlink" title="多项式转换"></a>多项式转换</h2><p>我们通过<code>Parser.parseExpr()</code>，得到了一个处理（或者说，标记？）后的<code>Expr</code>。</p>
<p>考察最终化简式，可以得知其形式为：<br>$$\sum a*x^b$$<br>因此，我们需要构造：</p>
<ul>
<li><code>Mono</code>类：一个单项式</li>
<li><code>Poly</code>类：一个多项式，使用容器存储其包含的单项式</li>
</ul>
<p>同样，我们认为，此时各单项式间连接只有加法。</p>
<p>如何定义Mono？其中包含：</p>
<ul>
<li><code>BigInteger multiplier</code>：a</li>
<li><code>String var</code>:x</li>
<li><code>BigInteger exp</code>: b</li>
</ul>
<p>针对纯数字的表达，我们规定：</p>
<ul>
<li>值全部存储在<code>multiplier</code>中</li>
<li><code>var</code>此时为空串<code>&quot;&quot;</code>，为变量可能为多字符的情况准备</li>
<li><code>exp</code>恒为1</li>
</ul>
<p>在这个思路的指引下，我们引入一个处理器<code>Flattener</code>，将已进行标记的表达式<code>expr</code>“拍扁“，得到一个满足上式的多项式。此时，我们并不需要考虑化简的问题；化简的过程，我们在Poly类内实现一个方法即可。</p>
<p>为何要多一个Flattener? 感觉上，边Parse边获取单项式似乎是可行的，但为了高内聚低耦合，还是把获取单项式的过程独立出来吧。</p>
<p>Flatter中需要实现的方法：</p>
<ul>
<li><code>getPoly()</code>：将表达式转为多项式</li>
<li><code>getMono()</code>：逐层得到单项式，返回一个<strong>单项式容器</strong>；显然，要根据传入的是Expr&#x2F;Sub&#x2F;Factor来进行不同的处理</li>
</ul>
<p><code>getPoly()</code>调用<code>getMono(Expr)</code>，随后将容器包装为Poly对象。</p>
<p>我们在此仍然采取递归下降的思路，对已标记的Expr进行处理。根据传入对象类别划分：</p>
<ul>
<li><p>Expr：创建一单项式容器<code>monoList</code>；遍历包含的Term，由getMono()得到子容器；此时是加号，简单合并各容器即可。</p>
</li>
<li><p>Term：遍历Factor，得到各子容器；此时是乘号，调用一个<strong>多项式乘法方法</strong>，得到存有单项式的一个容器</p>
</li>
<li><p>Factor：过程略有复杂。<br>在当前定义下，必为<code>a^b</code>的形式。若为<code>x^b</code>，直接构建新的<code>Mono</code>，加入将返回的单项式容器；若为<code>&lt;num&gt;^b</code>，则直接进行计算，按照上文中，纯数字下单项式的约定，构建单项式；若为<code>&lt;expr&gt;^b</code>，则调用一个<strong>多项式求幂方法</strong>，得到一系列单项式，最后加入容器。</p>
<p>在得到单项式，返回容器之前，还记得Factor的<code>reserved</code>属性吗？此时，若其为true，则需要调用一个<strong>取反方法</strong>，将各个单项式的系数取反。</p>
</li>
</ul>
<p>好的，现在我们还要做：</p>
<ul>
<li>多项式乘法：多次<strong>单项式乘法</strong></li>
<li>多项式求幂：多次调用多项式乘法即可</li>
<li>取反：将各个单项式的系数取反。</li>
<li>单项式乘法：功能不赘述。<br>不过，我们的乘数为0，乘后指数为0的情况都需要在此处理。</li>
</ul>
<p>这三者的实现其实很简单，这里就不再赘述，不过可以提一下多项式求幂：</p>
<p>在定义中，<code>m^0=1</code>，我们怎么实现这个逻辑呢？显然，我们求幂返回的是个单项式容器；故，我们在方法被调用的开始，初始化一个只含单项式：<strong>数字1</strong>的容器；随后，根据次幂，将其同底数多项式相乘指数次即可。</p>
<p>一番操作后，我们就得到了一个未化简的多项式对象Poly了。</p>
<h2 id="多项式化简"><a href="#多项式化简" class="headerlink" title="多项式化简"></a>多项式化简</h2><p>思路很简单：遍历单项式容器，合并同次幂单项式。</p>
<p>需要对单项式为数字（即，<code>var.equals(&quot;&quot;)</code>）单独开情况处理。不用担心指数为0的情况，上面的单项式乘法里，我们已经处理掉了。</p>
<p>限于篇幅，且实现也不困难，这里就不展开说了。</p>
<h1 id="Hw2"><a href="#Hw2" class="headerlink" title="Hw2"></a>Hw2</h1><p>引入了两个新功能：</p>
<ul>
<li>三角函数：<code>sin</code>，<code>cos</code></li>
<li>自定义递推函数</li>
</ul>
<p>其他的定义可以认为没改。我们逐个分析。</p>
<h2 id="递归函数解析"><a href="#递归函数解析" class="headerlink" title="递归函数解析"></a>递归函数解析</h2><blockquote>
<p>也可以参考<a target="_blank" rel="noopener" href="http://oo.e2.buaa.edu.cn/assignment/608/discussion/1656">这篇帖子</a>，其思路也很不错，本人思路也有不少与之相近之处</p>
</blockquote>
<p>这是本次作业里较为头疼的一点，要怎么办呢？</p>
<p>书接上文，我们在解析表达式时，在<code>Factor</code>下再加了一层<code>SubFactor</code>。一番分析可知，<code>递归函数调用</code>正是属于<code>SubFactor</code>这一层次。那么，我们能不能<strong>在<code>parseSubFactor()</code>中添加调用对应的处理规则</strong>，使得我们parse函数调用的时候，得到一个<strong>完全展开的表达式呢</strong>？</p>
<p>是可以的。在此之前，我们需要搓一个**展开递归函数的“求解器”<code>Solver</code>**。</p>
<h3 id="求解器"><a href="#求解器" class="headerlink" title="求解器"></a>求解器</h3><p>我们这里的整体思路是：</p>
<ul>
<li>Parser解析输入表达式时，读到调用，交给Solver处理；</li>
<li>Solver通过调用序号，得到调用对应的表达式；此时，我们<strong>不要求此处得到的表达式完全展开</strong></li>
<li>解析这一表达式；遇到调用，则递归重复上述思路。</li>
</ul>
<p>我们当然先要知道递归函数定义如何。我的处理是：</p>
<ul>
<li><strong>先把各定义Tokenize为Token串</strong>；</li>
<li>非递归定义的Token串：存入一个<strong>以序号为索引的定义表</strong>内</li>
<li>递归定义的Token串：单独存储。</li>
</ul>
<p>至于为什么这么做，这就要看我们的求解过程了；我们此时先不管形参转实参的问题：</p>
<ul>
<li>对传入的调用序号，<strong>先查定义表内有没有该序号</strong>，有则直接解析表项的Token串，没有则继续：</li>
<li>定义表不存在该序号，则<strong>获取递归定义的Token串，并将其中不定序号<code>n</code>对应的Token，换成序号对应的数字Token</strong></li>
<li>解析这一替换好的Token串副本。随后，就是我们上面的整体思路。</li>
</ul>
<p>问题来了，我们要怎么解析递归表达式？我们这里的Token串仍然是表达式，<strong>复用我们写好的Parser</strong>即可，不过需要些许更改：</p>
<ul>
<li>添加SubFactor为调用时的处理方法，并解析出调用的<code>序号</code>与<code>参数</code>(上面已经提到）</li>
<li>序号的解析应该支持<code>&lt;num&gt;</code>和<code>&lt;num&gt;-&lt;num&gt;</code>的形式，为递归做准备</li>
<li>实现<strong>形参替换</strong></li>
</ul>
<h3 id="形参替换"><a href="#形参替换" class="headerlink" title="形参替换"></a>形参替换</h3><p>我们能不能在Parser进行处理的时候，就直接自动把变量解析成实参呢？</p>
<p>答案是有的，我们只需要略微修改Parser，以及<code>parseSubFactor()</code>时，读到变量类型的处理方法：</p>
<ul>
<li>Parser：添加属性：<strong>符号查找表</strong><code>HashMap&lt;String,Factor&gt;</code></li>
<li><code>parseSubFactor()</code>：碰到变量先查表，如有对应实参，则返回实参的Factor对象，没有则返回变量</li>
<li>显然，我们还要把Factor分类到SubFactor里。</li>
</ul>
<p>在我们解析输入函数时，我们向<code>parse()</code>传入空表；而在<strong>解析递归函数时</strong>，我们则先把变量建立好对应的查找表，再在调用的<code>parse()</code>中传入递归函数的符号查找表。</p>
<p>至此，我们即可展开递归函数并传递变量，完成原设计中标记表达式的功能。</p>
<h3 id="获取多项式"><a href="#获取多项式" class="headerlink" title="获取多项式"></a>获取多项式</h3><p><strong>我们这里先不管三角函数。</strong></p>
<p><code>Flattener</code>这里本没有什么好说的，但是：参数必须是Factor类型，而我们把Factor类归在了SubFactor类下，故这里也需补充对应获取多项式的逻辑…</p>
<blockquote>
<p>事实上，参数完全可以视作<code>Expr</code>类，毕竟参数内容是由你的parse方法得到的，而且递归下降的原理也告诉我们，这么处理没问题；视作表达式来处理还更方便，因为不用把Factor归进SubFactor，维持我们Hw1的处理逻辑就行；但题目这么说就这么做吧</p>
</blockquote>
<p>这里我们先在“标记”阶段处理掉了递归函数展开，因而获取多项式的部分不需大改，这算是低耦合的好处吧。</p>
<h2 id="单项式结构的修改"><a href="#单项式结构的修改" class="headerlink" title="单项式结构的修改"></a>单项式结构的修改</h2><p>由于三角函数的引入，我们不得不修改单项式的定义！</p>
<p>现定义单项式如下：<br>$$a*\prod<unit>$$<br>其中：$$unit &#x3D; &lt;Var|TrigFunc&gt;^n$$<br><code>Var</code>代指变量，<code>TrigFunc</code>代指三角函数。</p>
<p>因此，我们只需要一个<code>BigInteger</code>存进乘数，一个<code>ArrayList&lt;Unit&gt;</code>存入后面累乘的幂函数。</p>
<p>在修改了单项式的定义后，是不是需要大规模的重构呢？</p>
<p>先看<code>Flattener</code>：</p>
<ul>
<li>构造方法：我们在构造方法处使用多态，从而<strong>兼容先前构造接口</strong></li>
<li>多项式求幂&#x2F;相乘：只涉及<code>ArrayList&lt;Mono&gt;</code>的相关处理，在这一层次不涉及<code>Mono</code>内部操作，维持现状即可，算是万幸</li>
<li>单项式相乘：<strong>这个没办法，必须重写</strong>；</li>
</ul>
<p>我的重写思路如下：</p>
<ul>
<li>分两步进行：</li>
<li>第一步：简单的乘数相乘，幂函数容器合并</li>
<li>第二步：合并底数相同的幂函数</li>
</ul>
<p>第二步中如何比较底数相等，以及如何合并难度不大，留给读者自行探索。</p>
<p>再看负责多项式化简的<code>Poly</code>：</p>
<ul>
<li>属性不用更改，本来就是<code>Mono</code>容器</li>
<li>出问题了！合并同类项的<code>mergeMono()</code>要大改！</li>
</ul>
<p><code>mergeMono()</code>分两步：</p>
<ul>
<li>比较多项式是否为同类项，是则合并</li>
<li>进行三角函数的化简，这个后面再提</li>
</ul>
<h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><p>这才是本次作业最头大的问题，主要在于化简的复杂度实在太高。</p>
<h3 id="TrigFunc与TrigFuncFactor"><a href="#TrigFunc与TrigFuncFactor" class="headerlink" title="TrigFunc与TrigFuncFactor"></a><code>TrigFunc</code>与<code>TrigFuncFactor</code></h3><p>我们引入这两个新的类。</p>
<ul>
<li><code>TrigFuncFactor</code>在Parser内使用，其内存放三角函数的类型，及参数对应的<code>Factor</code></li>
<li><code>TrigFunc</code>在处理成多项式后使用，其内存放三角函数的类型，及参数对应的<strong>多项式</strong></li>
</ul>
<p><strong>三角函数</strong>与<strong>函数调用</strong>被放在了“变量因子”层次，同之前幂函数在一个层次。因此，我们决定，将与<code>TrigFuncFactor</code>置于<code>SubFactor</code>层次，这对<code>sin()^2</code>情况的处理亦有好处。</p>
<p>需要在Flattener和Parser处编写针对三角函数的规则，这里不再赘述。</p>
<h3 id="化简"><a href="#化简" class="headerlink" title="化简"></a>化简</h3><p>我选择复现<a target="_blank" rel="noopener" href="http://oo.buaa.edu.cn/assignment/608/discussion/1657">讨论区内已有方法</a>，化简规则看这个基本就够了。不过这篇帖子里讲的是是单次化简。</p>
<p>考虑这样一个输入：<br>$$(cos(x)^2-sin(x)^2)^2+sin(2x)^2$$<br>理想的化简结果是<code>1</code>；显然，单化简一次是不够的！</p>
<p>我们引入这样一个多重化简机制：</p>
<ul>
<li>两个容器：原始单项式集合<code>monoList</code>和结果<code>newMonoList</code></li>
<li>外层套<code>while()</code>，由一个布尔变量<code>proceed</code>指示是否继续重复化简</li>
<li><strong>引用一个写回缓存区</strong><code>buffer</code>，实现“化简之后，把结果加回正在遍历的结果列表”的效果</li>
<li>判断单项式集合中<code>mono</code>与<code>newMonoList</code>中元素是否可化简：</li>
<li>若能，则<strong>将合并结果写入缓存</strong>，并<strong>将此<code>mono</code>从原始集合中移除</strong>；</li>
<li>若不能，<strong>将此<code>mono</code>移动到结果列表中</strong>；也就是说，<code>mono</code>无论如何都得删。</li>
<li>双层遍历完成后，**若缓存为空，则说明不可化简，<code>proceed</code>设为否；反之，则将缓存内容写回<code>newMonoList</code>**。</li>
</ul>
<p>示意如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boolean proceed = true;</span><br><span class="line">while (proceed) &#123;</span><br><span class="line">	&lt;for mono in monoList&gt; &#123;</span><br><span class="line">		&lt;第一次进行化简时，把第一个mono放入结果列表&gt;</span><br><span class="line">		&lt;for newMono in newMonoList&gt; &#123;</span><br><span class="line">			// do something</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	if (buffer.isEmpty) &#123; proceed = false; &#125; else &#123;</span><br><span class="line">		newMonoList.addAll(buffer)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Hw3"><a href="#Hw3" class="headerlink" title="Hw3"></a>Hw3</h1><p>引入非递归自定函数与求导因子。</p>
<p>SubFactor引入上述两个新元素，对应修改Flattener规则</p>
<p>求导规定成<code>dx(&lt;Expr&gt;)</code>；在<code>Flattener.getMono(Factor)</code>中，读到求导因子的Subfactor，则将里面的<code>&lt;Expr&gt;</code>化成多项式，随后逐单项式，运用求导规则，获得新的表达式。</p>
<p>可以造一个单项式求导器。</p>
<p>非递归自定函数，按照现有实现改进即可。考虑到我们写递归函数求解器的写法，我们甚至可以直接复用。</p>
<h2 id="改Solver"><a href="#改Solver" class="headerlink" title="改Solver"></a>改Solver</h2><p>复用已有的Solver。</p>
<p>首先要改lexer，把两个自定函数的符号进行分类，分类就继续分到<code>FUNC</code>内；</p>
<p>接下来是Parser部分；我们在处理递归函数的时候，写了这么一个东西：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lexer.forward(); // Skip LCurly  </span><br><span class="line">final int times = parseInvocationTimes();  </span><br><span class="line">lexer.forward(); // Skip RCurly</span><br></pre></td></tr></table></figure>
<p>我们在此次修改时，需要这么做：</p>
<ul>
<li>读取当前Token，看是圆括号还是花括号</li>
<li>圆括号-&gt;普通函数，花括号-&gt;递归函数</li>
<li>圆括号默认<strong>调用次数为0</strong></li>
</ul>
<p>随后，目光转向Solver；</p>
<p>在我初始化Solver时，我采用了如下写法，以获取<code>n</code>行的函数定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Solver(int n) &#123;  </span><br><span class="line">    int lines = n;  </span><br><span class="line">    while (lines &gt; 0) &#123;  </span><br><span class="line">        String expr = scanner.nextLine();  </span><br><span class="line">        Lexer lexer = new Lexer(expr);  </span><br><span class="line">        classify(lexer);  </span><br><span class="line">        lines--;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们初始化一般函数时，<code>n</code>设成1；递归函数，<code>n</code>为3.</p>
<p>其中的<code>classify()</code>方法，是根据输入的定义式，判断递归表达式的类型，从而决定将定义放入递归定义，还是定义表内；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">classify() &#123;</span><br><span class="line">	// Skip Name  </span><br><span class="line">	// Skip &#123;  </span><br><span class="line">	Token typeToken = lexer.getCurrentToken();  </span><br><span class="line">	// Skip n  </span><br><span class="line">	// Skip &#125;  </span><br><span class="line">	// Skip (</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用同样的思路，在普通函数时，让typeToken变成”0”；随后，就可顺利复用Solver。</p>
<p>那么，我们怎么实现多个函数的解析呢？</p>
<ul>
<li>首先，我们需要给<code>Solver</code>添加<code>String name</code>属性，从而记录当前求解器解的是哪一个函数；</li>
<li>随后，我们需要构建一个<strong>按名称的函数求解器表</strong>，将其传给Parser；</li>
<li>Parser在遇到函数关键字时，查找求解器表，获得求解器，随后求解得到表达式。</li>
</ul>
<p>这部分就成功解决了，接着看求导。</p>
<h2 id="加求导"><a href="#加求导" class="headerlink" title="加求导"></a>加求导</h2><p>首先，我们要在Lexer里面加<code>dx</code>的规则，这就不多说了。</p>
<p>求导因子会出现嵌套，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dx(dx(x^2)+x^3)</span><br></pre></td></tr></table></figure>

<p>我们此时仍然不用担心，递归下降的原理保证其可以被处理；我们只需在<code>getMono(Factor)</code>处正确获取多项式即可。</p>
<p><code>getMono(Factor)</code>处，读到求导因子，调用一个求导器，获取实际多项式。</p>
<h2 id="求导器"><a href="#求导器" class="headerlink" title="求导器"></a>求导器</h2><p>为方便求导的进行，我们决定对一个<strong>多项式</strong>求导。也就是说，我们需要先将<code>dx(&lt;expr&gt;)</code>中的表达式先转换为多项式，再进行我们求导的过程。</p>
<p>我们需要求导的表达式，符合如下一般形式：<br>$$expr &#x3D; \sum{a*\prod{<base>^b}}$$<br>我们将其分为以下层次，分别求导：</p>
<ul>
<li>多项式：如上</li>
<li>单项式：$a*\prod{<base>^b}$</li>
<li>幂函数：$<base>^b$</li>
<li>底数：$<base>$</li>
</ul>
<p>这样即可应对链式法则中，幂函数之底数为三角函数的问题。</p>
<p>各层规则如下：</p>
<ul>
<li>多项式：对各单项式求导，<strong>合并各次求导所得多项式</strong></li>
<li>单项式：实现<strong>乘法法则</strong>，得到求导后多项式</li>
<li>幂函数：<br>先假设<code>&lt;base&gt;</code>为一个整体，按照幂函数的求导方法正常进行；随后，<strong>将结果与底数求导结果相乘，实现链式法则</strong>。这里可能需要对<code>^0</code>，<code>^1</code>等情况做特殊考虑。</li>
<li>底数：返回一个<strong>多项式</strong><br>数字：求导为0；<br>变量：求导为1；<br>三角函数：sin,cos按各自方式求导（内部表达式视为整体）后，<strong>与内部表达式的求导结果相乘</strong>，实现链式法则。</li>
</ul>
<p>不难注意到，我们上面需要用到多项式乘法；调用我们已实现的方法即可。</p>
<h2 id="拓展三角化简"><a href="#拓展三角化简" class="headerlink" title="拓展三角化简"></a>拓展三角化简</h2><p>在Hw2中，我没有搓sin的二倍角化简。在本次作业中，由于出现可化简情况的概率大幅增大，我们决定补齐这一化简策略。</p>
<p>$$(cos(x)^2)’&#x3D;-2cos(x)sin(x)&#x3D;-sin(2x)$$</p>
<p>为了防止化简后，输出长度不减反增，我们规定其：</p>
<ul>
<li>在其它三角化简后进行。</li>
<li>仅在sin,cos指数均为1时进行</li>
</ul>
<p>还有化简本身的规则：</p>
<ul>
<li>乘数绝对值大于1（因为我们的系数是<code>BigInteger</code>）.</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回顾本次作业，我发现自己的最终成果存在以下问题：</p>
<ul>
<li>Flattener中，<code>ArrayList&lt;Mono&gt;</code>与<code>Poly</code>类混用；这是因为，Poly类是在我发现多项式化简需求后才引入的；我没有狠下心，将单项式容器全部重构为<code>Poly</code>类，导致<code>Flattener</code>处画风相当混乱；</li>
<li>各方法所属的类并未妥善划分；我的多项式&#x2F;单项式乘法全部放在了<code>Flattener</code>中。虽说获取多项式需要这些方法，但仔细想来仍然不合理：多项式有关计算，应该在多项式类中才对；</li>
<li>部分过程未打包为方法，导致可读性下降：最明显的，就是我赶工赶出来的三角函数化简。</li>
<li>不敢<code>@Override</code>，导致实现深克隆的过程未被打包为方法，而直接出现在过程中；</li>
</ul>
<p>日后多加改正。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>OO_U1 - 数学表达式</p><p><a href="http://lajipz.top/2025/02/28/OO_U1 - 数学表达式/">http://lajipz.top/2025/02/28/OO_U1 - 数学表达式/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>LajiPZ</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-02-28</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-04-14</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=671eeccad01e2b00125527bf&amp;product=inline-share-buttons&amp;source=platform" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2025/04/17/%E5%9C%A8IDEA%E5%86%85%E9%83%A8%EF%BC%8C%E8%BF%9B%E8%A1%8C%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E6%AD%BB%E9%94%81%E8%B0%83%E8%AF%95/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">在IDEA内部，进行更高效的死锁调试</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2025/02/04/%E8%88%AA%E7%A0%96%E7%A5%AD%E7%A5%96%E5%90%8E%E6%97%A5%E8%B0%88/"><span class="level-item">航砖祭祖后日谈</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card" id="comments"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="waline-thread"></div><link rel="stylesheet" href="https://unpkg.com/@waline/client@2/dist/waline.css"><script src="https://unpkg.com/@waline/client@2/dist/waline.js"></script><script>Waline.init({
            el: '#waline-thread',
            serverURL: "https://comments.lajipz.top/",
            path: window.location.pathname,
            lang: "zh-CN",
            
            emoji: ["https://unpkg.com/@waline/emojis@1.2.0/tieba","https://unpkg.com/@waline/emojis@1.2.0/weibo","https://unpkg.com/@waline/emojis@1.2.0/bilibili"],
            
            meta: ["nick","mail","link"],
            requiredMeta: [],
            login: "enable",
            
            pageSize: 10,
            imageUploader: false,
            highlighter: false,
            texRenderer: false,
            search: false,
            pageview: false,
            comment: false,
            copyright: true,
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Hw1"><span class="level-left"><span class="level-item">1</span><span class="level-item">Hw1</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#要求"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">要求</span></span></a></li><li><a class="level is-mobile" href="#构造"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">构造</span></span></a></li><li><a class="level is-mobile" href="#多层括号嵌套"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">多层括号嵌套</span></span></a></li><li><a class="level is-mobile" href="#发病"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">发病</span></span></a></li><li><a class="level is-mobile" href="#继续构造"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">继续构造</span></span></a></li><li><a class="level is-mobile" href="#lexer"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">lexer</span></span></a></li><li><a class="level is-mobile" href="#符号化简"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">符号化简</span></span></a></li><li><a class="level is-mobile" href="#多项式转换"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">多项式转换</span></span></a></li><li><a class="level is-mobile" href="#多项式化简"><span class="level-left"><span class="level-item">1.9</span><span class="level-item">多项式化简</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Hw2"><span class="level-left"><span class="level-item">2</span><span class="level-item">Hw2</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#递归函数解析"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">递归函数解析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#求解器"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">求解器</span></span></a></li><li><a class="level is-mobile" href="#形参替换"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">形参替换</span></span></a></li><li><a class="level is-mobile" href="#获取多项式"><span class="level-left"><span class="level-item">2.1.3</span><span class="level-item">获取多项式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#单项式结构的修改"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">单项式结构的修改</span></span></a></li><li><a class="level is-mobile" href="#三角函数"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">三角函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#TrigFunc与TrigFuncFactor"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">TrigFunc与TrigFuncFactor</span></span></a></li><li><a class="level is-mobile" href="#化简"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">化简</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Hw3"><span class="level-left"><span class="level-item">3</span><span class="level-item">Hw3</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#改Solver"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">改Solver</span></span></a></li><li><a class="level is-mobile" href="#加求导"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">加求导</span></span></a></li><li><a class="level is-mobile" href="#求导器"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">求导器</span></span></a></li><li><a class="level is-mobile" href="#拓展三角化简"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">拓展三角化简</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">4</span><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/pz13.png" alt="Position 0 - LajiPZ的随想屋" height="28"></a><p class="is-size-7"><span>&copy; 2025 LajiPZ</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">Background by @katorei</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://unpkg.com/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://unpkg.com/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://unpkg.com/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://unpkg.com/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://unpkg.com/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://unpkg.com/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><script src="https://unpkg.com/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>