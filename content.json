{"posts":[{"title":"OO_U1 - 数学表达式","text":"Hw1这本是一个描述本人思路的草稿，后决定还是整理一下，发到公屏交流一下）） 要求读入一个含： 加，减 乘 乘方 至多一层括号（建议考虑多层的拓展）的 单变量（e.g. 字母x） 表达式。 输出： 展开所有括号 结果尽可能短 构造我们可以继续沿用先前的逻辑，不过需要针对乘方进行优化（用一个我看得懂，杂揉了RegEx的写法，严谨定义请参阅参考书）： 12345- Expr：(+|-){0,1}term | expr(+|-)term- Term：Term * Factor | (+|-){0,1}Factor- Factor：**变量** | 常数 | Expr- 变量：x(^【一个正数，可能有前导0和+】){0,}- 常数：(+|-){0,1}\\d+ 为了处理幂函数，我们引入Factor的下一级SubFactor：当前定义下，为^两端的对象，可为数字，变量或表达式。 此时，我们的指数一定为一个正数，这里SubFactor涵盖指数会不会有问题？在Parser标记的过程，不会；但在后面由标记好的Expr，得到多项式的过程中，就有可能出问题了。 多层括号嵌套看了OOpre.hw7的都知道，那边的实现之所以不能处理多层嵌套，是因为在最低层次中引入了SubExpr；我们只需把SubExpr换成Expr，就可以处理多层括号嵌套了。 发病这是一个在参考书的定义下不可能出现的情况，但仍然值得考虑： 1+-++---+++-009+b 对应regex： 1(\\+|-){0,1}((\\d|\\+|-)+) 实际情况中，至多只可能出现三个连续的符号，但考虑一下也好。 继续构造lexer将输入tokenize。分以下几类： + - * ^ ( ) 数字：调用parseNum()，分析出数字。此时我们先不考虑符号数的问题。 空字符直接跳过，毕竟在我们的定义中，空格不存在语义；不关心其数量而直接跳过，并无影响。 为什么在parse前要tokenize？这对后续拓展其实是有利的，比如说，变量名字不是一个字符x，而是多个字符时。 符号化简我们认为，此时各个Term的连接应该都是加号。因此，我们需要想一个处理正负的方法。 我们需要对符号进行简化，得到唯一的正负标识reversed。 这个reversed标记该放到哪一层呢？ 123此时，我们应在最小单元处，进行加减号的化简；因此，我们决定，在parseSubFactor()过程中进行加减号的吞并，同时使用一标识符，指示SubFactor是否取反。事实上，我们只需要对Num，Var记录这一取反符号 仔细思考发现，上述思路对于以下样例处理存在问题： 1+-5+-x^5 幂函数整体是一个正值。因此，我们处理正负的问题，应该停留在Factor层次。处理连续符号的过程，因此也放在Factor处进行。 为此，我们还需修改Factor类的构成：除SubFactor容器外，还需记录一个boolean reversed. 具体实现为： Expr：parse方法需提供reversed，指示默当前正负；直接向下parse，并传递reversed。 Term：符号可认为只对第一个乘数有影响，故只将该reversed传递到第一个Factor，其余Factor的reversed全设为false；继续向下parse Factor：先处理符号。 当前读到+保持reversed不变，读到-对reversed取反。完成处理后，使用处理好的reversed新建Factor对象，再进行下一层的parse（方法同现有的类似，不再赘述）。 SubFactor：分三类情况，数字，变量和表达式。仿照现有思路处理即可。不过，对于表达式，我们此时调用parseExpr()时，传入的reserved应为false，因为我们已经在其上一级Factor处理好了符号。 这样一来，我们逐层向下传递了各个Factor的正负属性，从而为下文进行多项式转换提供便利。 多项式转换我们通过Parser.parseExpr()，得到了一个处理（或者说，标记？）后的Expr。 考察最终化简式，可以得知其形式为：$$\\sum a*x^b$$因此，我们需要构造： Mono类：一个单项式 Poly类：一个多项式，使用容器存储其包含的单项式 同样，我们认为，此时各单项式间连接只有加法。 如何定义Mono？其中包含： BigInteger multiplier：a String var:x BigInteger exp: b 针对纯数字的表达，我们规定： 值全部存储在multiplier中 var此时为空串&quot;&quot;，为变量可能为多字符的情况准备 exp恒为1 在这个思路的指引下，我们引入一个处理器Flattener，将已进行标记的表达式expr“拍扁“，得到一个满足上式的多项式。此时，我们并不需要考虑化简的问题；化简的过程，我们在Poly类内实现一个方法即可。 为何要多一个Flattener? 感觉上，边Parse边获取单项式似乎是可行的，但为了高内聚低耦合，还是把获取单项式的过程独立出来吧。 Flatter中需要实现的方法： getPoly()：将表达式转为多项式 getMono()：逐层得到单项式，返回一个单项式容器；显然，要根据传入的是Expr/Sub/Factor来进行不同的处理 getPoly()调用getMono(Expr)，随后将容器包装为Poly对象。 我们在此仍然采取递归下降的思路，对已标记的Expr进行处理。根据传入对象类别划分： Expr：创建一单项式容器monoList；遍历包含的Term，由getMono()得到子容器；此时是加号，简单合并各容器即可。 Term：遍历Factor，得到各子容器；此时是乘号，调用一个多项式乘法方法，得到存有单项式的一个容器 Factor：过程略有复杂。在当前定义下，必为a^b的形式。若为x^b，直接构建新的Mono，加入将返回的单项式容器；若为&lt;num&gt;^b，则直接进行计算，按照上文中，纯数字下单项式的约定，构建单项式；若为&lt;expr&gt;^b，则调用一个多项式求幂方法，得到一系列单项式，最后加入容器。 在得到单项式，返回容器之前，还记得Factor的reserved属性吗？此时，若其为true，则需要调用一个取反方法，将各个单项式的系数取反。 好的，现在我们还要做： 多项式乘法：多次单项式乘法 多项式求幂：多次调用多项式乘法即可 取反：将各个单项式的系数取反。 单项式乘法：功能不赘述。不过，我们的乘数为0，乘后指数为0的情况都需要在此处理。 这三者的实现其实很简单，这里就不再赘述，不过可以提一下多项式求幂： 在定义中，m^0=1，我们怎么实现这个逻辑呢？显然，我们求幂返回的是个单项式容器；故，我们在方法被调用的开始，初始化一个只含单项式：数字1的容器；随后，根据次幂，将其同底数多项式相乘指数次即可。 一番操作后，我们就得到了一个未化简的多项式对象Poly了。 多项式化简思路很简单：遍历单项式容器，合并同次幂单项式。 需要对单项式为数字（即，var.equals(&quot;&quot;)）单独开情况处理。不用担心指数为0的情况，上面的单项式乘法里，我们已经处理掉了。 限于篇幅，且实现也不困难，这里就不展开说了。 Hw2引入了两个新功能： 三角函数：sin，cos 自定义递推函数 其他的定义可以认为没改。我们逐个分析。 递归函数解析 也可以参考这篇帖子，其思路也很不错，本人思路也有不少与之相近之处 这是本次作业里较为头疼的一点，要怎么办呢？ 书接上文，我们在解析表达式时，在Factor下再加了一层SubFactor。一番分析可知，递归函数调用正是属于SubFactor这一层次。那么，我们能不能在parseSubFactor()中添加调用对应的处理规则，使得我们parse函数调用的时候，得到一个完全展开的表达式呢？ 是可以的。在此之前，我们需要搓一个**展开递归函数的“求解器”Solver**。 求解器我们这里的整体思路是： Parser解析输入表达式时，读到调用，交给Solver处理； Solver通过调用序号，得到调用对应的表达式；此时，我们不要求此处得到的表达式完全展开 解析这一表达式；遇到调用，则递归重复上述思路。 我们当然先要知道递归函数定义如何。我的处理是： 先把各定义Tokenize为Token串； 非递归定义的Token串：存入一个以序号为索引的定义表内 递归定义的Token串：单独存储。 至于为什么这么做，这就要看我们的求解过程了；我们此时先不管形参转实参的问题： 对传入的调用序号，先查定义表内有没有该序号，有则直接解析表项的Token串，没有则继续： 定义表不存在该序号，则获取递归定义的Token串，并将其中不定序号n对应的Token，换成序号对应的数字Token 解析这一替换好的Token串副本。随后，就是我们上面的整体思路。 问题来了，我们要怎么解析递归表达式？我们这里的Token串仍然是表达式，复用我们写好的Parser即可，不过需要些许更改： 添加SubFactor为调用时的处理方法，并解析出调用的序号与参数(上面已经提到） 序号的解析应该支持&lt;num&gt;和&lt;num&gt;-&lt;num&gt;的形式，为递归做准备 实现形参替换 形参替换我们能不能在Parser进行处理的时候，就直接自动把变量解析成实参呢？ 答案是有的，我们只需要略微修改Parser，以及parseSubFactor()时，读到变量类型的处理方法： Parser：添加属性：符号查找表HashMap&lt;String,Factor&gt; parseSubFactor()：碰到变量先查表，如有对应实参，则返回实参的Factor对象，没有则返回变量 显然，我们还要把Factor分类到SubFactor里。 在我们解析输入函数时，我们向parse()传入空表；而在解析递归函数时，我们则先把变量建立好对应的查找表，再在调用的parse()中传入递归函数的符号查找表。 至此，我们即可展开递归函数并传递变量，完成原设计中标记表达式的功能。 获取多项式我们这里先不管三角函数。 Flattener这里本没有什么好说的，但是：参数必须是Factor类型，而我们把Factor类归在了SubFactor类下，故这里也需补充对应获取多项式的逻辑… 事实上，参数完全可以视作Expr类，毕竟参数内容是由你的parse方法得到的，而且递归下降的原理也告诉我们，这么处理没问题；视作表达式来处理还更方便，因为不用把Factor归进SubFactor，维持我们Hw1的处理逻辑就行；但题目这么说就这么做吧 这里我们先在“标记”阶段处理掉了递归函数展开，因而获取多项式的部分不需大改，这算是低耦合的好处吧。 单项式结构的修改由于三角函数的引入，我们不得不修改单项式的定义！ 现定义单项式如下：$$a*\\prod$$其中：$$unit = &lt;Var|TrigFunc&gt;^n$$Var代指变量，TrigFunc代指三角函数。 因此，我们只需要一个BigInteger存进乘数，一个ArrayList&lt;Unit&gt;存入后面累乘的幂函数。 在修改了单项式的定义后，是不是需要大规模的重构呢？ 先看Flattener： 构造方法：我们在构造方法处使用多态，从而兼容先前构造接口 多项式求幂/相乘：只涉及ArrayList&lt;Mono&gt;的相关处理，在这一层次不涉及Mono内部操作，维持现状即可，算是万幸 单项式相乘：这个没办法，必须重写； 我的重写思路如下： 分两步进行： 第一步：简单的乘数相乘，幂函数容器合并 第二步：合并底数相同的幂函数 第二步中如何比较底数相等，以及如何合并难度不大，留给读者自行探索。 再看负责多项式化简的Poly： 属性不用更改，本来就是Mono容器 出问题了！合并同类项的mergeMono()要大改！ mergeMono()分两步： 比较多项式是否为同类项，是则合并 进行三角函数的化简，这个后面再提 三角函数这才是本次作业最头大的问题，主要在于化简的复杂度实在太高。 TrigFunc与TrigFuncFactor我们引入这两个新的类。 TrigFuncFactor在Parser内使用，其内存放三角函数的类型，及参数对应的Factor TrigFunc在处理成多项式后使用，其内存放三角函数的类型，及参数对应的多项式 三角函数与函数调用被放在了“变量因子”层次，同之前幂函数在一个层次。因此，我们决定，将与TrigFuncFactor置于SubFactor层次，这对sin()^2情况的处理亦有好处。 需要在Flattener和Parser处编写针对三角函数的规则，这里不再赘述。 化简我选择复现讨论区内已有方法，化简规则看这个基本就够了。不过这篇帖子里讲的是是单次化简。 考虑这样一个输入：$$(cos(x)^2-sin(x)^2)^2+sin(2x)^2$$理想的化简结果是1；显然，单化简一次是不够的！ 我们引入这样一个多重化简机制： 两个容器：原始单项式集合monoList和结果newMonoList 外层套while()，由一个布尔变量proceed指示是否继续重复化简 引用一个写回缓存区buffer，实现“化简之后，把结果加回正在遍历的结果列表”的效果 判断单项式集合中mono与newMonoList中元素是否可化简： 若能，则将合并结果写入缓存，并将此mono从原始集合中移除； 若不能，将此mono移动到结果列表中；也就是说，mono无论如何都得删。 双层遍历完成后，**若缓存为空，则说明不可化简，proceed设为否；反之，则将缓存内容写回newMonoList**。 示意如下： 1234567891011121314boolean proceed = true;while (proceed) { &lt;for mono in monoList&gt; { &lt;第一次进行化简时，把第一个mono放入结果列表&gt; &lt;for newMono in newMonoList&gt; { // do something } } if (buffer.isEmpty) { proceed = false; } else { newMonoList.addAll(buffer) }} Hw3引入非递归自定函数与求导因子。 SubFactor引入上述两个新元素，对应修改Flattener规则 求导规定成dx(&lt;Expr&gt;)；在Flattener.getMono(Factor)中，读到求导因子的Subfactor，则将里面的&lt;Expr&gt;化成多项式，随后逐单项式，运用求导规则，获得新的表达式。 可以造一个单项式求导器。 非递归自定函数，按照现有实现改进即可。考虑到我们写递归函数求解器的写法，我们甚至可以直接复用。 改Solver复用已有的Solver。 首先要改lexer，把两个自定函数的符号进行分类，分类就继续分到FUNC内； 接下来是Parser部分；我们在处理递归函数的时候，写了这么一个东西： 123lexer.forward(); // Skip LCurly final int times = parseInvocationTimes(); lexer.forward(); // Skip RCurly 我们在此次修改时，需要这么做： 读取当前Token，看是圆括号还是花括号 圆括号-&gt;普通函数，花括号-&gt;递归函数 圆括号默认调用次数为0 随后，目光转向Solver； 在我初始化Solver时，我采用了如下写法，以获取n行的函数定义： 123456789Solver(int n) { int lines = n; while (lines &gt; 0) { String expr = scanner.nextLine(); Lexer lexer = new Lexer(expr); classify(lexer); lines--; } } 我们初始化一般函数时，n设成1；递归函数，n为3. 其中的classify()方法，是根据输入的定义式，判断递归表达式的类型，从而决定将定义放入递归定义，还是定义表内； 12345678classify() { // Skip Name // Skip { Token typeToken = lexer.getCurrentToken(); // Skip n // Skip } // Skip (} 用同样的思路，在普通函数时，让typeToken变成”0”；随后，就可顺利复用Solver。 那么，我们怎么实现多个函数的解析呢？ 首先，我们需要给Solver添加String name属性，从而记录当前求解器解的是哪一个函数； 随后，我们需要构建一个按名称的函数求解器表，将其传给Parser； Parser在遇到函数关键字时，查找求解器表，获得求解器，随后求解得到表达式。 这部分就成功解决了，接着看求导。 加求导首先，我们要在Lexer里面加dx的规则，这就不多说了。 求导因子会出现嵌套，比如： 1dx(dx(x^2)+x^3) 我们此时仍然不用担心，递归下降的原理保证其可以被处理；我们只需在getMono(Factor)处正确获取多项式即可。 getMono(Factor)处，读到求导因子，调用一个求导器，获取实际多项式。 求导器为方便求导的进行，我们决定对一个多项式求导。也就是说，我们需要先将dx(&lt;expr&gt;)中的表达式先转换为多项式，再进行我们求导的过程。 我们需要求导的表达式，符合如下一般形式：$$expr = \\sum{a*\\prod{^b}}$$我们将其分为以下层次，分别求导： 多项式：如上 单项式：$a*\\prod{^b}$ 幂函数：$^b$ 底数：$$ 这样即可应对链式法则中，幂函数之底数为三角函数的问题。 各层规则如下： 多项式：对各单项式求导，合并各次求导所得多项式 单项式：实现乘法法则，得到求导后多项式 幂函数：先假设&lt;base&gt;为一个整体，按照幂函数的求导方法正常进行；随后，将结果与底数求导结果相乘，实现链式法则。这里可能需要对^0，^1等情况做特殊考虑。 底数：返回一个多项式数字：求导为0；变量：求导为1；三角函数：sin,cos按各自方式求导（内部表达式视为整体）后，与内部表达式的求导结果相乘，实现链式法则。 不难注意到，我们上面需要用到多项式乘法；调用我们已实现的方法即可。 拓展三角化简在Hw2中，我没有搓sin的二倍角化简。在本次作业中，由于出现可化简情况的概率大幅增大，我们决定补齐这一化简策略。 $$(cos(x)^2)’=-2cos(x)sin(x)=-sin(2x)$$ 为了防止化简后，输出长度不减反增，我们规定其： 在其它三角化简后进行。 仅在sin,cos指数均为1时进行 还有化简本身的规则： 乘数绝对值大于1（因为我们的系数是BigInteger）. 总结回顾本次作业，我发现自己的最终成果存在以下问题： Flattener中，ArrayList&lt;Mono&gt;与Poly类混用；这是因为，Poly类是在我发现多项式化简需求后才引入的；我没有狠下心，将单项式容器全部重构为Poly类，导致Flattener处画风相当混乱； 各方法所属的类并未妥善划分；我的多项式/单项式乘法全部放在了Flattener中。虽说获取多项式需要这些方法，但仔细想来仍然不合理：多项式有关计算，应该在多项式类中才对； 部分过程未打包为方法，导致可读性下降：最明显的，就是我赶工赶出来的三角函数化简。 不敢@Override，导致实现深克隆的过程未被打包为方法，而直接出现在过程中； 日后多加改正。","link":"/2025/02/28/OO_U1%20-%20%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"OO_U2 - HW7简要总结","text":"前言讨论区已有一众仙人分享了自己的实现，但我认为我有在降低修改复杂度上更进一步的办法。 考虑到本次作业为本单元的最后一次作业，我的修改方法更注重于降低修改的复杂度，可能存在部分性能的牺牲。 在各位进行参考时，请注意这一点。 本人实现的亮点在于：UPDATE请求的处理，与双轿厢目标楼层的规避，全部利用线程交互实现。 支持UPDATE请求特殊请求由谁分给电梯？针对上一单元的SCHE请求与本单元的UPDATE请求，我都选择交由Dispatcher实例进行处理。 原因无他，为了减少进程交互的复杂性。 我的电梯运行线程Scheduler与电梯信息类Elevator是分离的，我希望Elevator只有Dispatcher与Scheduler两者在竞争。 这两类特殊请求都将直接加入请求池。那我们怎么保证Dispatcher优先处理这两种特殊请求呢？ 答案是，将请求池改为用优先队列实现。这是因为，优先队列的比较条件（提供了Comparator接口）可以自行实现，这为我们当前情况的需求提供了极大的便利。 我们需要保证： SCHE/UPDATE请求在优先队列的首位 剩下的普通请求在后面。 示例如下： 123456789101112131415161718import java.util.Comparator; public class RequestComparator implements Comparator&lt;SubRequest&gt; { @Override public int compare(SubRequest o1, SubRequest o2) { int o1Index = calcIndex(o1); int o2Index = calcIndex(o2); return o1Index - o2Index; } private int calcIndex(SubRequest subRequest) { if (subRequest.isSche()) { return 0; } else if (subRequest.isUpdate()) { return 0; } else { // 按你自己的方法，处理普通请求！ } } } 在Dispatcher从头遍历优先队列时，我们此时即可保证特殊请求被优先处理。 UPDATE请求的处理现在，我们的UPDATE请求放在了Dispatcher处理；此时，聪明的你不难发现一些问题： 在UPDATE请求处理完成前，Dispatcher是不是会被阻塞，不能分配其他请求？ UPDATE显然需要一个类似总控的东西，来控制有关的交互；这个总控难道就是Dispatcher线程本身？ 这样肯定不对。因此，我们在Dispatcher内引入一个子进程，作为UPDATE请求处理的“总控”。 这个子线程怎么创建呢？使用Lambda表达式，可以快速创建新线程： 1234Thread th = new Thread(() -&gt; { // Do something!}); th.start(); 这样，Dispatcher线程就可在处理升级请求的过程中，继续分配其他可分配的请求，而不会发生阻塞。 如果你不放心，还可以用th.join()，在Dispatcher线程的某处，强制处理UPDATE请求的子线程完成后，再继续执行。 总控与两台待升级的电梯的整体交互逻辑如下： 告知两台电梯需要升级，等待两电梯就绪 Scheduler读取Elevator中信息，得知电梯需要升级，进行疏散乘客等“预处理”操作 处理完成后，通知总控该电梯已就绪，等待总控对其进行升级 总控在两台电梯均就绪后，输出UPDATE-BEGIN，随后修改电梯的运行属性，完成升级 具体实现上，我的电梯信息类Elevator采用了ReentrantLock实现锁管理，上文中的两个等待，我们通过创建两个Elevator锁的Condition实现。 电梯如何指示自己已就绪？我采取给电梯增加一个UPDATE运行状态；在电梯完成了“预处理”后，电梯就将进入这一运行状态，并使用Condition.signal()唤醒总控。 下述伪代码仅作示意之用。更进一步的细节，需要各位根据自己的架构实现。 1234567891011121314// ElevatorReentrantLock lock;Condition schedulerUpdateCond = lock.newCondition()Condition dispatcherUpdateCond = lock.newCondition()setUpdateStatus() { this.status = new Status(&quot;UPDATE&quot;); this.dispatcherUpdateCond.signal(); }updateA() { // updateB()同理 // 修改属性，并将电梯运行状态设为IDLE this.schedulerUpdateCond.signal()} 12345678910// Schedulerelevator.lock.lock();...if (elevator.shouldUpdate()) { evacuatePassengers(); elevator.setUpdateStatus; elevator.schedulerUpdateCond.await(); elevator.respondUpdate; // 解除指示电梯需要升级的flag // await()结束后，电梯已被更新为新的状态，按照原有的运行逻辑运行即可！} 123456789101112131415161718192021222324// DispatcherThread th = new Thread(() -&gt; { Elevator elevA, elevB; // 由两层await()，实现两电梯均就绪后再继续 elevA.lock.lock(); if(elevA.getStatus() != &quot;UPDATE&quot;) { elevA.dispatcherUpdateCond.await(); } elevB.lock.lock(); if(elevB.getStatus() != &quot;UPDATE&quot;) { elevB.dispatcherUpdateCond.await(); } // UPDATE-BEGIN //重新分配被取消RECEIVE的请求 elevA.updateA(); elevB.updateB(); // UPDATE-END // 放elevA/B的锁}); th.start(); “三角死锁关系？”看到上面的实现后，聪明的你不难发现，这一实现中，如果调度策略是影子电梯，总控、Scheduler、Dispatcher三者都可能争夺Elevator的锁，很容易出现死锁，不是吗？ 事实上，只要锁管理得够好，这个问题仍然是可以避免的。下面，我将从这三个竞争者在处理UPDATE请求的情况下，分析如何避免“三角死锁”。 Dispatcher:（事实上，关键的只有这一处）在进行普通请求分配时，先判断当前电梯的是否仍在响应UPDATE请求（这一判断不获取电梯的锁），再获取锁 Scheduler/总控：await()在开始等待前会自动放锁，等待结束后会自动重新获得锁；仔细观看上面的实现，你会发现，冲突此时并不存在！ 楼层冲突规避基本分析很遗憾，我们不能通过不到“目标楼层”的方法，规避楼层冲突的问题，否则全部都被改造成双轿厢，且目标楼层均在同一层时，会导致跨越目标楼层的请求全部无法完成。 产生冲突的情况，我们大致可以分为三类： 相向而行：两电梯同时将要到达目标楼层 同向而行：一个电梯尚未完全离开目标楼层，而另一电梯即将到达 一动一静：一个电梯闲置于目标楼层，或正在目标楼层下客，而另一电梯即将到达 在我的实现中，与电梯移动有关的逻辑是这样，相信各位的实现与其大同小异： 123456789101112131415161718192021222324252627// Scheduler while (true) { elevator.lock.lock; try { if (/*一般情况*/) { normSchedule(); } } finally { // 以防中途开锁 if(elevator.lock.isHeldByCurrentThread()) { elevator.lock.unlock(); } }}normSchedule() { if (elevator.status == RUNNING) runningSchedule;}runningSchedule() { elevator.lock.unlock(); // 唤醒Dispatcher；开锁是为了允许Dispatcher此时为其分配可加入的请求 sleep(speed); elevator.lock.lock(); // 更改楼层 // 输出ARRIVE // 判断下一步状态：是下客的WAITING，还是继续RUNNING？} 为了防止不必要的判断，这一判断只应在当前电梯即将进入目标楼层时进行。 在判断之前，我们自然要获取对方电梯的锁，以免对方电梯的状态在判断时改变。 观察我们上面实现的锁管理情况，我们不难发现： 为了避免死锁，我们尽量确保一个线程一次只拿一把锁； runningSchedule()中恰好有一个开锁的窗口，为一次只拿一把锁提供了可能 对方电梯正前往目标楼层时，由于我们上面的锁机制，读取到的对方当前楼层，一定是目标楼层的前一层 在对方电梯的当前楼层为目标楼层时，读出的状态不可能为RUNNING，只可能为闲置的IDLE，或正在下客的WAITING 因此，上述三种冲突情况，我们只需要对“相向而行”这一情况特殊考虑；其余情况，都可以通过判断对方当前位置是否为目标楼层判断。 “相向而行”特殊在哪呢？特殊在无法直接确定需要等待的电梯。其他两种情况中，我们可以确定等待的是当前不在目标楼层的电梯，这一情况不行。 对此，我规定：下方的电梯，规避上方的电梯。 为了减少复杂度，我并没有考虑轿厢中乘客的问题，性能可能因此下降；如各位希望争取这一部分性能，可以以这一条件为最低级条件，将轿厢内请求加入判断条件中。 具体实现自然，为了避免死锁，我们的判断放在在runningSchedule()那一开锁的窗口内。 下文中以cooper称呼对方电梯。（coop-er，能想出的最简洁称号就这个了，笑） 为双轿厢电梯单独写一套运行逻辑自然不大明治。我们将这一判断逻辑融入原有的运行逻辑中，判断只在电梯已被改造为双轿厢（对方电梯cooper !=null）时进行。 123456789101112runningSchedule() { elevator.lock.unlock(); // 唤醒Dispatcher；开锁是为了允许Dispatcher此时为其分配可加入的请求 if (elevator.willEnterTargetFloor &amp;&amp; cooper != null) { cooper.lock.lock();// 获取对方的锁 judge(); // 判断 // 放锁；这样放锁当然有目的，详见下文 if(cooper.lock.isHeldByCurrentThread()) {cooper.lock.unlock(); } } sleep(speed); elevator.lock.lock(); 电梯避让的等待/唤醒，使用挂在电梯信息类Elevator的锁上的Condition实现，命名为conflictCond。 整体交互如下： 在判断出我方需要等待后，我方执行conflictCond.await()，同时通知对方需要规避 通知对方规避时，唤醒对方的Scheduler，以处理对方正处在IDLE，Scheduler正休眠的问题 每当对方远离目标楼层时，就让对方执行我方方法conflictCond.signalAll()，唤醒等待冲突解除的我方。 随后，我们就可得出如下判断逻辑： 1234567891011121314151617181920212223242526judge() { if (elevator.isElevB()) { // 是在下方的B电梯 switch (cooper.getStatus().getStatusType()) { case RUNNING: // 相向而行 if (cooper.getFloorBeforeTargetFloor() == cooper.getCurrentFloor() &amp;&amp; cooper.towardsTargetFloor()) { cooper.setAvoid(); // 通知对方规避 cooper.lock.unlock(); // 避免同时获取两把锁 elevator.lock.lock(); // 没锁就await()，会发生什么？ elevator.conflictCond.await(); elevator.lock.unlock(); } break; default: break; } } // 其他情况 if (cooper.getCurrentFloor() == cooper.getTargetFloor()) { cooper.setAvoid(); cooper.setUnlock(); elevator.lock.lock(); elevator.conflictHangUp(); elevator.lock.unlock(); }} 判断写好之后，该通知对方规避了，响应机制当然也得有： 123456789// Elevatorpublic void setAvoid() { this.awaitingAvoid = true; this.idleCall(); }public void respondAvoid() { this.awaitingAvoid = false;} 改完这些还不够，我们需要对WAITING/IDLE两个状态的转移规则稍加修改，使得在一动一静的情况下，两种状态转移后，可以响应规避请求： 12345678910111213waitingSchedule():... // 原有实现// 接在原有实现之后if (entersIdle) { if(shouldAvoid) { /*让电梯移动到下一层，类似SCHE，但到了之后不开门*/ respondAvoid() } else { setIdle() }} 1234567891011idleSchedule(): if (keepsIdle) { if (shouldAvoid) { /*让电梯移动到下一层，类似SCHE，但到了之后不开门*/ respondAvoid() } else { // 原逻辑 }} else { ...} 对于同向而行的情况，我们还需要继续修改RUNNING下的运行逻辑，使得避让请求被正确响应： 123456789101112131415runningSchedule() { ... // sleep()完成 /*更改楼层*/ /*在楼层更改时，若远离了目标楼层，暂存一个flag*/ .... // 状态转移 // normSche原有逻辑结束 if (flag) { elevator.setUnlock(); // 同样，此处开锁是为了保证一个线程只拿一把锁 respondAvoid() cooper.lock.lock(); cooper.conflictCond.signal(); cooper.lock.unlock(); } // 需要Scheduler线程的`while(true)`处能够正确处理中途开锁的锁释放问题，可以看看本文前面的实现} 做到这里，我们就成功的使用纯线程交互的方法，完成了楼层冲突的处理，不需要引入任何新的类来进行管理。 调度再次，我们本单元求稳为先，选择的方法不一定最优。 我的原调度逻辑（见HW5，6总结）类似影子电梯，在出现双轿厢的时候也犯了难。比起编写新逻辑，我选择最大程度复用原有的调度逻辑。 在原有的调度基础上，我们需要添加是否在运营范围内的判断。 调度第一步，沿用原有逻辑，对所有电梯评估请求是否可分配，选评价指数最低者。 同时，在这一步中，记录下所有的双轿厢电梯。 此处记录的并不是双轿厢电梯对，而是其中的每一个电梯。 例如：2、3是一对双轿厢电梯，我们这里记录的是：电梯2、电梯3，而不是[电梯2，电梯3]。 若第一步未能分配，则进行第二步，“拆请求”。在第二步中，我们只对双轿厢电梯进行评估。 将原有请求，以当前评估电梯的目标楼层为节点，按先后顺序分成两段； 在第一段请求完成后，再由Dispatcher分配第二段请求。 “拆请求”如何实现？我们需要修改我们已有的乘客请求类passengerRequest，在其属性中加一个passengerRequest followingRequest，存储当前请求的后半段。 在下电梯的时候，需要判断是否包含后续请求，有则OUT-F，并将后续请求放回请求池，没有则OUT-S。 判断是否可加入，与计算代价指数的逻辑不变。 不过，我们选取电梯的逻辑发生了变化，选取优先级如下： 可行楼层跨度最大 原设计中，评估指数最小者 选取楼层跨度最大者，是因为，我们无法保证后续换乘的次数；换乘可能会造成额外的等待时间，且额外等待时间难以预知。楼层跨度尽可能大，可以尽可能减少换乘次数，一定程度缓解这一问题。 线程交互不难注意到，对于双轿厢电梯对的其中一个电梯，在IDLE，无请求，且closed的条件下就结束，在这里肯定不对劲。不这样的话，目标楼层的冲突没法规避。 我采取了一个相对粗糙的办法： 电梯的close()由Dispatcher调用，这是我的原有设计 在close时，Dispatcher用一不加锁的方法，获取当前所有电梯的状态；只在所有电梯都处在IDLE状态时，才将所有电梯close()，否则wait() 保证电梯在进入IDLE时，会唤醒Dispatcher 至此，我们完成了HW7所需的所有改造。","link":"/2025/04/17/OO_U2%20-%20HW7%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/"},{"title":"OO_U2 - HW5,6阶段性总结","text":"前言 我的调度算法，与我的架构实现耦合度较高，因此我不得不先提一些我自己的电梯实现；不需要的同学，欢迎直接跳开“电梯实现”部分。 这算是本人两周以来的一个总结吧，终于有时间写了… 浅提电梯实现读前注意，本人的设计并非最佳，其中有不少会引起复杂度增加的设计，请各位参考时务必谨慎。 概况在完成HW6后，本人的整体架构如下： 其中，电梯信息与电梯运行进程分离，便于维护。 我的电梯，将运行状态分为以下几类： IDLE：闲置，此处与常理理解中的闲置是一致的，不多赘述 RESERVED：预约，在闲置状态的电梯，收到起点与电梯当前所在位置不同楼的请求时，进入的移动状态。 RUNNING：运行，电梯处在非预约状态时的正常移动状态。 WAITING：等待，电梯停靠，进行上下客时进入的状态。停靠完成后，视情况转入RUNNING/RESERVED/IDLE状态。 同时，我们还需要记录电梯的运行方向，现规定： 1：上行 -1：下行 0：仅在进入IDLE时设为此值。 在电梯进入WAITING时，方向将被设置为下一步要移动的方向 电梯内亦有一子请求表，记录满足以下条件的请求： 请求与电梯运行方向一致 记录当前方向的所有请求；比如，我们的电梯正在处理一个F1-F3的请求，现在处于F2；此时，若有一F4-F5的请求，则该请求可被指派给电梯，加入子请求表 存储状态的额外信息上面提到，我们的子请求表只允许同向请求加入；在我们现在的实现下，这种情况当然会产生： 电梯在F3，IDLE 出现了一个F1-F7的请求，电梯进入RESERVED，空放到F1 电梯从F3空放去F1途中出现一个F2-F1的请求，我们自然希望捎带它，将其加入子请求表 也就是说，空放方向与发出预约的请求的方向反向。 我们自然需要一个地方暂存这个预约请求；我选择通过继承的方法，将其存在状态内。 具体而言： 上面四个状态均属于一个Status类，内有一enum Type属性，记录当前状态类型 若一个状态需要记录额外信息，则该状态作为Status的子类，额外信息作为子类的属性，存在子类中。 我们此时只需对RESERVED，WAITING两个状态记录额外信息。 RESERVED： allowPickUp：中途是否允许捎带 requester：进行预约的请求。允许为null。 WAITING： prevStatus：进入WAITING前的状态。 欲知为何如此，请继续看下文。 兼容SCHE请求不知各位是否发现，在HW6引入的临时调度，跟我们上面提到的RESERVED略有相似之处？ 我们要让我们的现有设计兼容SCHE请求，只需做这么几件事情： SCHE-BEGIN前，把途中无法捎带的请求赶回请求池； 在临时调度至不同层时，SCHE-BEGIN对应转入一个 requester = null，不允许捎带的RESERVED状态 确保已有的RESERVED状态下的电梯运行规则，能够处理上述的RESERVED情况 就这样，我们就做完了SCHE请求的电梯运行部分；剩下的，只需要实现指派电梯进RESERVED的逻辑，很省事吧！？ 等待状态的转移规则WAITING的状态转移规则如下： 先前为RUNNING：若仍有请求未到终点，则恢复RUNNING若请求已全部满足，则进入IDLE 先前为RESERVED：若未到预约者起点，则恢复RESERVED若到达了预约者起点，则进入RUNNING，同时将暂存的请求加入子请求表 先前为IDLE：直接进入RUNNING，因为我们保证，IDLE下的电梯被预约后，直接进入RESERVED状态，此时必是因为，有一起点与IDLE状态下电梯所在位置的请求被分给了电梯。 调度算法交互方面，我采用的是一Dispatcher对多个Elevator的实现，与绝大多数做法一致。 大家都知道影子电梯，不过它需要模拟电梯的整个运行过程，实现略显复杂；那么，有没有一个在复杂度和影子电梯的高效率之间折中的方案呢？ 是有的。我的这个策略在思路上与影子电梯有颇多相似之处，只不过： 只需要计算（模拟）当前请求的运行时间 已指派给电梯的其它请求的估计，利用优先级机制实现 是否允许加入进行计算之前，Dispatcher需要得知当前正在评估的电梯，能否接受当前待加入的请求。 可加入的规则如下： 若电梯此时在IDLE状态下，直接允许加入，否则进行下述流程 请求方向需与电梯当前运行方向一致；方向有关的说明见上文。 电梯同向，且电梯此时没有超过请求的起点 如果状态为（RESERVED）/（WAITING，且前一个状态是RESERVED），则：RESERVED状态需允许捎带若预约请求方向与当前运行方向相反，则待加入请求的终点不得超过预约请求的起点 加入后，不会出现电梯满员的情况 “电梯满员”视个人实现不同，判断逻辑可能不同；我这里就以我的实现为例，谈谈我的判断逻辑。 正如上文所述架构实现，我们一个电梯的子请求队列不仅包含了当前在电梯内的请求，还包含了将来电梯要捎带的请求； 我们的判断逻辑是，假设请求加入了子请求表，得出各楼层处，最多同时出现的请求数； 这一“同时出现的请求数”，反映了那一运行区间内，电梯内的人数。 若各区间的同时出现请求数的最大值，大于电梯容量，则认为此时加入请求会导致超员。 如图所示，待加入请求在F2-F3区间会导致超员，故我们不应加入这一待加入请求。 需要注意的是，如果采用了上文RESERVED状态的实现，若预约请求方向与电梯空放方向一致，此时还需将预约请求放进上面的图里进行比较。 计算评价指数在上述复杂的判断后，我们终于可以开始计算了… 我们的计算公式如下： $$index = index_{base} + priorityPenalty * elevStopTime$$ $index_{base}$我们先需要得知： $dis$：电梯所在位置，与请求起点的楼层数 $travel$：请求跨越的楼层数 $stopCount$：请求沿途需要停靠，以让自己进电梯/捎带其它请求；stopCount即中途停靠的次数 随后即可算出当前请求的运行时间，作为我们评价指数计算的第一步； $$index_{base} = (dis + travel)*elevSpeed + stopCount * elevStopTime $$ $priorityPenalty$优先级惩罚，是所有请求的优先级惩罚之和： $$priorityPenalty = \\sum_{i=1}^{n}{penalty_{R_i}}$$ 对于一个请求$R$，设其优先级为$priority$，楼层跨度为$travel$，则我们规定该请求允许的中途停靠次数$maxAllowedStops$如下：$$maxAllowedStops = round(travel * (1 - \\frac{priority}{100}))$$其中，$round(x)$取$x$最靠近的整数。 在我们进行评价指数的计算时，我们先假设待加入请求已被加入；随后，对原有的请求$R_i$，算出加入后的总停靠次数$stops$。 若$stops &lt;= maxAllowedStops$：$penalty_{R_i} = 0$ 否则：$penalty_{R_i} = (stops - maxAllowedStops) * priority$ 小总结由此，我们就可以算出各个（可加入请求的）电梯的评价指数，选择评价指数最低者加入。 上述是一个相对简单的模型，相信各位有更好的实现。 评测方案我选择构建评测机框架，留出随机数据生成器（dataGen）与正确性检查器（Checker）的接口。这样有利于提高不同题目下评测的灵活性。 评测机框架方面，我构建了一个可以评测多程序、多测试点的多线程评测机，按照以下两种策略运行： 测试深度优先：评测机优先对一个待测程序，测试多个测试点 测试广度优先：评测机优先对一个测试点，测试多个程序 评测机框架建议允许添加数据生成器生成的数据以外的数据，从而为人工构造高强度数据提供可能。 运行测试程序方面，我选用了Python的subprocess库，其中的POpen方法十分有用，不仅可以指定子进程的工作目录，还可重定向子进程的输出。 注意到，我们的数据投喂器读取的是**当前工作目录下的stdin.txt**；因此，我们可以通过指定不同工作目录的方法，来让投喂器同时测试多个样例。 随后，我们即可使用数据投喂器+打包好的.jar进行评测；两个子进程需要用管道串起来，实现如下： 123456789101112131415input_process = subprocess.Popen( ['input.exe'], # input.exe 读取当前目录的 stdin.txt cwd=case_dir, # 设置工作目录为测试用例目录 stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True )java_process = subprocess.Popen( ['java', '-jar', os.path.join(target_dir, jar_file), f&quot;-Xmx{memLimit}&quot;], stdin=input_process.stdout, stdout=fileout, stderr=fileerr, text=True ) 据闻Python的psutils库有办法记录CPU使用时间，不过我的尝试没有成功，希望做过尝试的同学多多分享经验:P 我两次作业的随机数据生成器与Checker均先由AI生成，再由人工进行细节修改。 注意到，AI生成的Checker并不完全准确，在HW6时这一问题尤为显著，需要多处人工修正；在寻求AI工具的帮助，节省时间的同时，请务必仔细检查AI生成的工具是否能如预期般工作。 之前写过的一些总结 使用ReentrantLock，实现更灵活的锁管理策略 在IDEA内部，进行更高效的死锁调试 总结 本单元，我感觉最需要的其实是细心，不然线程间交互很容易出现问题。 架构设计同样起到了关键的作用。本人架构中RESERVED状态的抽象，大大节省了本单元的开发时间。 我认为，只要架构： 易于维护； 复杂度低（可以归进上条）； 运行效率在可接受范围内； 就可以算一个好设计。 不过，我自己不得不承认，我本单元架构在不少实现细节上的复杂度实在太高，因此带来的BUG与维护的不便不在少数。 本单元亦让我直观地感受到了算法和数学模型，于程序的重要性何在。 本人实现中，判断电梯是否满员的问题，可以抽象为计算一个二维空间内，所有线段的最多重叠次数；没有算法的帮助，计算效率很难提升。 处理优先级问题的方法，其实就是简单的数学建模。 感受到了AI的力量。使用AI生成checker+人工修改的效率，远比纯手搓要高。","link":"/2025/04/17/OO_U2%20-%20HW5,6%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"},{"title":"OO_U3 - JML","text":"本文就是本人的博客作业。本单元除了优化方法外乏善可陈，因此我没什么额外要说的。 前言本单元以一个简单的社交网络为背景，要求各位同学按照题目给出的JML规格，进行规格化开发。 此外，本单元中还要求各位同学对部分关键方法构建JUnit单元测试，同时也引导了同学们利用大模型辅助规格化开发。 测试过程不同类别的测试按照要求，我们把集中类型的测试先简要介绍一遍： 单元测试：从开发者角度，对最小可测试单元的测试，比如方法 功能测试：从用户角度，对程序的某个特定功能进行测试 集成测试：各个功能组合起来，整体进行测试 压力测试：集成测试上更进一步，以大数据量/多边界条件等，测试程序的性能和正确性 回归测试：在原有程序基础上进一步开发后，测试修改后程序是否保证原有功能的正确性 这集中测试，在我看来，是软件开发的不同阶段进行的： 单元、功能、集成测试：在开发过程中进行，旨在验证当前完成的开发工作是否正确 压力测试：在开发工作已有整体成果后进行，旨在验证Corner Case等严格条件下的正确性/效率 回归测试：在原有基础上继续开发后进行，旨在验证原有功能不受新增功能影响 数据构造策略我选择使用数据生成器，并按照一定的指令出现权重来随机生成指令。 123456789101112131415possible_instructions = [&quot;ap&quot;, &quot;ar&quot;, &quot;mr&quot;, &quot;at&quot;, &quot;dt&quot;, &quot;att&quot;, &quot;dft&quot;,&quot;qv&quot;, &quot;qci&quot;, &quot;qts&quot;, &quot;qtav&quot;, &quot;qba&quot;, &quot;qcs&quot;, &quot;qsp&quot;,&quot;coa&quot;, &quot;doa&quot;, &quot;ca&quot;, &quot;da&quot;, &quot;foa&quot;, &quot;qbc&quot;, &quot;qra&quot;,&quot;am&quot;, &quot;arem&quot;, &quot;afm&quot;, &quot;aem&quot;, &quot;sm&quot;, &quot;sei&quot;, &quot;dce&quot;,&quot;qsv&quot;, &quot;qrm&quot;, &quot;qp&quot;, &quot;qm&quot;]weights = [12, 15, 8, 10, 6, 7, 6, # ap, ar, mr, at, dt, att, dft7, 4, 3, 4, 4, 3, 4, # qv, qci, qts, qtav, qba, qcs, qsp8, 4, 10, 5, 8, 4, 5, # coa, doa, ca, da, foa, qbc, qra10, 8, 8, 10, 15, 8, 3, # am, arem, afm, aem, sm, sei, dce6, 5, 5, 6 # qsv, qrm, qp, qm] 注意到，本单元作业的输入，可能存在以下情况： 增删密集型（频繁ap/mr/coa等） 查询密集型（频繁qtvs/qcs/qsp/...） 上述两者兼备 我们由此可以对应调整数据生成器中，各类指令的权重，以生成多种情况下的测试数据，补足随机测试过于随机的短板。 大模型辅助本单元中，我主要利用大模型，辅助了规格阅读、自动测试两个部分。 当前的大模型在具备了思维链等技术后，并不需要过多的提示词，多了反而会影响模型的表现。 我们要做的，就是给足大模型需要参考的信息。就本单元而言，大模型需要的信息，无非指导书，以及各个文件里存放的JML规格。 如果需要模型按某个流程执行任务，再在提示词里面描述清楚自己想要的流程，就可以了。 规格阅读随着大模型的日趋成熟，以及JML语料每年的增长，当前的大模型已经可以做到：用户用极少的提示词，给足必要的信息，即可让大模型在JML有关问题上，输出质量较高的结果。 以下是我使用Deepseek辅助阅读JML的一次尝试；其输出结论确与规格描述的结果一致。 考虑到AI输出有时仍不可靠，在本单元中，我均采用了先本人阅读一遍规格，得出规格想要规定的结果后，再让AI阅读一遍，随后将自己的结论与AI的结论进行比较的模式，以确保我对规格的理解正确。 自动测试在第二单元尝到了利用已有评测机框架，由AI代劳数据生成与Checker的甜头后，我在本单元继续延续了这一自动测试思路。 具体而言，我向AI提交了这些输入： 课程指导书（通过网页审查元素，可以得知其存在一个content.json中） 存有规格内容的各个.java文件，合并为一个文本文档，规避AI工具的文件上传次数限制 示例datagen.py与checker.py，旨在让AI在已有评测机接口下，编写数据生成与正确检查器 一定的提示词 本单元中，我的提示词如下： 1请参考main.txt中，各类的JML规格描述及Runner类的行为，以及exception.txt中各种异常的输出，参考content.json中指导书的数据范围限制，为我编写本次作业的数据生成器（datagen）与正确性检查器（checker）。上传的datagen与checker作为示例，你需要保留其中的接口。 而在第二单元，一次作业的指导书，依赖上一次作业的指导书补全不变的设计要求的情况下，我的提示词是这样的；此时，我在文件中上传了各次作业的指导书。 1请帮我生成一个第七次作业的数据生成器（datagen）和正确性检查器（checker）；你应该先查看第五、第六次作业，再查看第七次作业在先前两次作业上做的修改，再开始工作；我已附上写好的datagen和checker，请仿照其格式进行编写。 在自动生成datagen/checker的过程中，我尝试了Deepseek-R1/Gemini 2.5 Pro/o3-mini等模型，均能取得一定成果。生成的datagen一般不存在问题，但生成的Checker虽整体框架无误，但在边界条件的检查上往往会存在疏漏。 针对这个问题，我选择“边测试，边修改”：在出现Checker报错时，先检查我自己的程序是否有问题，在确认自己的程序无误后再检查checker的问题。如果修改起来很方便，自己改了即可，不方便则直接指出问题，让AI工具进行修改。这一模式我已在多次作业中确认可行，且获得了可观的成果，可以在后续的第四单元继续使用。 生成的datagen出问题的情况也存在，主要表现在部分指令不在生成范围内。这个问题，一般给AI指出问题，并让其修正即可。（假设之前你已经给足了参考信息） 架构设计实不相瞒，这单元的架构已经给定了设计，可发挥的空间并不大，也没有什么重复介绍的必要。这一部分介绍的，主要是优化方法。 并查集这主要是为isCircle()方法服务。我们需要快速判断关系图内，两个人是否连通。诚然，使用BFS更通用，但是利用并查集，查找的最好情况，复杂度可以达到O(1)。 具体而言，就是对于关系图内各节点（人）进行聚类： 每个聚类，选取一个节点作为代表 每个节点记录自己所在聚类的代表 通过比较每个节点的代表是否相等，得出二者是否在一个聚类内 一个聚类中，可以保证各节点关系连通 注意到，并查集的维护是个严重的问题。我选择在Network内维护一份完整的关系图，同时引入脏位机制；在发生关系删除时，脏位置高；在查询时，若脏位有效，则按照关系图重建并查集。 并查集内部引入路径合并，以及按节点数的启发式合并，避免退化成链表带来的性能下降。 脏位众所周知，当我们修改了一个状态后，只要我们不查询它，我们是不知道它改变了的！ 因此，我们引入脏位： 对于某个不好维护的状态 状态受到影响，要发生改变，且有其他信息知道如何改变时，不改变状态，而是把脏位置1 在查询状态时，若脏位有效，则按照其他信息重建状态，否则直接返回状态 利用这一思路的方法： queryCoupleSum() ，在关系权重发生变化时，难以一下就得知配对数变化 getBestContributor()，文章删除导致贡献变化，不遍历很难得知最佳贡献着 queryBestAcquaintance()，在关系权重发生变化时，不遍历当前熟人，很难得知最佳熟人 动态维护在我们向一个集合加入一个元素时，我们便可动态维护一个集合整体的属性，从而避免查询该属性时遍历整个集合，导致效率下降的问题。 以queryTagValueSum()为例，每发生一次关系的加入/更改/删除，Tag内的valueSum属性就对应进行加减。 queryTagVar()思路与之类似，不再赘述。 链表的维护主要是为了处理queryReceivedArticle()。 在文章发生删除时，我们需要对Person接到的该文章进行删除。链表的删除一直是个问题，一般采取遍历链表，找到目标再删除的方法；很显然，在链表大小较大时，如此删除的开销实在太大。 而且，包装好的LinkedList中的方法，无法做到高效移除链表中所有符合某一规则的元素。在这个情况下，我们希望一下移除链表中，所有文章ID为指定值的节点。 注意到，对于双向链表，如果已知要移除的节点，那么，只需修改其前后节点的连接即可，时间复杂度可以做到O(1)，十分诱人；由此，我萌生了一个想法：在原有双向链表的基础上，再使用哈希表+链表，记录一个文章ID值对应的所有节点。时间复杂度是O(n)，不过n取决于已有的同文章ID节点数，相较遍历整个链表，效率也已经足够了。 随后，我自行实现了一个IndexedLinkedList类，实现了上述思路。较我原有的实现方法，这么做的时间、空间复杂度均有所下降。原有思路见下文“性能优化”。 这么做的性能瓶颈，在于额外HashMap的维护。 杂项 - 增量化开发众所周知，解引用、条件分支等等都是有时间开销的；为了尽可能减少这一开销，我们引入“增量式编程”。 举一个例子： 12345678// 两次解引用开销int var1 = persons.get(id).getVar1();int var2 = persons.get(id).getVar2();// 一次解引用Person p = persons.get(id);int var1 = p.getVar1();int var2 = p.getVar2(); 这能够带来一定程度的效率提升。 性能相关上面提到，我在选择带索引双向链表前，使用了另外一个方法，这里简要做一个介绍。 既然链表删除要遍历，那我可不可以不删呢？ 答案是可以的。 注意到，articles容器只可能有两种操作： 在头部插入新节点 删除容器中所有ID为特定值的节点 且： 在ID为特定值的所有节点删除后，后续仍有可能加入ID位为该值的节点 删除和加入不可能同时发生 删除的区间，和删除后新加入的区间不相交 因此，我们可以： 链表只增不删 用一个HashMap&lt;Int, Int&gt;，记录当前链表中，一个ID有效节点的个数 每加入一个节点，对应ID有效次数加1，没有键值就设为1 全部删除时，直接撤销键值对应 并在query/getReceivedArticle处动手脚： 从头遍历，对于某个ID的节点，以HashMap对应键值，作为遍历中，读取该ID节点的次数 若次数&lt;=有效节点数，则认为该节点有效，将其加入返回的容器中 若次数大于有效节点数，则认为该节点是被删除操作删除的操作，忽略之，从下一个节点继续遍历 这样就可以规避删除的遍历问题。 但是，这么做有两个严重的问题： 内存溢出：这一机制对链表只加不减，得亏强测强度仍然不算大，不然这样是有可能MLE的 极端情况：考虑两个节点之间，间隔了数量极大个无效节点；这样的话，我们遍历的效率会急剧降低，且这一代价每次查询都存在，我们无法保证这种情况不发生 因此，我换到了上面使用带索引双向链表的方法。换了之后，对于Hw10的强测测试点，不仅有时间效率的提升，也解决了上面两个严重的问题。 对规格的理解在谈这些问题之前，我们需要明确，规格描述的是什么？ 事实上，规格描述的是方法执行后的结果，而非方法执行的过程。 规格中出现的“过程”，可以认为是测试流程，也可以认为是用来描述结果的过程。 规格中出现的容器实现等等，只是为了举例描述一个结果，可以认为其实现是一个抽象概念 因此，我们能发现一个显而易见的结论：规格不规定达到结果的过程，规格与实现分离因此合理，我们自然也可以在实现过程这一部分自由发挥，只要保证结果符合规格即可。 JUnit有关我认为测试可以分为两部分，一是不同测试上下文，二是方法自身的正确性检验。 我们先谈方法正确性检验的部分吧。 上面提到，规格中出现的”过程“，可以认为就是测试流程。因此，按照规格中描述的过程来编写测试，即可保证测试通过与符合规格等价，这是最简单的办法。 当然，我们也可以根据规格描述的结果，以另一个测试流程来检验；不过，既然规格已经告诉你测试流程了，除非这一新的测试流程，在保证检测正确性的前提下，效率更快， 我们没有不按照规格给的测试流程编写测试的理由。 综上，照抄规格，就是实现方法正确性检验的最简便方法。在这个选择下，“Junit测试检验代码实现与规格的一致性的效果”这个问题更不成立，因为我们的method测试流程，本来就是跟规格描述完全一致的。 方法正确性检验后，就是构建不同的测试上下文了，换言之，构造测试数据。事实上，我在本单元作业对JUnit的测试中出现的问题，都是因为构建的测试数据不够强大，未能考虑到部分边界条件。 那我们怎么知道要考虑什么边界条件？这就是“利用规格信息”要做的了。我们需要从规格中得知： 待测试方法要求哪些属性不变，要变的属性怎么变 待测方法涉及的属性，会受其它什么方法的影响 明确好这两点后，我们基本就能找出所有的边界条件了。 本单元学习体会算法的重要如果说前两个单元是为了考察同学们对程序整体架构的设计能力，这个单元考察的就是：同学们在架构确定的前提下，进行具体实现的能力。 长期以来，我都对算法不甚重视，期望用架构或多线程等方法，代替算法解决问题。本单元打消了我这一错误的偏见，让我真正认识到了算法的重要性。 具体而言，查询关系是否连通这一问题，在并查集以外，我实在想不出效率更高的办法，这就是算法影响程序效率的一个实例。 测试的重要性本单元开始的第一次作业，我认为严格按照规格描述的结果实现，就不会产生问题，我因此没搓评测机。然后在强测就出现了问题，最后检查发现，是自己的一处愚蠢的笔误（笑，把value赋值到id上）造成的；在有评测机的情况下，这个问题很好发现，但我没搓评测机，这个问题我就没发现。 自此以后，我每单元都搓一次评测机，避免这种事情再次发生；后面也确实没有发生过。 时刻认为自己写的程序有Bug， 这个思维模式还是很重要的。 JML为何难以推广？形式化验证的需求的确很小，但我认为JML难以推广，是可读性出了问题。 我们简要比较一下，几种语言如何描述结果： 自然语言：操作后，id1对应成员的 | 包含id2对应的成员的 | 所有tag内，不再包含id2对应的成员 JML语言： 12@ ensures (\\forall int i; 0 &lt;= i &amp;&amp; i &lt; getPerson(id1).tags.length; @ \\old(getPerson(id1).tags[i].hasPerson(getPerson(id2)))==&gt;!getPerson(id1).tags[i].hasPerson(getPerson(id2))); （伪）数学语言：$$\\forall t \\in Persons[id1].Tags[], prev(t.hasPerson(id2))\\rightarrow !t.hasPerson(id2)$$ 不可否认，自然语言在表达上最直观凝练，但是它无法避免产生歧义的问题；在形式化验证/规格化开发等严谨的前提下，自然语言一般不被使用，或仅作为辅助说明出现。 这就是我们为何要引入规格语言。 但是，不难注意到，与我们上面的（伪）数学语言相比，描述相同的结果，JML语言花费了显然更多的篇幅；这是为什么？ 一言以蔽之，JML的抽象程度还不够，没有脱离具体实现。 事实上，JML在尝试用一种基础的，具体的实现（比如容器认为是数组），或一种基础的，具体的过程（比如容器的查找过程），来尝试描述自己想要的结果。 在本人对形式化验证的简单了解后，我了解到了TLA+这门形式化验证语言。其完全基于数理逻辑，而非软件开发思想，从而做到了高度抽象、脱离具体实现。最后的描述效果，与我们上面随手写的（伪）数学语言基本一致，严谨而简明。 当一个工具带来的收益，远远小于其带来的负面影响时，是否采用它就很值得商榷了。JML确实做到了严谨描述结果，但其带来的可读性问题十分严重。与之比较，作为当前主流的形式化验证语言，TLA+采用了数理逻辑语言进行结果的描述；虽然有初始的学习成本，但其保证了描述的可读性。相信这就是JML难以推广的原因吧，这也让我认识到了选好工具的必要性。 在研究这个问题的时候，我也再次感受到了 “抽象” 这一哲学，在计算机科学中的重要作用。抽象不仅有利于找出通用的解决方法，更有利于准确地描述问题。","link":"/2025/05/13/OO_U3%20-%20JML/"},{"title":"送给组内信类新生的一点点私货","text":"序首先，欢迎各位成为北航士谔书院的一员，也很荣幸能与大家共处同一梦拓小组！ 本文将尝试对大家初入大一可能遇到的部分问题进行解答，以备各位不时之需；同时夹带大量私货，欢迎各位参考😋 本文是按苯人自己一年来的经验，想到什么写什么写成的，应该能涵盖各位可能碰到的不少问题。若有其它没有覆盖到的问题，欢迎各位联系交流！🤗 同时推荐一份民间编写的学生指南，供各位参考；由于这个指南全靠民间热心的各位大神自发更新，里面的消息可能有不少未及时更新或不准确，仅供参考，真有拿不准的问题欢迎问导员或者梦拓！： 【腾讯文档】北京航空航天大学学生手册https://docs.qq.com/aio/DQXdSc0hXYlFVcnVY 另有一个比较抽象的新生指南：https://github.com/BUAA-Wjay/BUAANew（可能需要翻墙），里面消息可能需要自己甄别一下， 尤其是各类非官方群，毕竟那里通常是卖课、推销、诈骗的高发区。 英语课程选A，还是选B？在各位联系到作为梦拓的我的不久之后，相信大家已经对英语课程的分级考有所耳闻了。虽说会参考分班考成绩来分，但这个还是需要各位填选A班还是B班的志愿；那么，选哪个呢？ 可能有同学担心，两个班的课业压力差别较大；又或者是在各类吹水群里，听说了前一届甚至前几届前辈对A/B班的评价，对A/B班的学习状态已有了刻板印象……自然，课业上的压力，两个班的区别当然是存在的。但是！A/B班的课业压力孰轻孰重，各届的情况存在巨大的差别，前人的经验或许有帮助，但在这很有可能不具参考价值。 比如，我的 上一届（2022级） 普遍反映A班的作业和杂事都很多，难度大云云，B班就很轻松；然而！在我的这一届（2023级），情况却恰恰相反。我选择的A班反而每周十分轻松。课堂氛围轻松不说，除了课堂展示以外的杂事与作业真不多，作业检查程度也不算太严；反观同寝室另外3位选择了B班的同学，每周都会同各类神奇的英语作业（比如：假设自己要留学，做留学的出行等一系列计划）斗智斗勇不说，据其描述课上也很忙…… 而且，两个班最后的期末考试考的都是同一套卷子。从只看成绩的角度而言，选两个班的差别可谓是没有。 因此，个人认为，各位按照自己的实际英语能力进行选择就好。如果硬要用量化指标界定能力好坏的话，各位前辈得出的经验是：高考英语140分以上，进A班应该就没问题了。这一点我认为还是可以参考的。 学习方法要转变吗？一个字：要。上大学必须自学为主。 在高中的时候，各位都习惯的是听老师讲课，自己照单全收即可；但是，在大学，这个想法是非常危险的！ 且不谈当下大学的本科教育质量之差，现在照念ppt上课的方式已是常态。 不自己课下深入学习，只靠课上听讲是不可能学好的！ 更何况，现在不少老师（包括北航）只管自己讲自己的，完全不管自己讲的时候台下的同学是否能听懂。我不觉得这种情况下，听课效果能有多理想，这样真不如自学。 我就是在大一上的时候仍然心存听老师上课的幻想，直到大一下才“放弃幻想，准备斗争”，最后成绩并不亮眼；当然，这部分在最后扯有关我的事的时候再说。 总之，自学为主，这真的很关键！！ 有什么办法预习吗？有！办法还不少！这里稍微分享一点经验，同时也会简要掺一点各课程的上课概况的私货 宇宙安全申明：据说培养方案有改，课程开设方案和上课状况可能都有差别，仅供参考！ 进入信息大类，各位大一上学起来要花点功夫的主要就是工科数学分析、工科高等代数、C语言程序设计三门课程。剩下的基本没预习的必要。 两个学习资料的来源开始之前，个人先推荐两个学习资料的来源渠道。 一个是北航士谔书院的学业支持中心的北航网盘资料库。里面包含了大一整个学年可能用到的往年题，课件等可能有用的学习资料，同时也有一部分竞赛四六级资料。如果各位对预习有所兴趣，完全可以看着里面的课件ppt来预习 （事实上，大学，至少北航，上课基本不看教材，而基本只看ppt，知识点等等都在上面；更有甚者是念ppt上课，这也很常见） 。 里面的资料，相信对各位一定有所帮助：https://bhpan.buaa.edu.cn/anyshare/en-us/link/AAE382BC57552F47C3963B94EA8821E684/8432FD008DFD4F3D9256370735A84832/8EA3C8E70B7941ED9AA164501F0950D2/2E077C8617154E118896618A7C295703/8C5F58E5D4F94DD39151E336665D507B/7A3FF43284484037A2515529D9B0478F?_tb=none 另一个是一个往届前辈运营的一个微信公众号：三文鱼卷。 （以防各位顾虑，纯推荐，没接广，23333） 这里面可以查到 包括但不限于信息类 的大一学习指南，里面整理的资料也挺全。但是里面整理的资料难免出现分类混乱，质量参差不齐等问题，大家打包下载之后自己注意一下就可以了 但是，这个公众号能提供的资料不止信类大一上、下的学习指南。搜索航类大一上、下的学习资料，你又能获得另一份数分、高代的学习资料。这是因为，两个大类的同学除了少数课程，大部分课程都是相近的。（注意，用之前还是要核对一下，比如航类大一上的线性代数，大一下的物理教材就和信类不一样）这时，您不妨在航类的资料库里翻一翻，说不定能够补足信类资料库里缺乏的东西。（比如说，电子版教材，这个我只在航类的资料库里看到过） C语言程序设计正文先从程序设计（下称程设）开始吧。这一门课程主要教授C语言（纯C，没有C++/C#）的基本使用，教的程度大概也是知道基本常用知识，能用但不知道背后原理 （事实上，也没多少学校会在课上耐心教背后有趣的底层原理，比如头文件是怎么回事） 的水平，并不算太深入。因此，不要对此有太大的心理压力。 如果您恰好是前oier，大佬接我一拜😭🛐，这门课您根本不用担心！ 这一部分打好C语言的基础就可以了，后面大一下的数据结构课程就是建立在这门课的基础上的。 预习这一部分课程，看 《C Primer Plus》 这本经典的C语言教材即可。在各位上课的时候，也可以把这本书当作自己的正式教材。 又或者，试试这个：《Learn C the Hard Way》（https://wizardforcel.gitbooks.io/lcthw/content/preface.html）。 只不过，这个教材涉及到Unix/Linux，可能更适合对Unix/Linux已经有所了解的同学。不熟悉也没关系，如果目的只是学C语言的话，碰到涉及Linux和valgrind等工具的部分跳掉即可，用vscode等IDE就行。至于vscode怎么配置C语言开发环境，网上自行搜索即可，教程挺多的。（当然，这个教材对IDE不是很认可。从 只学C语言的角度， 可以姑且忽略这个反对的声音，23333） 想多练手的话，力扣（LeetCode） 和洛谷可以考虑做一下。 个人感受 这门课的作业，和每周上完课后的上机小测和考试都是在课程组的AC编程平台（https://accoding.buaa.edu.cn/） 上进行的。形式效仿的是IOI赛制。 一次典型的练习或上机会有 A-J 10个题。尽力而为就好，千万不要苛求做全，之前没接触过编程的同学很难做到。 作为参考，本人一般能做A-G题，有时可以接触到H、I题。 平台上出的题目多为前几届的优秀前辈编写。可以把这个当成题目难度离谱的原因，但也正因此，这门课程给的题目玩的梗奇多！ 相信在看到自己熟悉的梗的时候，你也会会心一笑！ 对于第一次接触编程的同学，对这门课程感到压力是再正常不过的事。 放平心态，不要放弃！ 部分题目的测试数据比较偏（但也确实应该在考虑范围内），经常会出现样例能过，但最后得到的测试结果是结果错误（WA）的情况。做题不要局限于样例数据，多想想题目给的数据范围，还有各种可能看似不可能的可能。 以我的接触，这门课的助教都还算友好。有关题目的问题交流一般都会耐心解答，但是助教也是各位前辈兼任的，耐心自然也有限，不建议一遇到问题就直接找助教，也不应该上来就找助教帮忙debug，而是自己多次尝试无解后再去求助。 视助教的友好程度，如果自己实在找不出问题，且不愿过度麻烦助教，可以向助教要题目的测试数据。但是这是万不得已的办法，不要轻易尝试，就算要到了也千万不要外传题目数据。对自己负责，同时也要对他人负责。更何况，有人可能要到数据就直接打表过关；打表这种做法对能力的锻炼一点好处都没有，后患无穷。要到数据，旨在用数据找到自己没考虑到的可能，然后在对自己的代码进行修改，而不是偷懒。 一些题目可能会涉及不少高阶算法。欢迎网上自行搜索，提高自己的知识水平 助教一般会在每次上机/练习/考试后在课程群里发题解，里面助教会分享不少能提高自己能力的知识，值得一看。 Github是个好地方，要学会在上面找参考代码（不限代码，其实什么都有）之类的资料。如果上不去的话，建议顺便学学怎么科学上网（特殊义）。 该课程只上8周，也就是说在期中那会这课就考完了。当时这节课是我们周四唯一要上的课，上完之后，下半学期的周四一节课都没有，那叫一个舒服啊😋相信各位也有机会享受这种福利（ 工科数学分析（一） 正文数分可谓大一除程序设计外的第二大难关。课程难度自然存在，但是还是能学好的。预习无非以下几个手段： 看课件。但是，课件有些部分还是写得过于简略，这里还是建议配合教材使用。北航版数分电子版教材，不妨在上面提到的三文鱼卷里的航类大一上资料库获取 看本校教材。这就不加赘述了。本校教材就是这张梗图里的教材，黄色封面。 看外校教材。个人感觉，北航自己编写的教材在部分内容上的讲解并不算细致，这时各位不妨参考以下外校的教材。上面提到的三文鱼卷的资料库里似乎也有，需要各位自己翻一翻。由于苯人在大一下才开始尝试这么办，这方面经验并不是很足；若要找推荐书目，建议在网上寻求建议，当然也可以拜托我询问一下其它梦拓 网课。B站大学，懂的都懂；由于我没试过，这方面的建议我也只能留个白（） 个人感受 要学好数分，除了做好习题真的别无他法。在各位完成作业的时候，千万不要因为写不完/一时想不出解法而直接抄答案，后患无穷！！！ 哪怕花的时间有点多，好好练是很关键的！ 此外，由于一节课要学的内容非常之多，建议各位课前先看书/课件预习（甚至直接自学完，课上顺便听听老师花了什么重点就行，我大一下就这么干的）。 以防出现上了就忘这种情况，建议各位上课稍微记记笔记，或者课下花一点点时间总结。此外，就我们这一届的经验而言，每周交作业的时候还会让你另外写一份学习心得。与其水过去，不妨就顺便在里面把自己本周学到的东西总结一下。 本人一室友就是这么做的，他最后数分成绩也还不错；反观我偷懒得多，最后成绩并不是很理想（ 在这门课上，各位会接触到一个叫智慧树的校外学习平台。在这个平台，除了提交每周作业外，你还需要在上面 “提高知识点的掌握度”，即做题目。我个人对这一平台并无好感（主要是事多和有些题目过于偏、难、怪，且上面的掌握度（须每个达到80%以上，做的时候错一个题基本就没戏）、测试成绩还要算进成绩里面），但是这个提高掌握度的事是必须在期末前做完的。 怎么解决它呢？一种办法是每次上完课就做一个知识点的习题。还有一种是完成每章的单元测试，满分后对应知识点的掌握度自动提升到80%以上，就不用每个知识点都做一遍题了。 但是！千万不要因为它烦人，就把它拖到期末来做。其恶心程度会让你本就难受的考期雪上加霜！！ 反正都得做，平常还得多练，干脆就把它当练习吧（笑） 平日的作业量有点小多，全用周末时间来写有点可惜。数分一周有两节（以我为例，我是周三、五上），不妨上了一节课就尽可能写现在能写的题目，避免出现题目想不出等问题。至于作业题目，开学课程群发的课程教学日历应该会全部列出来，不用等智慧树平台上出现了作业窗口再开始做。（当然，老师另有要求的话，以老师说的为准） 另有一个小事，就是当时我们的数分老师建议课后习题全做。 我认为这个对各位的要求太高了，各位在做完要求的作业的基础上量力而行即可，算是多练习的一个手段 如果感觉老师上课的节奏不适合自己，我建议全靠看ppt/看教材自学。这是很正常的情况，因为各位同学可能遇到老师在课上大费周章地讲书上写好的证明过程、解题方法讲的不细致等情况，此时自学效果反而会比听课好 工科高等代数正文这门课的难度其实不大，说实话没有什么预习的必要。 先上的是解析几何。这一部分主要就是空间解析几何的一些基本知识，不难。 上完之后，就进入到线性代数的部分了。这一部分学的主要是矩阵与行列式的知识，可能会稍微烧点脑筋。 教材用的是李红裔、赵迪的《空间解析几何简明教程》与李尚志的《线性代数》。当然也可以试着看其他教材作为参考，不过这方面小弟经验不多，就不多说了。 个人感受 如果要深入学习这门课程，强烈建议抛开课程自学。就以线性代数部分为例，在课上你只会学到矩阵是什么，有什么性质，却并不会教你学这个有什么用。甚至介绍性质的时候，有些老师也只会说这个性质”很好”，而不说”好”在哪里。如果你恰好对计算机图形学感兴趣的话，这门课更要学好，因为它是计算机图形学重要的数学基础之一。 有些老师上课进度有些拖沓。感受到这个问题的时候，请果断地选择看课件/教材自学。 其他必修课程这里就写得简略一些，也不会很全，感受居多。 习概：应该还是王海宇老师在教。至少就王海宇老师的课，这门课平日是打着习概名号的社会科学导论课。如果对人文社科感兴趣的话，可以听一听，甚至课下跟老师多多交流，王老师是真的和善！😋不感兴趣也没关系，直接水掉是可以的，只要该完成的课堂展示等作业完成了即可。临近期末的时候会按教材勾复习重点，课上可以不听（ 思修：假设是付丽莎（Lisa）老师上的话，那还是很推荐的！平日就是正常的思修课堂，但是Lisa老师平日会准备一些小惊喜（如期末的明信片等），人也很和善！临近期末也会划重点，课程组也有一个公众号一航思修，上面会发课程总结等等，值得一看。 体育课-足球课。北航的体育课是自己选的，我自己选了一个学年的足球课。原因无他，黄烨军老师和善不说，整个课上的氛围也很轻松活跃。也不知道黄老师是不是只上沙河的足球课，各位在学院路的话，可能就上不到了；如果在学院路也有的话，力荐！ （也不知道这个搬到学院路了还有没有）如果各位有入党的意愿的话，在大一上应该会进入学院的士信党建工作坊学习。这时各位应该会上高宁老师的《大国领袖》课程，强烈推荐各位上课认真听！！！ 高宁老师的思政课，各届同学公认精彩，上了都说好！！ 就算不打算入党，感兴趣的话也可以将高宁老师的《大国领袖》课当通识课来选，真的建议听一听！ 需要关注哪些信息渠道？微信公众号 北航士谔书院微信公众号。这个是士谔书院的官方公众号，上面一般会分享各类学院活动的预告、学习经验分享等消息， 包括后面的冯如杯竞赛（必选）的通知，大类分流各专业的宣讲（大一下）预告，也是在这里发布。 微言航语微信公众号。这上面主要分享的是生活指南还有各类校级文娱活动的预告。后者一定要试着参与一下，真的很丰富多彩！！ 例如：周末航影（免费在校看电影） 就是在这里发的预告；周末航影每周都会选取一部电影 （包好看，比如有一次放的是《爱乐之城》） 在学校的咏曼剧场放映，投票选电影和抽票的消息都是在这发的。还有厨艺课堂，教各位做甜点、咖啡、饺子等等的，有兴趣也可参与。有时还有剧团/乐团进校园等活动。而这些例子只是校级文娱活动的一小部分！ 智慧北航。在用统一认证账号登陆后才可使用，这个各位新同学弄好账号之后就能访问了，稍安毋躁。一个集成服务平台，查成绩等很方便。 航财通微信公众号。不关注不行啊，你充饭卡就在这充！ 北航后勤服务中心微信公众号。主要是停电、停水等通知。 北航教务处微信公众号。主要是教务有关的通知，比如四六级有关事项，选课通知，考试通知等。 北航总务公众号。类似于北航后勤中心，但是这里有交电费的入口，比较方便。 全球北航公众号。各类留学、交换计划都会在上面宣传，有需求的同学可以看看 各类社团的公众号。这个要看对哪个社团感兴趣。到时候各学生社团会进行宣传（“百团大战”），到时候现场扫码加就可以了。 北航社团中心。主要是社团（如：“百团大战”日期）相关事宜。 北京航空航天大学学生会。各大校内活动在上面都有通知，对学生会工作感兴趣的也可以加。 北航学生艺术团。艺术演出的活动公告一般都是在这里发布的，抢票信息也是！ 北京航空航天大学校医院。在校医院看病的时候可能用得上。 北航图书馆。可以操作续借等图书馆有关事务。当然在i北航 App/北航小程序上也可以做。 北京航空航天大学公众号。这里主要是对外宣传为主，如果对校级大新闻感兴趣可以关注一下。往常开学期间也会发机场/火车站到北航的路径，摆渡车时刻等交通信息，可以留意一下。 （谨慎选择）（非官方）“北航微生活”微信公众号。这是别人写的推荐之一，算是一个非官方的表白墙。本人没加过，不喜欢表白墙这类形式的我也不建议加。 两个神奇的非官方论坛伴航：https://banhang.lyhtool.com:8001 ，据观察里面有不少6系同学 航鸟小窝：https://buaa.live/bbs/ ，不过这个才建好不久，人气较上面那个冷清不少 教务处官网首页上面会公示转专业的相关事宜（如果有这个打算的话）（注，这个需要有统一身份认证账号后才能查，各位新同学弄好账号之后就能查了，稍安毋躁），也可以查询各个专业的培养方案（对后面专业分流有用）。后续的选课等，也是要在教务系统里操作的。 各专业的培养方案，可以在主页的“培养指南”栏目中查询，会对后面的专业选择有所帮助。 至于大类的培养方案？这个小弟似乎没有查到过，十分抱歉（ 教务系统（再次，注，这个需要有统一身份认证账号后才能访问，各位新同学弄好账号之后就能访问了，稍安毋躁） 访问在校内的话，是可以在教务处首页点”本研教育管理系统“直接进去的。但在校外不行，需要多一个步骤——由北航VPN访问。 首先要进入北航官网（www.buaa.edu.cn），在导航栏点”常用链接“，再点”VPN系统“。 进入界面以后，随便选一个即可。此处以VPN4为例。 随后需要用统一身份认证账号登陆。 登陆后，在资源列表里找到”教务处官网“，或在搜索框直接搜”教务“。 随后就进入了教务处的官网，点击本研教务管理系统，就可以正常用账号登入教务系统了。如果遇到这个界面，选新版系统入口就好了。 正文 相信在日后，辅导员等会给出教务系统如何使用的更详细指南。本文主要是教各位怎么用教务系统查开课方案，课程等信息。 信息的获取主要在”查询“一栏。 查询各专业和学院的开课计划这些，主要在”执行教学计划查询“里看。对于大类，院系选择“[70]北航学院”，其它专业的则根据不同专业对应的学院来选择就可以了。这个主要是后面选专业的时候，可以看看要上的课自己满不满意（笑） 有关四、六级在大一的时候，我推荐各位就把四六级解决了——大一上干四级，大一下干六级。 说实话，除了听力，四六级真不难。阅读题等等，在我感觉看来，就跟高考英语是一个水平。除了题型有所变化以外，难度跟高考英语其实是很相近的，大家不要对四六级太害怕，干就完事了！ 为什么要强调“除了听力”？因为听力可以算是整套题最难的了：高考题是把问题印上卷子的，而四六级的听力要你先听完全文，再听问题，然后作答。更难的是，文章/语段大部分只读一遍！ 这部分的解法，有两个。一个适用于记性好的同学，就是先专心听完全文，期间不要看选项分神，再听问题，按印象作答——有一点挑战性。还有一种就是边听边看选项，听的时候发现关键字，就在对应选项旁边标记一下（手速快还可以多写点提示词）；最后听选项的时候，在标记了的选项里面选就好。由于我一般用第一个办法，其他办法我并不是很了解；更好的办法，可能就要另请高明了 因此，我的四六级备考建议是：真题看看熟悉题型就行，重点练听力。 有关体育锻炼 北航有个叫TD线的特色项目，此外还要求各位进行体育活动的阳光打卡。TD一天可打3次，阳光打卡一周只能打4次，具体要求在打卡页面就能看到。一个学期的要求据说是TD+阳光打卡共48次，其中必有32次TD+16次阳光打卡。但是为保安全，我建议TD也刷到48次。 TD线通法可视个人喜好而言。想有一定锻炼量可以老实过各项项目；只为了刷完也可以摸鱼一路走过去。这两个算是正当的方法，不正当的方法就不说了，好孩子不要学（ 而且，在各位军训完之后，我建议休整好就尽快弄完，以防期末忙的时候忘记，导致体育课白扣10分！ 此外，有不少体育活动可以加TD次数。比如我们这一届在大一上的运动会时，有一个太极扇的表演项目；报名参加的同学，最后都喜提了48次TD次数。 有关沙河美食各位还是要在沙河待个两个星期的。是时候分享一点自己有限的美食储备了： 注意，这里主要是中晚餐。北航食堂在早餐卖的基本都是包子等面食，仅有少数窗口卖面、馄饨之类（如西区1f的一个窗口），可能需要各位适应一下。 西区：只推荐-1f的清真食堂与1f的食堂。 清真食堂可吃刀削面（现做），盖饭，炒饭，炒菜。刀削面8元一位，好吃但分量较少；盖饭本人推荐黄焖牛肉（17.8一份）和普通的牛肉盖饭（可自选搭配蔬菜，15一份）；炒饭和刀削面在一个窗口，各个口味都不错，10块一位；炒菜本人力推小炒羊肉和金蛊牛肉（如果还有的话） 1f我主要是吃早餐：推荐叉烧包，白菜肉包子，燕麦包。早餐我一般是两个包子+一碗豆浆。 东区：仅推荐3f的鼓瑟轩。如果各位军训的时候只能在东区解决饮食的话，那就将就吃1f/3f的菜吧，没办法了（ 至于学院路的？孩子才搬过来，还不知道有啥好吃的，再探完了再报😋 信类只有计算机一个”好“选择？答案很简明：不是，而且现在选计算机也不见得是好选择。 此处且借梦拓培训时，上一届学长的分享内容一用（注：国奖 = 国家奖学金）；里面的一些错误观点也可供各位参考：计算机人才过饱和，这已经是不争的事实了；上一个出现这种情况的叫土木工程。 【[打灰爱音/填词] 搅拌机下——“不提桶跑路已是我最后仅存的善良”】 https://www.bilibili.com/video/BV1eM4m1m74i 不妨把这首二创歌曲的对应部分改成计算机对应的内容，说不定你能发现周围人吹嘘计算机和曾经吹嘘土木的一些相似之处？（笑） 薪资呢？如果你觉得干开发就能赚大钱的话，不妨打开一个叫Boss直聘的软件，搜一下热门的前/后端开发的普遍薪资是多少。总之是不存在”一毕业就有40w薪资“这种事情的。 也许各位的确是奔着6系（计算机）来到北航的。但是，希望在大一这一年里，你能找到自己真正喜欢的专业方向，在大一下专业分流的时候，找到真正适合自己，且自己真心喜欢的选择。 千万不要按着分数选专业。 就像上文截图，这种想法反而是分数禁锢了自己。选自己真心喜欢的才重要。更何况，北航这几年的大类招生已经相对理性了许多：这一次的大类分流，6系甚至招到了全年级700名（23级大类内共有1000余人），应该不会再出现往年300名都挤不进6系的”盛况“了。 更何况，信类的优势专业也不止计算机一个。 电子信息工程学院（2系）和自动化科学与电气工程学院（3系，但是注意”电气工程“只有空壳，千万别选）也是本校的强项，在师资、设备、资源等方面都不比计算机学院差。如果你再留心看看北航被评上院士的各位教授的院系，更会发现，院士全在计算机外的其他院系，2系和3系（e.g. 23年刚评上的郭雷院士、焦宗夏院士）就有。 此外，如果你成绩亮眼的话，进2/3系福利也有不少：例如2系可以进北斗实验班（约等于院士班？），3系对大类前200名分进的同学有保研上的优惠，更能提早选科研导师，在大二就能接触科研项目，岂不美哉？ 其它的系呢？也有强的啊！仪器光电与科学学院（17系）实力也十分不错，在这方面北航可谓在全国占有绝对优势，不要因为报考的同学普遍成绩较差就不选它；还有一个集成电路学院（41系），师资也不错，在学院路的一号楼地下修了一个智能微纳中心，设备之齐全令人发指，保研也很方便。（常见问题：2/41二者差别？这个建议以大一下的专业宣讲为主进行参考，这里我就不多嘴了。） 总之，希望各位在大一下的时候能多参与一下各学院的专业宣讲，对大类里各个专业都有了明确的认识之后，再做选择。 除此之外，各位在开学的时候会被要求选一个学业导师。这个制度有一个好，就是可以通过导师举办的导学活动认识各个学院。我当时就是报了41系的郑翔宇老师，得以参观41系的微纳中心。如果你现在对某个学院感兴趣，不妨到时候选一个来自该学院的老师。 此外，选好导师可能会有你意想不到的福利！我有一位同学，当时选了3系的yjs老师；然后一次导学活动，他们导学小组竟然能有体验747-400型客机全动模拟驾驶舱的机会，这个机会加钱都不一定能有！！！当时的我，看到的时候眼都馋哭了😭 顺带一提，上文截图的”21系“是软件学院。某种意义上，6/21二者差不多。硬要比就是毕业得的学位，师资这方面的差别。 这一部分，我想借用一位我很尊崇的长者的话作结：“一个人的命运啊，当然要靠自我奋斗，但是也要考虑到历史的进程。” 北京”航空航天“大学？进入北航信类的你，肯定时常会想：”航空航天“跟我信类学生有啥关系？宣传这个有什么用？ 是有的。 上一栏提到的2系、3系干的活很多都跟航空航天有关。就以3系为例，无人机系统、飞行控制就是3系的主要业务范围。航空机载设备跟17系关系很密；雷达等电子设备，战机隐身和反隐身是2系的业务范围，等等…就连规模相对较小的41系，在研究的MRAM的主要用途也是抗辐射的航空航天机载设备。 我想报6系，那又有啥关系呢？ 航电设备难道不用写程序？（笑）。而且飞机设计这些是需要电脑跑流体仿真的，这个又能牵扯到计科的高性能计算（HPC）领域，又怎么能说无关呢？ 也许你对”航空航天“四字无感，或对信类有关航空航天的宣传感到不解。我能理解这种感受，这是非常正常的，特别是被6系的金子招牌吸引而进入北航的各位同学。 但是，身为一名航空爱好者（兼半个伪航天迷？航天我了解真不多，2333），我希望各位还是能给”航空航天“四字一点尊重，更需要尊重那些愿意在沙河待上4年、7年乃至更久的航类同学；因为他们确实是抱着对航空航天事业的热爱而选择的航类，并为这份伟大的事业做出了不少的牺牲。 哪怕各位可能会觉得自己读的应该叫“知春路计算机应用学院”，但别忘了国内最权威的航空学术期刊《航空学报》是哪个单位主办的。 这部分就写到这吧。可能各位对上述观点不大认同，那也没关系，就当是我对校内一些不良风气发的牢骚即可；但，如果各位认同小弟上述愚见的话，小弟自是非常感激。 跋这篇私货就写到这吧。如果日后有想到什么，再写点东西发给各位看官（ 本来是想再写写自我介绍的，但是时间实在紧迫……先这样吧，过几天我再写一个有关我自己的碎碎念。","link":"/2024/08/04/BUAA-freshman-FAQ/"},{"title":"OO_U2 - 电梯","text":"这是一篇导航帖。 本单元任务较忙，故我没有时间整合出一篇概括所有内容的文章。 博客周作业做了一些概括，但是我觉得里面我自己省掉了不小好玩的细节。 以下文章均与本单元有关，欢迎各位按需查阅： CSDN上的博客周作业 HW5，6总结 HW7总结 ReentrantLock使用 利用IDEA查死锁 杂记单元前序知识：Java多线程synchronized关键词有三种可能的修饰对象： 实例方法：public synchronized void method() {}；锁实例（this）的锁，或者说，对象锁。其他线程在该锁释放前，无法访问该实例的synchronized方法（言下之意，非synchronized可以访问） 静态方法：public static synchronized void method(){}锁定类，锁定后，其他线程无法访问该类的sync方法 代码块：锁对象锁，和第一个一致。12345public void method() { synchronized (Object) { }} 对象锁的行为经过实验，发现： 在对象锁被一个进程占用时，其他线程无法访问该对象的synchronized方法，但可以访问没加sync的方法，甚至由此对对象的属性进行更改 在Obj的对象锁被一个进程占用时，其他线程在执行到synchronized (Obj) {}代码块处会被阻塞。 对象锁针对的是对象，而不是方法；因此，调用一个sync方法method1()，method1()又调用另一sync方法method2()，是不会被阻塞的，因为当前线程一直拿着对象的锁。可能会带来预期外的不阻塞 wait()，notifyAll()Obj.wait()会暂停线程A（A此时拥有Obj的锁）的执行，直到另一线程B使用Obj.notifyAll()将其唤醒。 同时，Obj.wait()会释放线程A拥有的Obj锁。 notify()会随机唤醒等待池中的一个程序，而notifyAll()是全部唤醒。 Thread类涉及Runnable的太复杂，我们选择直接extends Thread，随后重写run()实现启动线程。 只有start()会创建新线程，run()只会顺序执行代码块。 确定要保护的方法在一个对象里，如果出现了要多线程共享的属性，那引用该属性的方法全部都要保护。","link":"/2025/04/17/OO_U2%20-%20%E7%94%B5%E6%A2%AF/"},{"title":"OO_U4 - UML","text":"本文使用Python搭建评测机。使用其他语言，在具体实现上可能存在差异，本文只是提供了一个思路。 前言众所周知，本次作业采用了“交互式评测”，会根据同学们的程序输出，来动态生成新的指令。这对本地复现作业评测方式，构建自动化测试带来了一些挑战。 本人在一番折腾，并在各路大模型的协助后，成功在本地初步完成了交互式评测的搭建。本文将对我折腾的经验，进行一些简要的分享。 数据生成正如评测说明，对于每一次评测，我们都有一套“基础输入”，取书/还书请求根据程序运行结果动态生成。 因此，我们采取如下的思路： 数据生成器负责生成“基础输入” 取书/还书请求由Checker根据程序运行结果，在基础输入中选取合适位置插入 Checker此时相当于承担了一部分数据生成的工作。 当然，为了方便复现测试结果，建议Checker输出一份stdin_actual，记录下插入了还书/取书请求的实际输入。 评测框架的修改在前几单元中，我的评测机模式是这样，相信大家在这部分大同小异： 评测机框架+数据生成器+Checker； 数据生成器一次生成所有测试输入 Checker在待测程序完全运行后启动；通过比较待测程序完全运行后的结果，与Checker预期结果，得出待测程序是否正确的判断 在本单元的交互式评测模式下，类似第二单元中，使用数据投喂器的思路，我们： 将Checker与待测程序同时运行 用管道将二者的输入、输出连接起来 待测程序的输入由Checker进行投放：12345678910111213141516171819java_process = subprocess.Popen( ['java', '-jar', os.path.join(target_dir, jar_file), f&quot;-Xmx{memLimit}&quot;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=fileerr,)check_process = subprocess.Popen( [&quot;python3&quot;, checker_path, out_file], # 注意参数out_file cwd=case_dir, stdin=java_process.stdout, stdout=java_process.stdin, stderr=logfile,)# 在完成数据投递/正确检查后，必须显式关闭java_process的stdin# 否则待测程序会认为仍有输入待读，一直等待，无法结束check_process.wait()java_process.stdin.close() 在上面的代码示例中，我的Checker通过读取工作目录下的stdin.txt，获取基础输入。因此，check_process中通过cwd指定了Checker的工作目录，以便进行多样例的并发评测。 进行自动化测试时，我们当然想要知道程序的输出；由于待测程序的输出管道接到了Checker的输入管道上，我们能想到的最美观办法，自然是由Checker记录待测程序的实际输出。 Checker的修改上面我们已经提到了这几个额外需求： 动态生成return/pick指令,并插入到基础输入的特定位置 记录实际输入 记录程序输出 还有Checker本身要做的： 交互式评测：向程序输入指令，同时动态获取一行或多行输出 正确性检查 动态获取输出这是Checker这几点中最麻烦的部分，主要在于多行输出的处理。 上面我们已经将Checker与待测程序的输入、输出管道连接在了一起。在Checker处，获取一行待测程序的输出，只需要sys.stdin.readline()即可。 那么，对于查询轨迹这种有多行输出的情况，是不是sys.stdin.readlines()就可以了呢？ 很遗憾，是不行的。 因为readlines()是以EOF判断读取的结尾的，而EOF一般情况只在管道关闭时才能发送。那怎么办呢？ 观察输出格式，不难发现，对于多行输出的情况，输出的第一行包含了我们接下来输出的行数。 12345678910query:[2025-01-07] B-0000-01 moving trace: **3** 1 [2025-01-06] from bs to ao 2 [2025-01-06] from ao to user 3 [2025-01-07] from user to broopen:**2** [2025-01-06] move B-0000-01 from bro to bs [2025-01-06] move C-0000-01 from bro to bs 因此，我们只需要想办法提取出接下来的行数”n”，随后n次readline() 即可。相信这也是课程组官方的交互式评测机处理多行输出的方法。 插入还/取书指令上面提到，我们的OPEN/CLOSE等基础指令，是由数据生成器生成的。为了简化问题，我们规定，插入的还/取书操作，都在已有的OPEN/CLOSE间插入，不新开OPEN/CLOSE对。 在这个规定下，我们需要做这几件事情： 读取生成的stdin.txt，得知所有OPEN/CLOSE对的时间 写一个函数，对于一个成功的预约/借阅请求，取一个预约/借阅日之后的开馆日，作为插入还/取书指令的时间 插入请求 对于如何插入请求，我的做法是这样 感谢D指导提供思路 ： 两个队列，队列A记录stdin.txt中的初始指令，队列B记录要插入的指令 队列中元素是一个三元组： (date,priority,line)，其中，OPEN、其他指令、CLOSE的优先级分别为0、1、2 每次要插入指令时，把要插入的指令存在队列B中；随后，将两个队列合并，并依次按照日期、优先级的顺序重新排序 Checker从合并好的队列中，取一条指令，作为发送给待测程序的输入 如此我们就完成了指令的插入，剩下的事情就很简单了。 记录程序输出/实际输入记录实际输入，只需要在向待测程序发送输入时，在stdin_actual里记下来即可。 同理，对于实际输出，读出一行，向out.txt里写一行就是。 下面仅作示意。 1234567891011with open(&quot;./stdin_actual.txt&quot;, 'w') as actualStdin, \\open(stdin_file_path, 'r') as filein, \\open(out_path, 'w') as fileout: for line in actual_lines: actualStdin.write(line) sys.stdout.write(line) sys.stdout.flush() # flush()保证输入被立刻发送 ...... # 下面仅作示意，多行输出的问题此处略去 line_out = sys.stdin.readline() fileout.write(line_out + &quot;\\n&quot;) 正确性检查这一部分，就可以像前几个单元一样，交给AI代劳了。 本人对Deepseek-R1，Gemini-2.5 Pro在内的多个模型进行测试，发现其均无法一下生成可用的交互式Checker（比如说，上面readlines()的问题，我没有特殊提示，AI很难一下处理好）。 这里建议，按照上面的步骤完成了输入/输出的处理后，再交给AI完成正确性检查的部分。 本次指导书的正确性约束较为分散，建议在给模型输入指导书时，在提示词里明确给出正确性约束条件，比如： 借书/预约/取书成功的条件 每次操作，书的运动轨迹：如借书时，从书架到用户 下面给出一个我用的prompt，供各位参考。需要注意，这个prompt我没有显式给出正确性约束条件，我得到的生成效果因此不大理想： 123456789请按照content.json中的指导书，帮我修改本次作业的正确性检查器（checker.py）。其中，你可能需要注意：- 如我上传的checker.py所示，checker.py是一个交互式评测器；他将读取stdin.txt，并对输入对应的输出进行响应；我已经完成了输入与输出的交互读取，你需要编写对读出的输出，按指导书规定进行正确性检查的部分；- 交互式评测会按照程序输出，生成对应的还书请求与取书请求；checker.py来完成这一部分工作。具体而言，当输出出现预约/借某本书成功后，checker.py将在预约/借书指令后的某一对OPEN/CLOSE指令之间，生成还书请求/取书请求。这样一来，生成的新请求，与stdin.txt中已有的请求是交错的。此外，你需要将包括了生成的还书请求/取书请求的实际输入，输出到checker.py留好的stdin_actual.txt中。-checker.py的接口也应如示例中保留；我的checker.py已经完成了输入与输出的处理，你不需要对这部分进行修改；最后请输出一个完整的checker.py","link":"/2025/06/10/OO_U4%20-%20Checker/"},{"title":"OO_U4 - UML","text":"直接就是博客作业。文末的课程收获是真情实感。 漫长的OO历程，终于到此结束了。 本篇文章将简要介绍本人在本单元中，利用UML进行正向建模的经历，并对一学期以来的课程经历做一个简要回顾。 整体架构 Main类负责处理输入 Library负责“分发指令”给各个下属类，同时起到“中转数据”的作用 Bookshelf等为Library的下属，负责完成具体指令 User、Book分别为读者、书本的状态信息，对应实现了一些查询/状态转移方法 对于预约，我设计了一AppointmentInfo类，用于记录预约请求的有关信息 正向建模事实上，我的正向建模过程并没有使用StarUML这款可视化建模工具，而是在草稿纸上，仿照UML的基本格式“打草稿”： 对于架构设计： 根据问题，抽象出需要的类 根据每个类所需要实现的功能，规定好必须实现的属性和方法 根据属性、方法与类之间的交互逻辑，确定类之间的聚合/继承等关系 在更新架构设计时： 确定是否加类 是否有属性/方法的更改 是否有类之间关系的更改 架构的设计与迭代流程大概是这样。 至于状态与流程图，打草稿结果与UML画出来的结果近乎一致，在这里也就不再展开了，只需注意转移规则与方法关联的问题。 与最终设计的追踪关系 类图：正如上文所言，本人采取的建模方式是先建模出必要的架构，再在其基础上进行具体实现。因此，初始的UML设计，与最终实现还是有细微差别。也就是说，我的开发过程中，有具体设计反过来添加UML中属性/方法的状况。好处是，这有利于加快开发效率，避免过度拘泥；坏处是，UML按理不该修改，但我们事实上改了。 状态/流程图：我的状态/流程转移，都是基于初始设计中的必要方法的；因此，最终实现是与初始设计一致的。 大模型辅助正向建模就我个人体验而言，我认为直接让大模型进行正向建模的效果差强人意。具体表现为，大模型会因幻觉，出现脱离于当前问题上下文的设计：如类与继承关系。 出于这一原因，本人的正向建模大部分由我本人完成。至于大模型的作用，我仅是让大模型生成了初步的正向建模模型。 大模型辅助建模，我主要是在实验课上实践。总结实验课上的经验，我的经验如下： 与实验指导书相反，我选择尽可能减少Prompt的规模。实践证明，当前主流大模型已足够在简明的Prompt下，生成令人满意的答案。 我只向大模型传入了当次任务的指导书，以及一个简明的Prompt. 这个Prompt内，主要是对指导书内一些没有显式声明的限制条件进行补充；以本单元为例，图书馆开馆时间不一定连续就是一个隐形条件。 在指导书足够清晰明了，介绍了所有要求与限制的情况下，我的Prompt甚至简单到只有三个字：“帮我做”。 更具体而言，要让大模型做架构设计，总体分三步： 设计总体架构：开什么类，类之间怎么交互 细化类：需要什么属性和方法 具体实现：开始编写方法内逻辑即可。 设计思维的演进在OOPre反复重构的心理阴影下，我在本学期OO正课开始，就对正向建模的过程较为重视。当然，四个单元下来，设计思路还是有长进的。 U1：初级阶段；对当前问题进行正向建模，不充分考虑未来可能的扩展方向；这导致我在Hw2时出现了一次代价较高的重构。 U2：吸收上一单元教训，在Hw5时前半周投入大量时间，用于设计后续作业通用的架构，以及电梯调度/运行策略；这一决定确有收获，后续迭代相对轻松；但全过程并未对进程间交互流程进行正向建模，导致Hw5多处出现死锁，强测失利… U3：按照规格按部就班；这应该是正向建模完成后的正常开发流程，我在此体会到了何为“规格与实现分离”。正向建模实质上就是设计规格，反过来改正向建模架构，严谨而言是不应发生的。 U4：正式进行正向建模。发现自己正向建模的思维仍然不够严谨，出现了反向改正向建模架构这种事情。这其实也反映了我的正向建模仍然不够抽象，这可能是我日后需要锻炼的地方。 测试思维四个单元下来，我的测试思维基本稳定；但在U3时，我的单元测试思维得到了强化。 具体而言，我当前的测试思维是： 回归测试：当前修改，不应影响原有功能的正确性； 针对边界条件测试：明确开发过程中遇到的边界条件，在实现一个功能后，即对其进行边界条件测试； 随机测试：随机生成数据，评测机灌水式测试；虽然简单暴力，但从扩大测试范围的角度确实有用； 压力测试：主要针对U2；评测机多进程并发评测，测试设计是否合理。 单元测试：更细颗粒度，针对某个方法进行测试。 课程收获从U1刚开始的高度紧张、焦虑，到U2中期后的逐步驾轻就熟，我认为本学期OO课程为我带来的最大收获，是面对困难任务时心态的转变。 自大学入学以来，我面对困难任务，要么是想捷径，要么是找合理的办法规避。要自己动手解决时，我往往对着问题焦虑地发愣：因无法完成任务而焦虑，因焦虑而无从下手。本学期的OO课程帮我打破了这一恶性思维闭环，鼓励我先放手大胆尝试，再考虑能不能做成。 这一思维模式的转变确实为我带来了好处。在第二单元中，我尝试了使用oolens未介绍的ReentrantLock，并从头完全设计了一套自己的电梯运行/调度策略。电梯单元任务的确艰巨，但在那一单元我大胆尝试，受益匪浅。可以说是万事开头难吧，但最重要的始终是试着迈出第一步，然后坚定的走下去。 另一收获是构建属于自己的评测机的经验，这也可以算是敢于尝试的一大成果吧。我构建评测机也是始于第二单元。随后，我逐步探索出了多进程并发评测，以及AI构建数据生成器/Checker的整个工作流程。收获还是颇为显著的，在构建好评测机后，除了Hw5评测机构建完成时间太晚、Hw9心浮气躁不用评测机翻车以外，其他次作业都没在强测里出问题。 由此，我也感受到了充分测试，对于程序开发的重要意义所在。在开发完一个功能后，第一假设应是“这个程序有bug”，而不是写完后就骄傲自满，完全不做测试，或是简单的“目视法”找bug。测试思维，也算是OO课程给我的一点收获吧。 我的抽象思维与建模能力也得到了提升。 U1、U2每次作业的正向建模，以及对后续迭代需求的简单预测，为我减少迭代开发量做出了重大贡献。U4时，我针对问题的建模能力也较前两个单元成熟了许多，在正向建模上花费的时间比之前少了不少。 在此，我由衷感谢OO课程组的各位老师与助教，本学期以来的陪伴与支持。没有你们的无私奉献，相信我是不会获得上文这么多收获的。再次，Большое спасибо!","link":"/2025/06/10/OO_U4%20-%20UML/"},{"title":"OS - LA32R移植报告","text":"这一部分由我与另一位同学共同完成。我主要完成的是SD卡部分的工作。仅此向Lab4就已探索出前三个Lab移植的他表示敬意… 指令集适配这一部分只介绍较为关键的改动。有关Makefile中编译选项的修改，指令名称、格式变动引起的修改，在此不多加赘述。 例外有关LA32R需要在状态控制寄存器（CSR）中，配置EENTRY和TLBRENTRY两项，分别对应普通例外的入口地址，以及TLB重填例外的入口地址。不难注意到，LA32R的TLB重填例外，是与其他例外分开处理的。 此外，由于触发 TLB 重填例外之后，处理器核将进入直接地址翻译模式，TLBRENTRY处所填入口地址应当是物理地址。EENTRY不受影F响。 配置两个入口的工作，也在start.S中进行： 123456789 la a0, exc_gen_entry csrwr a0, csr_eentry la a1, tlb_miss_entry // 转换为物理地址 li.w a0, 0x1fffffff and a1, a1, a0 csrwr a1, csr_tlbrentry 随后，是异常处理程序入口的获取。 这需要修改kern/entry.S： 在出现TLB有关异常时，LA32R核会直接由先前已经规定的TLB例外入口，进入对应的处理程序，我们在这里只需要关心其他例外的处理程序入口； 与先前由CP0.CAUSE获取例外编号类似，我们由CSR.ESTAT获取例外编号，进入对应的处理程序。 虚拟地址翻译LA32R引入了 “直接地址翻译模式”与“映射地址翻译模式”。在我们的实验中，我们的虚拟地址与物理地址位数相同，前者的虚拟地址直接就是物理地址，后者的虚拟地址则是由MMU进行管理，与常见实现类似。 LA32R还提供了“直接映射地址翻译模式”，允许在映射地址翻译模式下，按照CSR.DMW0/1中配置好的地址翻译窗口，将某个虚拟地址不通过页表，直接翻译为某个物理地址。 对于某些地址，我们希望其不通过Cache，直接访问内存（如MMIO有关）。LA32R提供了一致可缓存、强序非缓存两种模式，粗浅理解就是可否通过缓存访问。 LA32R并没有体系结构约定的虚拟地址空间。我们决定沿用原有的地址空间设计。因此，我们需要借助直接映射地址翻译，进行原设计中kseg0、kseg1的配置，是否可缓存的规则也与先前设计一致。 这一部分的配置工作在start.S中，于跳转到la32r_init()前进行： 12345678 // Configure KSEG0/1 li.w a0, 0x8000000a csrwr a0, csr_dmw0 li.w a0, 0xa0000011 csrwr a0, csr_dmw1 /* jump to la32r_init */ b la32r_init 此外，在start.S中，除了原有的禁用中断外，我们还需启用映射地址翻译模式： 12 li.w a0, 0xb0 // PLV = 0, ID = 0, DA = 0, PG = 1, DATF = DATM = 01 csrwr a0, csr_crmd LA32R亦对TLB/页表的表项结构产生了影响，大致可以归纳为以下两点： 引入PLV位，对访问权限进行控制；这需要在涉及页表操作时，对应设置权限位（pmap.c与env.c中涉及更改居多。大部分为PLV3，即用户态） 表项属性位置的变化。 TLB异常有关正如前文所言，TLB重填的处理入口，在LA32R中是与普通异常独立的，这为我们的实现带来了便利。 tlb_out被弃用，tlb_invalidate()使用invtlb指令即可实现 原有设计，是去除指定asid与va的TLB项目 内存共享问题此处已被考虑，就是要去除这一被共享的TLB项 查询LA32R手册，得知其对应模式标志为0x6 invtlb 0x6, a0, a1即可，$a0/1对应先前tlb_out参数中的asid/va。 tlb_asm.S内直接实现tlb_miss_entry中的重填逻辑。整体流程： 将处理过程中，要用到的寄存器原始内容保存进CSR 读取CSR中，一级页表地址 按照BADV，算出页目录索引 按页表索引，得出页目录项；检查之是否合法 合法，继续读取页表，将页表项存入TLB 不合法，则缺页，写两个空项进入TLB 处理完后，恢复寄存器 原有的TLB项对应页无效逻辑变化不大，此处不加赘述。 对应，kern/tlbex.c受到影响。 计时器首先，要配置计时器的中断使能，需要配置CSR.ECFG。这在进程创建时(env.c)进行；在进程切换，根据Trapframe恢复现场时，时钟中断对应就会启用。 1e-&gt;env_tf.csr_ecfg = ECFG_TIE; 其次，是计时器的控制，需要配置CSR.TCFG。实现在include/kclock.h中： 1234.macro RESET_KCLOCKli.w t0, 0xfffd // Enable = 1, Periodic = 0, Else as the init value of clockcsrwr t0, csr_tcfg.endm LA32R提供了Periodic的计时器复位方法：在时钟中断发生后，计时器自动复位成CSR.TVAL中预设值。为了简化设计，我们选择MIPS中原有的计时器复位思路，即时钟中断发生后，由软件手动配置计时器。 最后，则是时钟中断的处理。在LA32R中，我们需要手动写CSR.TICLR寄存器，进行时钟中断的清除。这部分逻辑在genex.S处实现： 12345678910111213handle_int: // 判断是否为时钟中断； // 与原有逻辑相似， // 但现在从CSR.ESTAT中获取异常信息 csrrd t0, csr_estat andi t1, t0, ESTAT_TI bne t1, zero, timer_irq timer_irq: li.w t0,1 csrwr t0, csr_ticlr li.w a0, 0 b schedule END(handle_int) 上下文保存首先，我们需要修改Trapframe结构体的定义，使得移植后，我们仍能得知异常处理所需要的CSR信息： PRMD：出错时的当前状态；这主要是为了进程的创建，使得进程退出后能够正常让系统回到内核态 BADV：出错的访存地址 ESTAT：例外状态，旨在得知发生了什么异常 ERA：异常处理后，返回的程序PC ECFG：旨在方便创建进程时，打开时钟中断 单独存储PRMD、BADV，而不是直接从CSR内读取，主要是为了处理异常的嵌套，单层异常的话，其实等价于此时CSR.PRMD与CSR.BADV中存储的值。 对应的，我们需要修改include/stackframe.h中的SAVE/RESTORE_ALL宏，更新指令为LA32R格式，并适应现在的Trapframe设计，使得上下文能够正常保存与恢复。 此外，在LA32R的寄存器定义下，发生了以下两个关键变动： $sp以及返回值寄存器的编号发生了变化； LA32R下，参数寄存器有5个，不再需要在栈帧中存放额外参数 这需要我们对设计这两个更改的地方进行修正。 SD卡驱动这部分的工作，大体可以分为SD卡的初始化，以及SD卡的读写两个部分。 自然，我们需要规定需要访问的SD Host Controller寄存器的地址；本实现选择跟串口地址的定义放在一起。 SD卡的初始化，本实现选择放在la32r_init()中。 SD卡的核心交互逻辑，存储在kern/sd.c中。 对应有include/sd.h，规定了ADMA2描述符结构体adma2_desc_entry，SD Host Controller寄存器的访问宏SDREG()，以及向SD卡发指令操作的函数定义。 为方便表述，下称Host Controller为控制器。 初始化这里主要分为三步： 配置控制器与SD卡的时钟； 配置控制器的一般/错误中断状态使能； 给SD卡发送指令，初始化SD卡。 配置时钟控制，通过配置控制器的Clock Control Register实现。 12345678void sd_clk_init() { SDREG(MEGASOC_SD_CCR) = ( 0x00 &lt;&lt; 8 | // 直接使用可用的基础频率 0x1 &lt;&lt; 0 // 启用控制器内部时钟 ); while (!(SDREG(MEGASOC_SD_CCR) &amp; 0x0002)) {} // 等待控制器内部时钟稳定 SDREG(MEGASOC_SD_CCR) |= 0x1 &lt;&lt; 2; // 启动SD卡的时钟} 在时钟配置完成后，我们才能对SD卡发送指令，进行初始化。 一般/错误中断状态使能，则是通过配置控制器的Normal/Error Interrupt Status Enable Register实现的。 12345678910111213void sd_intr_init() { SDREG(MEGASOC_SD_NISER) = ( 1 &lt;&lt; 0 | // CMD done 1 &lt;&lt; 1 | // Transfer done 1 &lt;&lt; 3 // DMA intr ); SDREG(MEGASOC_SD_EISER) = ( 1 &lt;&lt; 0 | 1 &lt;&lt; 1 | // CMD timeout/CRC 1 &lt;&lt; 4 | 1 &lt;&lt; 5 | // DAT timeout/CRC 1 &lt;&lt; 9 // ADMA err );} 对于NISER，我们只需要知道指令完成、数据发送完成（用于SD卡读写时）、DMA中断（DMA出错时有用）三个中断。而EISER，只需配置ADMA错误，控制器的CMD/DAT两条线的超时/CRC校验错误即可。 这两步完成后，即可按照手册中的初始化步骤，对SD卡自身进行初始化了。 我们使用ADMA2方法进行SD卡的读写。本实现在SD卡初始化时，就对SD卡的传输方式就进行配置。这通过配置Host Control 1 Register实现。 1SDREG_8(MEGASOC_SD_HC1R) = 0x2 &lt;&lt; 3; // Setup ADMA2 在进行SD卡的读写前，我们还需要让SD卡进入传输状态。 在上面的初始化过程中，我们通过CMD3的返回值，得知了当前已插入SD卡的相对地址RCA； 我们需要通过发送CMD7，以这一RCA为参数，使得被插入的卡被选中，进入传输状态 只有在传输状态下，SD卡才能接收并执行CMD18/25两个读写指令，进行正常读写。 同样，本实现在sd_init()中就发送CMD7，简化SD卡读写逻辑的编写 至此，整个SD卡的初始化流程就结束了。此后，我们即可调用SD卡的读写逻辑，对SD卡进行读写。 读写逻辑整个读写逻辑，我们打包在sys_read/write_block()系统调用中。文件服务在需要进行读写时，直接调用syscall_(read/write)_block(secno, (dst/src), nsecs)，即可对SD卡进行读写。增加系统调用的操作在此不加赘述。 具体的读写逻辑，在kern/syscall_all.c中定义。读、写过程十分相近，大体可以分为以下步骤： 配置ADMA2标志符表，并将标志符表的物理地址，写入控制器的ADMA System Address寄存器，告知控制器标志符表的地址 配置控制器的Transfer Mode寄存器，为读/写操作做准备 配置控制器的块大小、块计数寄存器； 发送多块读/写指令（CMD18/25） 此处以读操作的实现为例，进行具体分析。 描述符表项的结构体定义如下： 12345typedef struct { uint16_t attribute; uint16_t length; uint32_t paddr;} adma2_desc_entry; 123456789101112131415161718192021222324252627282930313233343536373839int sys_read_block(u_int secno, void *dst, u_int nsecs) { // 初始化描述符表；各描述符表项需连续分布在一段地址空间上 adma2_desc_entry adma2_dtable[512]; int i; for (i = 0; i &lt; nsecs; i++) { uint32_t vaddr = dst + (i * 512); uint32_t paddr = va2pa(curenv-&gt;env_pgdir, (u_long)vaddr); // 获取目标地址的物理地址；描述符表项的地址域，需要的是物理地址 adma2_dtable[i].paddr = ((uint32_t)(paddr)); adma2_dtable[i].length = 512; // 一块的大小 adma2_dtable[i].attribute = 1 &lt;&lt; 5 | // 配置表项为传输模式；此处涉及描述符表项的其他设计，此处略 1 &lt;&lt; 2 | // 出现错误时中断 1 &lt;&lt; 0; // 表示该表项合法 if (i == nsecs - 1) { adma2_dtable[i].attribute |= 1 &lt;&lt; 1; // 描述符表的最后一项，需要配置一个终止标记 } } SDREG(MEGASOC_SD_TM) = 1 &lt;&lt; 0 | // 启用DMA 1 &lt;&lt; 1 |// 启用块计数寄存器；配合CMD12使用 0x1 &lt;&lt; 2 | // 自动发送CMD12（停止传输）；这样，我们就只需在发送CMD18/25后，等待“传输完成”中断 1 &lt;&lt; 4 |// 数据方向为读 1 &lt;&lt; 5; // 多块数据操作 // 将描述符表的物理地址告知控制器 uint32_t dtable_paddr = PADDR(adma2_dtable); SDREG(MEGASOC_SD_ADMASAR_BASE) = ((uint16_t)(dtable_paddr &amp; 0xffff)); SDREG(MEGASOC_SD_ADMASAR_BASE + 0x2) = ((uint16_t)(dtable_paddr &gt;&gt; 16)); // 配置块大小和块数 SDREG(MEGASOC_SD_BLKSIZE) = 512; SDREG(MEGASOC_SD_BLKCNTR) = ((uint16_t) nsecs); // 发送读/写指令，等待其完成 sd_send_cmd18(secno * 512); // CMD18/25传入的SD卡数据地址参数，是字节编址的，因此需要对参数做如此变换 return 0;} 至此，我们就完成了一个基本的SD卡驱动。","link":"/2025/07/08/OS%20-%20LA32R%E7%A7%BB%E6%A4%8D%E6%8A%A5%E5%91%8A/"},{"title":"OS - Lab1实验报告","text":"归档于2025年7月8日。 思考题1.1先回答objdump的参数作用： -D：显示所有反汇编结果。 -S：在源码可以找到的情况下，将源码与反汇编结果一同输出： 我选择对mips-linux-gnu-gcc与gcc的结果进行比较。 直接看objdump的结果太费劲，我们用readelf观察编译结果的不同。最直观的结果，是头文件内容发生了变化： 使用readelf -S，观察地址，亦会发现不同： 1.2 解析结果如下： 阅读Makefile发现，我们的readelf编译时，是根据本机的运行环境进行编译的。 不难发现，此时我们的系统架构为x86/64，是64位系统，生成的readelf是64位程序；而我们的hello根据-m32编译选项，生成的是32位程序。 而我们编写的readelf是为了解析32位程序来写的，因此会出问题。 1.3我们在上电的时候，第一个启动的并非操作系统内核，而是bootloader。自然，我们的内核起始地址不会是上电初始化的地址。 再看为什么可以找到内核的地址。阅读指导书发现，在启动过程中，我们的内核入口一定是在kseg0的一个确定位置处；在这个约定下，我们在bootloader中自然也会按这一规定编写程序，在跳转到内核这一步时，直接跳转到约定的地址。 难点分析 如何调试printk()。其相关的所有指令均针对MIPS体系结构，直接在跳板机环境下无法运行，使用gdb远程调试的效率有时亦不大理想。 在本次实验中，我通过修改init.c，在其中测试printk()。在printk()内部，我也通过out()进行了传统的”printf()式调试。 printk()实现的正确性检验。我选择使用printf()，对二者解析相同格式的结果进行比较。 vim的高效使用。我编写readelf常常出现大小写按错的问题；没有自动补全很难办啊，目前这个问题也没有好的办法….还有查找定义与跳转，在每次进入子目录，检查子模块时，我们都要手动ctags，否则查不到定义；正在寻找更好的方法。 实验体会完成本次Lab时，我注意到，我使用vim进行开发的效率并不理想。是时候多研究一下里面的快捷键了… 原创说明本次实验报告为本人原创。","link":"/2025/07/08/OS%20-%20Lab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"title":"OS - Lab2实验报告","text":"归档于2025年7月8日。 杂记 我们需要回顾一下内存空间相关的知识。 kuseg：用户态空间，需要通过TLB和Cache kseg0：过Cache，不过TLB；MMU拉低最高位（-0x8000_0000）得物理地址 kseg1：Cache和TLB都不过；MMU拉低高三位得物理地址 kseg2：过TLB和Cache 还有，MIPS通过MMIO (Memory Mapped IO)进行外设访问。显然外设处在固定的物理地址上，我们肯定想到kseg1。 TLB需要软件初始化，故内核最开始自然放在不用TLB的kseg0上。kseg1暂时认为是访问IO设备专用。 思考题2.1指针变量存储的一般认为是虚拟地址。 在我们实现了地址翻译功能的硬件上，lw，sw访问的地址被视为虚拟内存；而像我们计组课设中直接访问内存的处理器核上，被视为物理地址。 2.2 C语言本身没有泛型语法，这样写可以做到创建一个泛型双向链表，提高可重用性。这同时也省掉了重复造轮子的烦恼，不是吗？（笑） 对于单项链表：插入只需更新两个next域（如insert_after，则是更新当前的，与待插入的两个节点），效率优于剩余二者（循环链表，双向链表还需维护prev）；但在删除时，单项列表需要遍历，效率较低； 对于循环列表：可以认为是双向链表的特殊情况；操作次数与双向列表近乎一致，不过由于需要特判头部节点，以及prev指针需要解引用来维护，效率可能较双向列表略有下降。 2.3 C。按照queue.h展开即可。 2.4 查询4Kc手册P41，我们可以得知ASID的定义： 类似于我们使用PID区分不同的进程，我们使用ASID进行不同进程/线程对应内存空间的标识。 不同的进程，其内存空间/上下文一般情况下不同，虚拟地址到物理地址的映射一般也会不同。这就需要ASID，指示TLB中的映射是否有效。 ASID有8位，对应即是2^8 = 256个不同的地址空间。 2.5 tlb_invalidate()调用tlb_out。 无效化ASID与虚拟地址va对应的页表项；若页表项不存在，则什么都不做。 123456789101112131415161718192021222324252627 3 LEAF(tlb_out) // LEAF函数，不调用任何其他子例程，不使用栈上的任何内存空间 4 .set noreorder // 指定下面程序不可交换执行顺序 5 mfc0 t0, CP0_ENTRYHI // 暂存当前的ENTRYHI 6 mtc0 a0, CP0_ENTRYHI // 将传入的参数（VPN,ASID）写入ENTRYHI 7 nop // 消除冲突 8 /* Step 1: Use 'tlbp' to probe TLB entry */ 9 /* Exercise 2.8: Your code here. (1/2) */10 tlbp // 从ENTRYHI指导的VPN和ASID，将TLB表项号读入INDEX11 nop12 /* Step 2: Fetch the probe result from CP0.Index */13 mfc0 t1, CP0_INDEX // 将INDEX内容提取出来14 .set reorder // 允许编译器调换执行顺序，因为下面程序对结果没影响15 bltz t1, NO_SUCH_ENTRY // 当INDEX最高位为1时，表项无效，比较时认为$t1 &lt; 016 .set noreorder // 不允许编译器调换执行顺序17 mtc0 zero, CP0_ENTRYHI // 准备清空内容18 mtc0 zero, CP0_ENTRYLO0 // 准备清空内容19 mtc0 zero, CP0_ENTRYLO1 // 准备清空内容；由于奇偶页设计，我们需要LO0,LO1都准备上20 nop21 /* Step 3: Use 'tlbwi' to write CP0.EntryHi/Lo into TLB at CP0.Index */22 /* Exercise 2.8: Your code here. (2/2) */23 tlbwi // 清空INDEX对应的TLB表项24 .set reorder2526 NO_SUCH_ENTRY: // 无论表项是否有效，下面程序我们都要执行27 mtc0 t0, CP0_ENTRYHI // 恢复之前暂存的ENTRYHI28 j ra // 函数执行完成，返回原程序29 END(tlb_out) 2.6整体来说，用户程序进行CPU缓存的过程是这样： 执行用户程序前，由内核进行TLB等内存相关硬件的初始化，随后再执行用户程序 用户程序执行到lw/sw指令，检查TLB （我们先不考虑Cache）若TLB表项命中，则将处理器中的虚拟地址转换为物理地址，进行访存 若TLB未命中，则由硬件产生缺页中断，进入内核态，执行对应的异常处理程序； 在异常处理程序中，调用了我们Lab中实现的do_tlb_refill等一系列函数 执行完成后，从内核态退出，回到产生异常的访存指令，继续执行。 2.7我选择LoongArch；此处仅对32位的LA32R进行讨论。 由于一些历史渊源，LoongArch有不少地方跟MIPS十分相似，比如，页表都采用了奇偶页的设计： 在我们本单元介绍的4Kc核中，MMU必须通过TLB进行地址翻译，而LA32R可以通过CSR（控制状态寄存器）配置地址翻译模式，在MMU处实现更灵活的地址翻译：![[Pasted image 20250401224956.png]] 直接地址翻译模式在地址为32位时，最高位拉低。类似于我们在MIPS中处理kseg0的虚拟地址转换。 直接映射地址翻译模式将虚拟地址的[31:29]位，由CSR中存储的映射，进行变换。仅在虚拟地址的[31:29]位命中时，且权限允许，才允许翻译。 这跟我们在MIPS中kseg1拉低高三位地址，得到实际地址有一点像，不过这里允许的映射更灵活。 页表映射翻译模式整体思路与MIPS实现基本一致，不过LA32R中由于权限等级不止内核态/用户态，还会对权限进行检查。同时也正因此在内的一些其它原因，LA32R中TLB表项结构与MIPS略有差距。 在Tag项中，LA32R多放了一个E，指示TLB表项是否为空；Data项的V仍然执行指示TLB项有效的功能。 PS仅在MTLB(数据存储对应的TLB)中出现，指示页的大小（LA32R支持大页） PLV0/1：指示特权等级限制。 MAT：指示存储访问类型； 具体有哪些访问模式见下，与MIPS下的基本一致。 LA32R了采取两种地址翻译模式；在映射地址翻译模式下，访问模式存在TLB表项中（这一点跟MIPS TLB项中的C0/C1域相似）；而在直接地址翻译模式下，由于不通过TLB，我们必须想办法存这一情况的访存模式，这就是CSR.CRMD中存直接翻译情况下访存模式的目的。 其中，CSR.CRMD指示了当前所处的特权等级，中断使能与（直接地址翻译模式时的）地址翻译模式： 其余过程与MIPS是基本一致的，不过： TLB访问/维护过程直接被打包成了一条指令 CSR中内容的划分与MIPS的CP0不同，比如LA32R中的ASID单独使用一寄存器管理。 限于篇幅，且并不紧要，这就不再展开了。 Appendix A.1整体布局应该是这样的： 123456[PD] - [PD] - [PD] - [PD] - [PD] - [PD] - [UPD] - [PD] | |[PT] - [PT] - [UPT] - [PT] - [PT] [PDp] - [PDp] - [PDp] | | | [PTp] - [PTp][PTE] - [PTE] 其中， 1234U：代指UniquePD：Page DirectoryPT: Page TablePDp/PTp：页目录/页表地址 由于题意语焉不详，我们认为所求的是三级页表的一级页表。1addr_UPD = PT_base + PT_base &gt;&gt; 30 &lt;&lt; 21 1result = PT_base + PT_base &gt;&gt; 30 &lt;&lt; 21 + PT_base &gt;&gt; 30 &lt;&lt; 12 + PT_base &gt;&gt; 30 &lt;&lt; 3 难点分析双向链表的实现主要是双向链表的实现并不直观，需要花时间进行理解。 整理下来，双向链表的结构整体长这样： 头节点特殊，只有next域 对于一个节点，有prev，next两个域 next是指向下一节点的指针 prev是 指向上一节点的next指针 的指针 由此设计，可以避免对头节点的特判。因为我们维护头节点的next，只需解下一个节点的prev指针，就可维护。 页的管理我们在整个Lab里做的，都是页控制块； 关键在于mips_vm_init()这个函数： 这里面涉及的都是物理页面/物理页号。 pages的作用，不仅是记录页的基地址，以通过&amp;pages[i]的方式访问第i页的地址，还有以pages[i]的形式，访问与维护第i个控制块。 转换到物理地址，就需要指导书中提到的两个宏了： 而虚拟地址到物理地址的映射，是由page_insert完成的。 实验体会本周完成耗时远高于Lab1: 一是内存管理具有一定的复杂度； 二是第一次接触一些实现，如本实验中的双向列表，理解需要一定的时间； 思考题深度很深。 要顺利完成的话，必须对内存管理机制足够熟悉才行…… 原创说明除引用的手册内容以外，本报告为本人原创。 LA32R手册 MIPS 4Kc手册","link":"/2025/07/08/OS%20-%20Lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"title":"OS - Lab3实验报告","text":"归档于2025年7月8日。 思考题3.1 UVPT指示的是整个页表空间的起始位置。 在页表自映射的设计下， e-&gt;env_pgdir[PDX(UVPT)]访问了页目录中，指向页目录自身的页目录项； 将这一页目录项赋值为PADDR(e-&gt;env_pgdir) | PTE_V，也就是在构建自映射，并让这一项有效，从而使得页目录可被正确访问。 3.2TLDR： data域用于传入进程控制块e的指针；调用来源在load_icode()； 其作用，是为了得知进程控制块对应的内存空间，从而让程序机器码加载进进程对应的内存空间 没有当然是不行的，不然操作系统根本不知道程序的机器码加载到哪… 以下是本人的探索： 在开始之前，我们不妨先理一下调用关系： 先调用load_icode()，作为加载程序机器码的ABI 随后，load_icode()遍历ehdr中的所有段，调用elf_load_seg()，将段加载进进程控制块e的空间内； 随后，我们目光转向elf_load_seg()： 可以看到，加载分成两步： 加载机器码 处理页对齐问题（ROUNDDOWN()） 加padding 正如指导书所言，将实际加载交给外部函数进行，可以让elf_load_seg()只关心段的加载，而不必担心页面相关的操作。 3.3 虚拟地址未按页对齐；见offset = va - ROUNDDOWN()部分 正常加载：见Step 1 机器码大小小于段大小：加padding，见Step 2 3.4当然是虚拟地址。 PC（Program Counter）本身就是一个虚拟地址，其会映射到内存的某一部分，那一部分存放着程序的机器码。 既然PC是虚拟地址，那么记录出错发生时PC的EPC自然也是虚拟地址了。 3.5在genex.S中。handle_int在其中直接实现。 但是，对于其他函数，与其说函数被实现，不如说，函数在genex.S内由一个宏，映射到了一个已经实现了的函数： 1234567891011121314151617181920212223242526272829303132333435genex.S: 1 #include &lt;asm/asm.h&gt; 2 #include &lt;stackframe.h&gt; 3 4 .macro BUILD_HANDLER exception handler 5 NESTED(handle_\\exception, TF_SIZE + 8, zero) 6 move a0, sp 7 addiu sp, sp, -8 8 jal \\handler 9 addiu sp, sp, 8 10 j ret_from_exception 11 END(handle_\\exception) 12 .endm... // handle_int定义 20 NESTED(handle_int, TF_SIZE, zero) 21 mfc0 t0, CP0_CAUSE 22 mfc0 t2, CP0_STATUS 23 and t0, t2 24 andi t1, t0, STATUS_IM7 25 bnez t1, timer_irq 26 timer_irq: 27 li a0, 0 28 j schedule 29 END(handle_int) 30 // 调用宏，映射函数 31 BUILD_HANDLER tlb do_tlb_refill 32 33 #if !defined(LAB) || LAB &gt;= 4 34 BUILD_HANDLER mod do_tlb_mod 35 BUILD_HANDLER sys do_syscall 36 #endif 37 38 BUILD_HANDLER reserved do_reserved handle_int之所以要单独实现，是因为其涉及CP0的操作，这一部分必须依靠汇编语言实现。 对于其它的，例如handle_tlb()，我们在上面可以看到，其被映射到了我们之前实现的函数do_tlb_refill。 3.6 在通过enc_gen_entry进入异常处理程序后，时钟中断被关闭 异常处理程序（e.g. handle_int()）期间，时钟中断也处在关闭状态 在处理完成，调用ret_from_exception()时，eret指令会将EXL置低；此时UM已被设为1，故此后运行时钟中断，进入用户态 3.7此处我们就以实验环境的MIPS与MOS系统为例。 在一个体系结构（e.g. MIPS）下，会有一组状态寄存器（MIPS中，是CP0.Count/Compare），分别记录自开始以来经过的时钟周期，以及一次时钟中断需要经过的时钟周期； Count每经过一周期加一次；加到与Compare相等时，产生时钟中断，同时在CP0的相关寄存器中记录下中断信息。 产生时钟中断后，系统进入内核态，自CP0读取当前的中断信息；得知此时产生的是“定时中断”，遂进入对应的异常处理程序：这里就是我们的schedule()。 schedule()将对我们的env_sche_list进行操纵，将当前的进程放入调度队列末尾，随后选取待调度进程； 随后，使用env_run()，用选中的待调度进程，替换掉当前正运行的进程，其中进行了上下文的保存与切换。 对于其它体系结构与操作系统，上面的整体思路也是不变的。 难点分析本人在进行Lab3时，遇到的最大困难，是进程切换的调度过程，以及其中的函数调用关系。 我们进程调度的相关代码，是在sched.c中完成的。 但是，其中的schedule()其实只负责env_sched_list、以及进程切换的时间计数count的维护；实际的切换，是在env_run()中完成的。 若无法理清过程中的函数调用关系，在这里就很容易栽跟头。我一开始就犯了这么一个错误：在schedule()中，就将curenv赋值为即将被调度执行的进程块，导致后续出错。 Lab3中，加载ELF时，load_icode()有关的函数调用关系也有些复杂。但在阅读源码后，我感觉自己的理解清晰了许多。（还是要RTFSC啊，笑 实验体会 注意到Lab3处的注释，较前两次给出的提示有所减少；这为我们真正理解实验内容，自行编写代码提出了要求。 坑点不少，需要细心：如schedule()中如何处理无待调度进程的情况（panic()），env_alloc()处，需要判断无空闲进程块的情况，返回-E_NO_FREE_ENV；这一点注释中没有明显提示。 原创说明本次实验报告为本人原创。","link":"/2025/07/08/OS%20-%20Lab3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"title":"OS - Lab5实验报告","text":"归档于2025年7月8日。 思考题5.1这跟Cache的更新策略有一些关系。 若Cache采用了写回策略，则：由kseg0写设备，向设备传递的数据会被存入Cache，而不会真正到达设备；仅在对应Cache块被清除掉时，向设备传输的数据才能到达设备。这会导致设备的延迟响应，甚至不响应。 Cache的更新策略，也与这个问题有关。如果Cache中缓存了设备的状态寄存器，那么：众所周知，设备的状态往往实时变化，若要保持Cache与设备状态寄存器的一致，我们必须时刻更新Cache，其性能开销极大，完全背离了Cache的设计本意；不维持一致性，则在Cache中读出的设备状态信息与实际的设备状态往往不符，会引起程序逻辑的问题。 这样做对不同设备的影响当然是不同的。对于IDE硬盘，可能是一次读/写请求迟迟不响应，导致程序长时间阻塞；对于显示设备（串口输出/显示器/…），可能是迟迟不显示该显示的内容。 5.2答案在user/include/fs.h中： FILE_STRUCT_SIZE：文件控制块大小，为256 BLOCK_SIZE:磁盘块大小；与PAGE_SIZE相等，为4096 由此得知，一个磁盘块，最多可存储4096/256 = 16个文件控制块。 剩下两个问题，需要看f_(in)direct能指向多少个磁盘块；答案是10 + (BLOCKSIZE / 4 - 10) = 1024个。 对于文件，文件系统支持的单个文件大小，为4096 * 1024byte = 4MB。 对于目录，其下可以有1024 * 16 = 16k 个文件。 5.3分析可知，我们的块缓存，采用了类似Cache中直接映射的思路，故缓冲区大小即等于最大硬盘容量。 查询serv.h得知，我们得知这一片空间大小为0x40000000byte；换算过来，就是1GB. 这些宏定义能不能起个好点的名字？DISKMAX一晃眼还以为是地址上限，结果仔细一看才发现是空间大小…况且之前都是用上限来界定空间，这里突然换成基地址+空间大小又是个什么意思 5.4要我说，其实都重要… BLOCK_SIZE：硬盘块大小 N_DIRECT：文件控制块中，直接指向硬盘块的指针个数 FILE2BLK：一个硬盘块里，可存文件控制块的个数 SECT_SIZE：一个扇区的大小 SECT2BLK：一个硬盘块可以存多少个扇区；注意这二者是不一样的 DISKMAP/MAX：指示内存中，硬盘缓冲区的起始位置与大小 5.5在动手写程序之前，我们不妨先分析一番。 众所周知，fork()会将父进程的内存映射复制给子进程；此处指向Fd的内存映射，应该也是在被复制的内存映射范围内的。 12345678910111213141516171819int main(){ int fd; int r; char buf[512]; fd = open(&quot;/test&quot;,O_RDONLY); r = fork(); if(r == 0){ if((r = read(fd,buf,3))!=3){ user_panic(&quot;read error&quot;); } debugf(&quot;child read: %s\\n&quot;,buf); }else{ if((r = read(fd,buf,3))!=3){ user_panic(&quot;read error&quot;); } debugf(&quot;parent read: %s\\n&quot;,buf); } return 0; } 测试下来，确实也是如此。 编写的时候需要注意： open()返回的是fd的编号 read()/write()中的参数，传入的都是int fdnum，而非fd本身 file_read/write()是给驱动用的，用户态只需要调用open/write()。 5.6先看fd.h里两个： 123456 34 // file descriptor 35 struct Fd { &gt;&gt; 36 u_int fd_dev_id; // 设备ID；对于文件则为可以简单理解为硬盘ID&gt;&gt; 37 u_int fd_offset; // 当前读写位置，距起始位置的偏移&gt;&gt; 38 u_int fd_omode; // 文件读写模式 39 }; 123456 49 // file descriptor + file 50 struct Filefd { 51 struct Fd f_fd; // 文件对应的描述符&gt;&gt; 52 u_int f_fileid; // 文件ID 53 struct File f_file; // 文件控制块 54 }; 再看FIle结构体： 12345678910 26 struct File { 27 char f_name[MAXNAMELEN]; // filename 28 uint32_t f_size; // file size in bytes 29 uint32_t f_type; // file type 30 uint32_t f_direct[NDIRECT]; // 指向硬盘块的直接指针 31 uint32_t f_indirect; // 间接硬盘块指针 32 33 struct File *f_dir; // 文件所在文件夹 34 char f_pad[FILE_STRUCT_SIZE - MAXNAMELEN - (3 + NDIRECT) * 4 - sizeof(void *)]; // padding 35 } 顺手提一下，Fd是怎么变成FileFd的： 在serv.c的serve_open()中，先file_create()创建文件控制块， 再file_open()，将文件加载进文件控制块； 最后，配置好FileFd，由fsipc，将ffd传回给fsipc_open(path, mode, fd)中的fd，配合强制类型转化完成。 5.7怎么OS也要跟UML语义纠缠 一共有这三种： Found Message（如ENV_CREATE）：无触发对象消息 同步消息：发送后，发送者停止自己的活动，如ipc_send(fsreq)，直到收到返回消息 返回消息：如ipc_send(dst_va) 具体实现： Found Message：将信息存在一个指定空间内，发送者就什么都不做了；ENV_CREATE就是将进程放进调度队列里 同步消息：类似于握手机制，在一个ipc_send()后，立即执行ipc_recv()；在未收到信息时等待，收到后则程序恢复执行 返回信息：就是普通的ipc_send()，只是为了配合同步消息的实现。 难点分析文件系统 按照教程中示意图，我们可以得知： 用户进程通过调用库，请求文件服务，实现文件操作 file_read()/write()由用户库完成，而非直接调用文件服务 文件服务单独为一个进程 用户进程由进程间通信，与服务进程交互 服务进程由中断进入内核，进行外部设备的文件交互 MMIOmalta.h中，诸如0x18000000一类的地址，指向的是物理地址。 在内核中，欲通过MMIO对这些外设进行交互，则需要访问一个映射到设备物理地址的虚拟地址；这个虚拟地址在kseg1内，物理地址加上kseg1的偏移，即可得到对应的虚拟地址。 对于MMIO的内存操作，指针建议都带上volatile修饰符，以避免编译器错误优化，带来预期外的结果： kseg1看这名字就知道是内核态的地址空间；我们的IDE驱动程序在用户态，故我们需要一个系统调用，来对这个地址进行访问。 文件系统的空闲位图 位图的起点在Block[2]处，也就是Super Block的下一个Block 每一个字节设为0xff，即全设为1；一个块的字节大小即BLOCK_SIZE 第三步的if，即“根据实际情况，将不存在部分设为0” 在fs/fs.c中，由read_bitmap()，将位图读入bitmap[]中。 *bitmap是一个uint32_t *，也就是一单位的bitmap[]有32个硬盘块的空闲位，这就是为什么下面free有关函数，要用bitmap[blockNo / 32]的形式访问位图。 free_block()中，若blockno为0，则会将分区表和引导扇区free掉。参考删掉pagefile.sys会发生什么（笑） create_file()这个函数，实际做的是： 为文件分配一块空闲的空间。 首先，遍历目标目录； 先看是否有空闲File块，有则复用 完全遍历后，没有空闲File块，则为目标目录分配一个新的块； 新块的起始位置，就是目标File块的位置。 map_block()不要忘了，page_alloc是内核用的；用户态分配页，是通过syscall_mem_alloc()来实现的。 也别忘了，参数中envid = 0，指示当前进程。（syscall流程见本人Lab4文档…） 思考题用户态程序的编写注意到，实验环境中已有的环境，已经生成了二进制机器码。 本人并没有找到效仿之，并在init.c中ENV_CREATE的较简便方法，遂选择直接修改init.c进行运行。 小细节我记得最深的，就是设备物理地址是否合法的检验。 指导书里是这么写的（指导书给的范围没错）： 123同时还要检查物理地址的有效性，在实验中允许访问的地址范围为: console: [0x180003F8, 0x18000418), disk: [0x180001F0, 0x180001F8)，当出现越界时， 应返回指定的错误码。 然而直接按照上面的范围，把条件写成if ((pa &gt;= 0x180003f8 &amp;&amp; pa + len &lt; 0x18000418)是错的，条件应该是if ((pa &gt;= 0x180003f8 &amp;&amp; pa + len &lt;= 0x18000418)。 为什么？考虑基地址为0，空间大小为4；那么我们可访问的地址，应该是[0x0, 0x3]，对吧？ 但在上面，使用pa + len的情况下，0x0 + 4 = 0x4；此时我们应该是允许等于0x4的。 一个基本的数学小问题，需要细心，不能看到指导书就直接照搬。 思考题中提到的比如说进程通信（fsipc），Fd到Filefd的转换过程等等，我认为有难度的地方，我都在思考题部分提到了；若您感兴趣，还请重新翻到上文阅读。 实验体会本次实验虽然花了比我预期要多的时间（），但是难度比我预期要低。 我的感受就是，遇到不懂的，就边读边记，实在搞不懂就参考前人的经验。像Fd到FileFd的转换，我不边读源码，边在报告里记录其流程，我自己真不一定能搞定。 至于参考前人经验…就比如说上面提到的，设备物理地址合法性检验的问题，在我没查看MOS的开源代码前，我真没有意识到这个问题，花了不少时间找bug。当然，参考不等于抄，参考之后自己一定要理解。 原创声明本文绝大部分内容为本人原创，但在实验过程中，确定部分细节是否实现正确时，本人难免参考了以下资料： https://gitee.com/osbuaa/mos https://seafoodfat1ger.github.io/2024/05/29/OS/OS_Lab5","link":"/2025/07/08/OS%20-%20Lab5%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"title":"OS - Lab6实验报告","text":"归档于2025年7月8日。 思考题6.1很简单，我们把两个case互换即可。 12345678910111213141516171819202122232425262728#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; int fildes[2]; char buf[100]; int status; int main() { status = pipe(fildes); if (status == -1) return -1; switch (fork()) { case -1: break; case 0: close(fildes[0]); /* 关闭不用的读端 */ write(fildes[1], &quot;Hello world\\n&quot;, 12); /* 向管道中写数据 */ close(fildes[1]); /* 写入结束，关闭写端 */ exit(EXIT_SUCCESS); default: close(fildes[1]); /* 关闭不用的写端 */ read(fildes[0], buf, 100); /* 从管道中读数据 */ printf(&quot;parent-process read:%s&quot;,buf); /* 打印读到的数据 */ close(fildes[0]); /* 读取结束，关闭读端 */ exit(EXIT_SUCCESS); } return 0; } 6.2 在我们当前dup()的实现下，我们是先复制文件标识符，再复制文件内容； 如果目标是一个管道，如此就会导致pageref(pipe) &gt; pageref(fd)的取值发生最终取值外的变化； 如果中途被打断，此时执行判断，就会得到错误的判断结果 6.3在执行syscall时，系统的中断使能会被关闭，计时器发出的中断无效；因此，系统调用过程不会被打断，是原子操作。 与之对比，调用系统的某个模块，比如说，给文件系统进程，提出打开文件的请求，这个步骤不是原子请求。因为这部分，我们采用了微内核设计，将系统调用变成了进程间通信问题。 6.4 调整fd与pipe unmap的顺序后，是可以解决这一问题的：在这一操作下，我们总能保证pageref(pipe) &gt; pageref(fd)，即不会导致pageref(pipe) == pageref(fd)这一条件语句的取值，在执行过程中出现真实结果外的变化，因此在过程被打断时不会误判。 是会的；在我们当前的实现下，我们是先复制文件标识符，再复制文件内容；如此就会导致pageref(pipe) &gt; pageref(fd)的取值发生真实结果外的变化；调换顺序后，这句话就恒真，也就不会出现中途打断误判的问题了。 6.5打开文件的过程： 调用open()； 分配一个文件描述符； 通过与文件管理进程进行IPC，将文件映射到文件描述符中 建立文件内容的内存映射 读取ELF： 主要由我们已经实现的load_icode()实现 load_icode()调用elf_load_seg()加载各个段，并建立内存映射 有关.bss： .bss段是与.data和.text连在一块空间内的 .data与.text没有占满的空间，被置0,分给了.bss 另外分配时，使用syscall_mem_alloc()分配，但是不映射到任何内容 6.6在user/init.c中，我们可以找到答案： 6.7都是外部程序，因为我们都要开一个子shell来处理。 cd之所以是内部命令，是因为 cd改变了此时shell的工作目录；如果是外部指令，更改只会对子shell生效；换言之，我们此时交互的shell执行了之后没有任何效果。 6.8我们需要手动修改一下sh.c中的runcmd()，以在正常spawn时，输出spawn信息。 观察运行结果： spawn有两次，对应的均为执行ls.b与cat.b的进程； destroy有四次，对应两次spawn，以及两个fork()出的shell子进程。 难点分析我认为，是shell的整个执行流程，以及弄清楚shell与先前实现的功能之间如何连接。 在明白了外部功能是由子shell执行以后，以及spawn()函数的调用关系后，剩下的事情就很简单了。 实验体会OS的实验部分就此结束了。 尽管MOS的实现较为简陋，但在完成各个Lab的实验内容的过程中，我确对理论课所学知识有了更深的理解，也对硬件如何与系统软件构建联系有了初步的认识，收获颇丰。 至于Lab6，其实要完成的功能并不难，难点仍然在于整个执行流程。 原创声明本报告为本人原创。","link":"/2025/07/08/OS%20-%20Lab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"title":"自己的碎碎念","text":"在给各位塞的私货里面，我大段写了一些经验，自己这部分提的不多；故这里再多闲聊一点，让各位能对我大一经历了什么有点了解（笑） 学业本人现就读与计算机学院（6系）的计算机科学与技术专业。 那么，我是大佬吗？我不是。 专业分流时，本人成绩年级排名491/1034，分进6系的时候排名是171/190+。 成绩就自爆到下面吧，大家感兴趣可以看（bian）看（shi）: 如各位所见，真不行。 真要反思是怎么回事的话，可能是大一上/大一下的前半学期过于放纵，天天都抽时间打电动导致的。这就导致时间不大充足，数分/基物作业写不及只能抄，引起了一系列后果。各位如果十分重视学业，千万引以为戒， 北航这个大一虽然可以比高中放松一点，但还是可以当高四读的。（唉大类招生） 但也侧面说明了，其实现在大类招生也理性了很多，不用太“卷”就能整到自己想要的专业。 说来也惭愧，本人这几科里最亮眼的是英语。算是唯一可以吹嘘的资本（笑） 为什么选6系？兴趣使然居多。 主要是，孩子从小学就一路在打电脑兼折腾电脑，这方面兴趣浓郁不说，有关计算机的大部分术语我也算熟悉。 编程严谨而言不在我的兴趣范围内，就当是系统学习计算机知识必须要承担的代价吧。因此各位在大一觉得对编程没兴趣的话，也不要因此对选6系有所顾虑。 我是一开始就决定报6系的吗？算是，也算不是。 算是的原因是，我高考填志愿的时候确实是奔着6系的名头，把信息类放到了第一志愿；算不是的原因是，我在大一的时候，对选哪个专业的思想有非常严重的波动。 这里就谈谈这个波动吧。也算是一点分流经验分享？ 一开始是因为参观了41系的微纳中心，又看到学校方面的资源给的非常足，加上自己某种意义上也算是对计算机硬件感兴趣，而对软件不感兴趣而有了选41的想法。 提到41就不能不提2。为什么2不在考虑范围？因为我的认知是，41偏重CPU之类的大型芯片工程（这里姑且忽略一下41的器（cai）件（liao）和工艺装备系），而2偏重的是MEMS，FPGA之类的小器件，这个我不感兴趣。而且我觉得MEMS这类的市场早就饱和了（虽说需求还是旺的） 2还有个方向是电磁场。由于大一下我基物学得比较痛苦（某种意义也可以怪当时上电磁场这部分的zy老师上得过于无趣），加上数学不好，这个我觉得不行。 而且，打算去41/2，我为啥不在高考填志愿的时候填UESTC？ 然后有了编程激发不了自己兴趣，之后学着估计吃力的想法。在这个想法的驱使下，我拷问了自己报北航的目的是什么：说起来你可能不信，我最开始萌生报北航的意愿，是航空！ 欸！恰好我自己对航空的兴趣这么多年还真没减退，要不我准备大二转去隔壁5系吧！ 听起来确实很荒谬，但我当时确实就是这么想的！连假期补上工图之类的计划都做了。 这个影响还是有点大的。其一就是转专业的分数要求只要加权平均达到80即可，我有一段时间的学习方针就是不要太卷，能把平均分保住80分以上就可以了，到时候转去5系即可。当然这个方针对我后续的学习有不小的影响，间接促成了数分、离散、基物比较糟糕的成绩。 最后是怎么想的呢？住七年沙河算是一个劝退点（实话实说，我觉得沙河校区内的各项环境其实都不错，北京城逛个两三次基本就腻了，沙河的确是潜心治学的一个好去处）。还有就是转专业太麻烦的问题。 还有一个，就是我觉得我国在航空方面已经够先进了。C919的翼型我认为已经足够完美，歼20的气动设计等等都足够先进，读5系毕业之后，以后估计没我的事。换句话说，喜欢坐冷板凳，但航空的板凳已经够热了？233333 还有就是我数学不行。航空对数学要求还是高的，不信请自行了解一个叫Navier-Stokes方程的东西。 然后我又把目光投向了3系，准确来说是305。为什么呢？因为它们说是自动化，实际上飞控，无人机基本就是他们在干。师资力量也雄厚，而且航天口的活也有在干。控制工程我觉得也是个足够吸引我的领域。进3系算是可以把我的计算机+航空两个爱好能有机地联系起来。 顺带一提，各位选专业的时候，不妨进各学院的官网，看看博士生/硕士生导师的师资团队，对学院各个老师的大致研究方向有个概念。当时我就是这么了解41/3系的。当时看到305老师的研究课题很多契合我兴趣的时候，我那叫一个激动啊（ 那最后为什么不去？还是数学的锅，自动控制原理我觉得对我来说还是有点挑战… 其实我最后还是在3跟6之间摇摆不定，想的就是靠专业系统抽奖。第一志愿考虑初心写的是计算机，第二志愿就是自动化，然后系统抽到了计算机。嗯，就这样吧 对了，说到志愿、计算机等等，又想起一个事情，我为什么要选北航？ 高考填志愿的时候，我是可以挑战一下南大计算机的。但是，一是自己对航空的兴趣，二是北京的地理位置，三是危险的可能促成了我选北航。 第一个就不在这细说了，我们谈第二个。南京我以前去玩过，吃的真不行，鸭血粉丝汤之类的我真吃不惯，而且据说南大食堂也不行；北京能吃的就多得多。而且有一个重要影响因素，就是北京是全国拍飞机最好的地方之一（其它还有上海、成都等），而南京就没什么好拍的。 北京人文等方面的优势就不说了，不言自明。 危险的可能是什么呢？当时南大的计算机和天坑专业是放在一起的（好像是环境？），而且我的分数也是刚够到南大的门槛。考虑到这种危险性，我还是放弃填报南大的计算机，选择了北航。 现在我后悔吗？我不后悔。 倒是从铁了心读计算机的角度，还是有点后悔的。个人觉得6系开课的质量不如南大。南大的计算机教学我感觉还真优于6。要举例的话我就举南大的计算机系统基础课（PA）吧。我觉得那个才是我心目中读CS该上的课。 当然，上述仅供吐槽，大家看看乐子就好！千万不要跟着后悔啊23333，况且6系放眼全国而言也很不错了 有关英语既然是闲聊，那就多聊点吧233333 我觉得英语这方面我还是可以聊一点的，这里就分享一点我学英语的经历吧 我其实没怎么刻意学过英语。我英语真的全靠打游戏学的。 这方面要从一个叫未转变者（Unturned）的游戏说起，我在小学四年级-六年级的时候玩得很多。当时这个游戏没有官方中文，汉化全靠民间汉化补丁。 但是！这个游戏经常更新新内容（好事），民间汉化自然是更不上更新的进度的，然后就会出现游戏界面中英掺杂的混乱情况。 这TM能忍？某种意义上，我是有强迫症的，比如中英掺杂我看着就不爽 （可能是这个的原因，我看着导员等天天说ddl这个词就非常的不爽，好好说截止日期会死？） ，于是我一怒之下卸载了汉化，且不管当时的我看得懂不，直接上英语原版！影响其实也不大，因为各个功能的布局我都记着的。自此孩子打开了新世界的大门，在眼前看到的英语界面和记忆里汉化界面的中英对照下，我记下了不少有用的词。** 这个习惯延续到了我后面五年级开始打彩6的时候。某种意义上，是彩6把这个习惯发扬光大的。 因为当时的彩6中文字体有问题（尤其是数字），看着那叫一个难看；英语的字体就没问题。然后我就顺手把彩6的界面也调成全英了。欸！彩六这边有旁白且也是英语（旁白甚至还提供多种语言），旁白还带字幕，还有干员小故事，顺手学英语的条件那叫一个优越啊！ 后面就成瘾了。能调英语的界面我都尽量调（Windows这边，微软式中文功不可没）。硬要说原理就是创造一个能每天用英语的环境。当然国产软件我不调，以微信等腾讯应用为例，那个英文翻的tm什么玩意 由于我复杂的成分，我无聊还有看Linus Tech Tips（加拿大白嫖王，在此顺便向NixieSub致敬一下），LGR，The 8-bit Guy之类的频道，现在想起来也对学英语有帮助？ 然后再加上自己看到不认识的词就顺便记一下的习惯，还有看到东西就无聊想想英语对应什么词的神奇习惯，这英语就这么学会了（ 说到背单词？初中轶事：当时我们英语课不准上课整英语以外的事情，我手上恰好有一本牛津高阶词典，然后我没事干就拿它翻着玩，看到我感兴趣且不认识的词就顺便记一下；某种意义上，这就等于背没难度上限的乱序版词汇书（更直白一点，这不就tm背词典吗？），词汇量确实是这么来的，2333333。当然现在没干了，也没这个时间和机会干了 另有一份写得稍微正式点的主观经验分享，详见博客，欢迎围观/吐槽/围攻（误） 就写到这吧。","link":"/2024/08/07/casualTalk/"},{"title":"使用ReentrantLock，实现更灵活的锁管理策略","text":"本文是对OO第二单元总结的一部分。 前言众所周知，我们可以通过synchronized方法，以及synchronized代码块获取对象的锁；但是，你是否发现，这一做法有时并不灵活？ 就以电梯为例，我们现在使用这么一个设计：电梯属性为一个类（Elevator），电梯的运行由一个排班器线程（ElevatorScheduler） 管理，乘梯需求的分配由一个调度器线程（Dispatcher），根据电梯当前属性，决定是否分配给当前电梯： 两个线程自然会对Elevator产生竞争，我们想到的最简单解决办法，便是用synchronized块/方法解决，对吧？这里以排班器为例： 1234567891011121314151617181920212223242526ElevatorScheduler:@Override public void run() { synchronized (elevator) { switch (elevator.getStatus()) { case IDLE: idleSchedule(); case RUNNING: runSchedule(); case WAIT: waitSchedule(); } }}Dispatcher:@Override public void run() { ... synchronized (elevator) { if (elevator.canDispatch()) { elevator.addRequest(request); } }} 在我们的电梯进入WAIT状态，执行waitSchedule()开门上下客的时候，我们自然希望：此时Dispatcher也可将能够加入的需求，放入电梯的请求表内。 但是在上面使用synchronized块的实现下，我们的希望会落空：此时Elevator锁被ElevatorScheduler持有，Dispatcher此时无法加入任何请求；为了保证两线程在读取Elevator状态的关键节点不出错，synchronized块似乎也不能去掉，减小synchronized块的颗粒度也不好实现。 那么，有没有什么办法，能在进了WAIT状态后，让ElevatorScheduler暂时释放Elevator的锁，在ElevatorScheduler即将加入待乘需求的时候，又重新取回电梯的锁呢？ 是有的，这就需要用到我们今天的主角ReentrantLock。与synchronized类似，它也是一种互斥锁。在他的帮助下，我们可以突破synchronized关键字加锁的不少限制，为实现更灵活的锁管理提供可能。 基本使用构建与使用对象锁我们在这里只介绍如何使用ReentrantLock对一个对象加锁这一常见情况，其他情况欢迎各位自行查阅资料探索。 首先，我们需要将ReentrantLock作为对象的一个属性： 1234import java.util.concurrent.locks.ReentrantLock;public class Elevator { private ReentrantLock lock = new ReentrantLock();} 与synchronized块自动进行锁的获取与释放不同，我们需要显式通过lock.lock()与lock.unlock()两个方法，获取/释放锁。 显然，我们此时的lock属性的权限是private（你猜这限制哪来的？）。在线程中每一次对其加锁时，都要先ReentrantLock lock = elevator.getLock();再lock.lock();并不美观，我们选择在Elevator类中实现setLock()与setUnlock()两个public方法。这样一来，对象外线程即可由这两个方法，获取该对象的锁。 ReentrantLock还支持通过isHeldByCurrentThread()方法，查询当前线程是否持有锁；这为我们后续进行锁的管理提供了方便，建议用上。至于有什么用，请看后面。 123456789101112131415public class Elevator { private ReentrantLock lock = new ReentrantLock(); public void setLock() { lock.lock(); } public void setUnlock() { lock.unlock(); } public boolean hasReentrantLock() { return lock.isHeldByCurrentThread(); }} 与oolens介绍的ReentrantReadWriteLock类似，由于我们此时锁的获取/释放完全手动，我们需要使用try..catch..finally..块，避免出现异常时，锁泄露的问题： 1234567891011public class Dispatcher { ... public void example() { elevator.setLock(); try { // do something } finally { elevator.setUnlock(); } }} 以防各位产生思维定式，我们不一定要在finally{}里释放锁，在catch{}里也是可以的，比如这样： 12345678910111213141516171819202122232425262728public void example() { try { Elevator target = null; for (Elevator elevator : elevators) { elevator.setLock(); if (elevator.isOurTarget()) { target = elevator; } } for (Elevator elevator : elevators) { if (elevator != target) { elevator.setUnlock(); } } if (target != null) { // do something to it target.setUnlock(); } }} catch (Exception e) { // 全部解锁 for (Elevator elevator1 : elevators) { if (elevator1.hasReentrantLock()) { elevator1.setUnlock(); } } e.printStackTrace();} 我们实现hasReentrantLock()方法，用处就在这里；我们可以如上述例子灵活地管理锁的获取与释放，并避免了没获取到锁便释放，会引起的IllegalMonitorStateException。 可重入机制正如其名，ReentrantLock是一个可重入锁，即一个线程可以多次获取对象的锁，这与synchronized关键字对应的锁是一致的。 ReentrantLock实现可重入的方法，可以理解成： 有一个计数器，初始值为0； 线程调用一次lock()，计数器+1 线程调用一次unlock()，计数器-1 仅在计数器为0时，才认为线程释放了这一把锁 因此，在使用lock()/unlock()时，请务必保证这二者是成对使用的，否则锁不会正常释放。 修饰实例方法我们如何实现像synchronized关键字修饰实例方法一样，在执行该方法时，就获取该实例对象的锁的效果呢？ 只需在执行方法时获取锁，并在完成后释放锁即可。 12345678public void example1() { this.setLock(); try { // do sth } finally { this.setUnlock(); }} 那么，这种情况怎么办？ 123public synchronized int example2() { return 0;} 修改后的结构仍然与上文一致；Java此时会暂存return的值，先执行finally{}中的代码，再执行return，也就是说，我们上述的锁仍然可以保证会被释放。这方面的原理不是本文的重点，欢迎各位自行多加探索。 12345678public int example2() { this.setLock(); try { return 0; } finally { this.setUnlock(); }} 线程的等待/通知基本用法与synchronized关键字使用wait()和notify()/notifyAll()进行按对象的线程等待/通知不同，ReentrantLock使用另一Condition属性的await()与signal()/signalAll()方法，进行按条件的线程等待/通知。 我们需要将Condition也作为对象的属性；这里先实现按对象的等待/通知，在这一需求下，我们的对象中只有一个Condition属性： 123456import java.util.concurrent.locks.ReentrantLock;import java.util.concurrent.locks.Condition;public class Elevator { private ReentrantLock lock = new ReentrantLock(); private Condition cond = lock.newCondition();} 还是因为private属性的原因，我们需要给await()/signal()/signalAll()套个壳： 1234567public void condHangUp() throws InterruptedException { idleCond.await(); }public void condCall() { idleCond.signalAll(); } 不难注意到，给await()套壳的时候，我们要throws InterruptedException；这是因为，与synchronized不支持等待时发生中断不同，ReentrantLock支持等待时发生中断。这一部分就不展开了，各位大可自行探索。 随后，就可以按照仿照synchronized下的wait/notify逻辑，进行线程的等待与通知了。 同样，没有获取到锁就await/signal，一样是会引起IllegalMonitorState的，注意。（笑） 进阶用法上面提到，ReentrantLock进行的是按条件的线程等待/通知；我们可不可以绑定多个条件呢？ 是可以的，这也是其区分于synchronized的一大方面。 而且，我们可以借用这一机制，指定唤醒一个正在等待的程序，解决掉notifyAll()选取等待线程的随机性的问题！ 具体例子可以观摩这篇文章 中“ReentrantLock和Synchronized比较”部分，受限于篇幅，这里就不搬过来了。 公平锁支持synchronized关键字对应的锁是非公平的；也就是说，线程调度会随机选取一个被阻塞的线程执行。 在我们上面的样例中，我们实例化的ReentrantLock也是非公平的。但，ReentrantLock是支持实例化为公平锁的，我们只需调用实例化方法时，传入一个true布尔变量： 1ReentrantLock lock = new ReentrantLock(true); 公平锁会将被阻塞的线程进行排队；选取要执行的线程时，会选取队列中第一个被阻塞的线程。 这有什么影响呢？考虑这样一种情况： 1234567891011121314151617Thread1 { @Override public void run { synchronized (obj1) { foo(); } }}Thread2 { @Override public void run { synchronized (obj1) { bar(); } }} 在非公平锁的情况下，“有可能” 出现Thread1一直获得obj1锁，而Thread2一直被阻塞的情况，而公平锁的排队机制，可以保证这种事情不会发生。 不过使用公平锁，可能会对整体性能产生影响，这就见仁见智了。 警示谨慎与synchronized/多把锁混用本人在HW5中，我在已经实现了synchronized块的锁机制后，才决定换成ReentrantLock；但在修改代码的过程中，我出于偷懒的目的尝试synchronized与ReentrantLock两把锁混用，以期实现与原有代码的兼容性。 然后，Elevator类中出现了这样的方法： 12345678public synchronized int example2() { this.setLock(); try { return 0; } finally { this.setUnlock(); }} 随后就不会出意外地出意外了，程序中出现了多个死锁点，直到作业提交截止前我都没有找完，然后… 最后我还是决定，去掉电梯有关所有的synchronized。这样改以后，既方便维护，也顺便解决了所有的死锁问题。 最后，再次告诫诸位：！！谨慎对一个对象加多把锁！！，这是血的教训…… 加/放锁要谨慎使用ReentrantLock后，加/放锁操作全部手动，这就要求我们处理加/放锁格外谨慎。 建议回顾上面的“可重入机制”。 总结ReentrantLock用好的话，不仅能实现synchronized块做不到的灵活锁管理，更能因此做到程序效率的提升。 欢迎大家对此多加尝试，也预祝大家顺利通过U2的所有作业…","link":"/2025/04/17/%E4%BD%BF%E7%94%A8ReentrantLock%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E9%94%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/"},{"title":"图床测试","text":"通过阿里云OSS+PicGo的方案，本博客成功实现了图床功能。 Github在国内访问速度太慢，为了实现图片快速加载，只能加点钱上阿里云了 :( 不过一个月也就6块钱，也就约等于一个月少喝一瓶东方树叶嘛😋","link":"/2023/11/30/%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95/"},{"title":"OS - Lab4实验报告","text":"归档于2025年7月8日。 感觉开始上强度了。 我需要从头理一些东西。 杂记syscall的处理以debugf()为例： 处理参数，随后调用vdebugf() vdebugf()中调用熟悉的vprintfmt，用debug_output作为后端 随后还调用了debug_flush()，调用出syscall_print_cons syscall_print_cons()调用msyscall()，传入信号参数SYS_print_cons，指示之 好，到了msyscall，发现其只做了这么简单的事情： 1234567891 #include &lt;asm/asm.h&gt;23 LEAF(msyscall)4 // Just use 'syscall' instruction and return.56 /* Exercise 4.1: Your code here. */7 syscall8 jr ra9 END(msyscall) 只调了个syscall，然后返回，没了？我参数呢？在调用msyscall的时候，参数就已经存在了栈上了，不用担心。 之后就是进入syscall的异常处理程序；自然我们想到往genex.s看： 1BUILD_HANDLER sys do_syscall 好的，异常是由do_syscall()做的，继续看；存在syscall_all.c里的： 众所周知，我们的异常处理会保存Trapframe；Trapframe的保存，是在进入了内核态之后，在entry.S中进行；此时Trapframe保存了我们msyscall()的参数，故我们的参数这里才会用到； 首先就是第一个参数；当然是从$a0($4)里取了；这样，我们就知道要执行哪一个系统调用，从syscall_table[]里取函数了。 出问题的时候，就返回一个异常值；函数返回值（第一个）就是$v0($2)了；存了之后return就是。 整个系统调用流程大概就是这样。 sys_*()需要注意的是，我们在系统调用中进行的系统操作（增删映射，设置进程控制块状态等），一般都是由sys_*()完成的，而非直接使用page_remove()等函数。 最主要的原因是，我们需要由envid2env()，围绕envid/pid进行一些处理，比如： envid == 0，则指向当前进程 判断进程是否已被释放（status == ENV_FREE） 进程ID是否出错：我们由ENVX(envid)取出的进程块的envid，应该与我们现在这个envid一致 权限检查：检查操作是否是进程自己对自己，或者是进程对自己的 “直系子进程”。 我自己做Lab4的时候没怎么注意这个问题，然后就踩坑了。 进程间通信我们这里是通过内存共享实现的。 为了实现IPC，我们需要在进程块中加这么几样东西： 起点；来自哪个进程 终点；被映射到了接收方的哪个虚拟地址 传递的信息 当前进程是否可接受信息 当前进程是否在等待要接收的信息 进行进程通信这个操作，还是通过系统调用（syscall） 实现的。因此，对应逻辑在sys_*()中。 我们在这里的问题是，这里对应的共享内存空间到底是哪里？ 阅读源码，我们发现其利用is_illegal_va()检查地址是否合法： 123112 static inline int is_illegal_va(u_long va) {113 return va &lt; UTEMP || va &gt;= UTOP;114 } 然后，是时候好好看看内存布局了： &lt;UTEMP：无效内存对应空间 &gt;= UTOP：超出kuseg的一定范围；换言之，超出了用户栈的范围 也就是说，我们共享的信息，是在用户空间内共享的。 1我们知道，所有的进程都共享同一个内核空间（主要为 kseg0）。因此，想要在不同空间之 间交换数据，我们就可以借助于内核空间来实现。 指导书的这句话，意思是借助内核空间，进行两个进程对同一内存块的映射。 看向sys_ipc_recv()： 我们为何要((Trapframe *)KSTACKTOP - 1 )-&gt;regs[2] = 0； 此时，我们的当前进程的栈，自然在栈顶上；栈使用的空间正好就是Trapframe的大小，故我们这么做，就是在访问当前进程的上下文，将函数返回值设为0. 那么，为什么我们这里不直接return呢？ 因为我们此时要做到一个阻塞进程的效果，若直接return 0，进程就会继续恢复进行，不符合我们的预期；将返回值暂存在上下文中，就可以做到阻塞解除后，进程被重新调度，恢复执行，得到返回值0的效果了。 阻塞的解除，是在sys_ipc_try_send()里，由修改接收方状态为ENV_RUNNABLE，并将接收方重新放回调度队列中实现的。 对了，还有个好玩的事情： 为何我们不需要checkperm？因为进程间通信不需要检查进程是否为父子关系；checkperm检查的是envid是否指向自己，或自己的直系子进程。 src/dstva == 0 ？我认为指导书这里说的不是很清楚？ 不难注意到，我们在try_send()时，在srcva == 0时，不会将发送方的某个页面，映射到接收方的某个页面上。 但是，我们还是会对接收方进程控制块的ipc域进行修改（e.g. 待接收位拉低，value位设为要传递的value值），并将接收方放回调度队列。 这一点很关键。 当然，这其中一个作用就如指导书所言，仅由进程块的value域传递小量信息，快捷方便；但我认为这跟进程的同步也有关系。 回顾前面的recv()，我们在待接收时阻塞，在发送时唤醒，这不就是多进程的同步吗？（笑 fork()fork()怎么创建一个与父函数不同的新进程的？这个答案指导书已经告诉我们了，通过fork()-exec()的配合。 小实验对了，在做实验的时候，我发现了一个有趣的现象。在使用管道重定向带fork()程序的输出的时候，输出有些奇怪： 12345678910111213141516171819 1 #include &lt;stdio.h&gt; 2 #include &lt;unistd.h&gt; 3 4 int main() { 5 int var = 1; 6 long pid; 7 printf(&quot;Before: var = %d\\n&quot;,var); 8 pid = fork(); 9 if (pid == 0) {10 var = 2;11 sleep(3);12 printf(&quot;Child: %d&quot;,var);13 } else {14 sleep(2);15 printf(&quot;Parent: %d&quot;,var);16 }17 printf(&quot;, pid: %ld\\n&quot;, (long) getpid());18 return 0;19 } 12341 Before: var = 12 Parent: 1, pid: 1132673 Before: var = 14 Child: 2, pid: 113268 Before句按理只会输出一次，为何这里输出了两次？由于我们的实验还没做到管道部分，这里我们暂时也不知道为什么… 自上而下分析fork()干了这么几件事： 设置父进程的TLB Mod Handler exofork()创建子进程，获得创建好的进程控制块的PID 自此开始分割父进程和子进程；父进程在此完成所有操作，返回0 子进程：构建父进程所有页的映射 设置子进程的TLB Mod Handler，并让子进程进入RUNNABLE 还有一点： 1MOS 允许进程访问自身的进程控制块，而在 user/lib/libos.c 的实现中，用户程序在运 行时入口会将一个用户空间中的指针变量 struct Env *env 指向当前进程的控制块。对于 fork 后的子进程，它具有了一个与父亲不同的进程控制块，因此在子进程第一次被调度的时候（当然 这时还是在 fork 函数中）需要对 env 指针进行更新，使其仍指向当前进程的控制块。这一更新 过程与运行时入口对 env 指针的初始化过程相同。 这就是为什么： 继续。构建父进程映射部分的细节颇有意思： 结合上面的内存空间图，我们得知：我们将kuseg段，所有在USTACKTOP下的页面全部映射到子进程中（当然要做COW的处理）；这样一来，循环条件就很明显了：找所有USTACKTOP下的页。 随后就是里面的条件了： 页号对应页目录项要有效 页表项要有效 非有效即可认为映射不准确，故选择不映射；到时候会产生缺页异常重新取的。 思考题4.1在我们上面回顾了一下syscall的流程后，这个问题就很好解答了。 将GPR的所有信息存入Trapframe，在处理完成后再从Trapframe恢复，这样GPR的信息在调用前后就不会发生变化。 理论而言是可以的，因为此时的$a0-$a4按理没有发生改变，但这违反了我们保护现场的原则；这也是我们为何需要从Trapframe中读取的原因；此外，Trapframe自身能保证GPR就是调用前的状态，有更保险的方法为什么不用（） do_syscall()从Trapframe中读出msyscall()传入的参数，从而将这些参数分发给sys_*() 这部分的改变主要在do_syscall()中发生；此时，cp0_epc加4；在用户态，表示异常处理完后直接执行下一条指令；tf-&gt;regs[2]被设为了调用的处理函数的返回值；如果没有对应系统调用的处理函数，会返回一个错误值；对于用户态，我们此处就可以根据返回值确定系统调用的状态，对应进行处理。 4.2为了检测envid对应的进程是否真的存在。 有这么一种可能： 传入envid2env()的envid是一个当前不存在的进程 envid指向的envs[]存的是无效信息 如果不判断，我们就会错误地认为这个进程存在… 4.3首先，mkenvid()正如其名，创建一个新的进程ID，它的结果当然不应该为0。 envid2env()这一函数其实“名不副实”，因为除根据envid获取进程控制块外，他还整合了检查进程控制权限的功能。 何为“进程控制权限”？阅读源码，我们知道，“进程控制”只有在两种情况下合法： 查询的envid，对应的正好就是调用envid2env()的进程自己； 查询的envid，对应的是调用进程的 “直系子进程”。 envid2env()能处理envid==0的情况，其实是为了给进程获取自身的进程控制块提供方便。毕竟，进程此时不获取自己的进程控制块，是不知道自己的PID的。 4.4C。 父函数调用fork()，生成了子进程；随后，给父子两进程返回不同的返回值。 4.5把内存空间图继续搬下来： 对于USTACKTOP以上的空间： ULIM-UVPT：父进程自己的页表，我们的duppage会做重建页表的工作，故不用 pages/envs：被映射到系统的pages[]和envs[]两个内核数组；每个进程在env_init时就做了映射，故不用 exception_stack：仅在用户态处理异常时要用到，这里用不上，故不管 剩下的只要满足条件，就要映射。 4.6首先，我们知道，页表是被映射到了一个确定的虚拟地址上的，且我们的MOS采用了页表自映射。 vpd，vpt分别获取页目录和页表的起始地址；lib.h中将二者分别定义为了Pde *与Pte *，故按照指针的用法使用之即可；比如说，可以vpd[PDE_ID]，也可以vpd + PDE_ID。 页表被映射到了一个确定的虚拟地址上；一个进程拥有一套自己的页表；在切换进程时，这个页表也会被切换。在得知基地址和偏移量后，能访问页表就很自然了。12#define vpt ((const volatile Pte *)UVPT) #define vpd ((const volatile Pde *)(UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT))) vpd处UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT)已经很明显了，不再赘述 不能，权限不够 4.7 重入机制如下，注意tf-&gt;regs[29] &gt;= UXSTACKTOP 12345680 void do_tlb_mod(struct Trapframe *tf) {81 struct Trapframe tmp_tf = *tf;8283 if (tf-&gt;regs[29] &lt; USTACKTOP || tf-&gt;regs[29] &gt;= UXSTACKTOP) {84 tf-&gt;regs[29] = UXSTACKTOP;85 } 考虑这么一种可能：do_tlb_mod的处理函数，再次访问了一个需要COW的页。 此处异常处理的一部分在用户态处理，这是有可能破坏上下文的；为了维护进程进入异常处理前后的上下文一致，我们自然需要保存进入异常前的上下文。此外，异常现场是在进入异常时保存的，对用户态透明，故我们需要将其复制到用户空间。 以防我忘了，多写一点：do_tlb_mod()中，进行了上下文的复制；对于现在放在Trapframe的那一份上下文，我们修改其cp0.epc到处理函数的位置； 随后，开始执行处理函数（如cow_entry）。执行完成后，会调用syscall_set_trapframe，以复制的那一份上下文，恢复进程的上下文。 恢复$sp和上下文，是在sys_set_trapframe处完成的。 4.8 微内核的概念中，异常处理放在用户态处理，减少了因权限不足等问题引起系统崩溃的可能。 在用户态处理页写入异常时，我们可以调度其他进程继续执行，避免主机为了处理这一异常，让其他进程等待太久。 4.9 我认为二者相对位置没什么影响。因为第一个set_entry是对于父进程的，子进程直到父进程为其设置tlb_mod_entry（第二个set_entry）前都不会执行，故没有影响。放的位置可能就看个人喜好了。 写时复制保护，保护的是USTACKTOP下的所有内容；这当然也包括了我们的函数参数；假设我们调用了一个函数，就可能触发COW；如果我们将set_entry放在COW机制后，就有可能导致调用函数时产生COW异常，而没有对应处理函数的问题。 难点分析 各个过程耦合程度挺高的，需要真正重头过一遍才能看懂。具体见我上面的杂记吧。 在前几个单元的思维定势下，我常常忘记一些地方需要用sys_*()；比如duppage中页表的映射，我下意识就输入了page_insert()… 细节很多。比如说fork进行COW映射时，还需要关注页目录/页表项是否有效。没有注释的提醒，我一开始确实没有考虑这么多… 实验体会我深刻感觉到本单元开始，任务的加重。 首先是注释细化程度进一步下降，这让我不得不更谨慎地考虑实现细节。最后确实发现不少细节漏掉了，比如上面提到的COW映射，与页目录/页表有效有关的问题。我自觉自己注意细节的能力在日趋下降，是时候想办法改变一下了。 说实话，本次Lab是我第一次大量参考往届学长/MOS开源仓库的代码。虽说能保证最后结果正确，但为了避免印象不深，而在第二天从头再看一遍的时间开销还是很大。怎么才能达到独立完成，和参考他人经验之间的平衡，是个值得探讨的问题。 原创声明本人报告的绝大部分内容由我自己独立完成。但我在思考题4.5、4.7处遇到了一些困难，有参考两位学长（学姐）博客中的思路，谨此致谢： https://seafoodfat1ger.github.io/2024/05/24/OS/OS_Lab4/ https://volcaxiao.top/2023/06/10/BUAA-OS-lab4-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8Eipc%E4%B8%8Efork/#%E5%AE%9E%E9%AA%8C%E4%BD%93%E4%BC%9A","link":"/2025/07/08/OS%20-%20Lab4%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"title":"在IDEA内部，进行更高效的死锁调试","text":"本文是对OO第二单元总结的一部分。 前言oolens最近发的多线程文章中介绍了两套调试工具，但个人认为二者功能相互独立，且二者使用起来都不大方便。这两个工具还是太吃操作了，有没有什么更简单又强势的工具推荐一下呢？ 有的兄弟，有的！ 使用IDEA本身就够了！我们主要利用的，是它的Dump Threads（获取线程转储）功能。 基础操作这个Community版本也能用，没搞到Ultimate版的同学不用担心。 在你使用IDEA运行程序的时候，你是否好奇过，这个照相机是个什么玩意？这其实就是我们今天的主角Dump Threads了。 直接左键选中，会进入一个菜单。这个选项可以抓取当前时刻程序运行状态的快照，记录了当前程序下所有线程： 是否等待 等待类型 在代码运行到何处等待 调用栈等详尽的信息，为我们的调试带来了极大的便利。 直接点开超链接，甚至可以直接定位到代码处： 妈妈再也不用担心我找不到死锁了！ Debug处也有这个入口，在更多选项里： 要这么做有一个局限性，就是当前程序必须在IDEA内运行，可能需要配合更好用的数据投喂器使用。当然，如果能用下面提到的方法，这个局限就不存在。 更进一步 - 使用IDEA Profiler（需要IDEA Ultimate，如果手上没有，获取方法还请自行探索 :D） 显然，我们一般跑程序，不可能全部放在IDEA里面跑；有没有什么像oolens里介绍的工具一样，找出当前运行的所有Java程序，并选取要分析的程序进行分析的方法呢？ 是有的，要用到IDEA Profiler。就是上个单元，我们分析运行时间接触到的那个IDEA Profiler。 他除了分析运行时间以外，还可以查看选中进程的运行状态。 要打开它，我们需要点开菜单栏中这个仪表盘图标： 点开之后，菜单里会列出正在运行的所有Java程序。如果我们此时的程序正在运行的话，我们可以在下面的选单里找到我们的程序： 随后直接左键选中，发现里面有个选项叫”Get Thread Dump”，跟我们上面的Dump Threads得到的效果是一样的。 如果我们此时拥有上述调用的源码，我们一样可以点开超链接，直接定位到代码对应位置；没有的话，IDEA甚至会帮你反编译： 整体效果跟oolens提到的jconsole基本一致，甚至比它还好用。 结语没什么好总结的，大家手上有IDEA的快去试试吧！:D","link":"/2025/04/17/%E5%9C%A8IDEA%E5%86%85%E9%83%A8%EF%BC%8C%E8%BF%9B%E8%A1%8C%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E6%AD%BB%E9%94%81%E8%B0%83%E8%AF%95/"},{"title":"技术演示 - 并发执行的多测试数据对拍脚本","text":"归档于250204，供后来者参考。 读前须知：本文针对Windows环境；Linux仙人参考思路即可… 需求：针对多组测试数据的评测为尽可能追求测试覆盖率，且方便测试程序的编写，我们往往会选择构造多组测试数据进行测试。 回顾本人先前构造，且至今一直使用的对拍脚本，每次仅可对拍一组测试数据。要进行多组数据的测试，需要每次对待测数据进行手动替换，效率实在太低。 因此，我决定对我的对拍脚本进行完善，使之支持多组数据的评测。 已有评测机存在的问题 - 效率太低考察了当前已有的COKiller等支持多数据评测的评测机，发现存在以下问题： 对多组测试数据的测试均是串行进行 有重复编译的现象产生 上述两个问题会大幅降低评测效率。 我们都知道，我们的Verilog代码是由fuse编译成iSim实例来运行的；对于一次对拍，我们只需要编译一次。 串行评测多组数据就不用说了，效率低自是当然。 本方法的实现整体结构以支持延迟槽对拍的脚本为例。P7的除了多加几个.py处理.ktext外，没啥区别… !make.bat：对拍程序入口； atom.bat：对一个测试数据进行对拍； clear.bat：清理临时文件； /code：存放各组测试数据 /src：存放Verilog源码 /temp：临时存放编译结果 result：存储各数据的对拍结果：输出与波形 *_filter.py：过滤输出，避免输出出现版权信息/向$0写入的信息 mips.tcl：配置是否产生波形/仿真上限时间用；具体见教程自动化测试相关内容 mars.jar：带输出的MARS。需要注意的是，各版本MARS运行时需要的参数可能不同，需要手动进入atom.bat进行修改；这个当然可以通过造接口解决，我图省事没做… !make.bat完成Verilog代码的编译工作，同时开始调度，让atom.bat对每组数据进行处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@echo off%运行前，先清一遍临时文件，以防没清干净% rmdir /s /q result 2&gt; nul rmdir /s /q temp 2&gt; nul%开始编译% md temp cd temp %根据src下源码，自动生成.prj文件% for /f %%i in ('dir /b ..\\src') do echo verilog work &quot;..\\src\\%%i&quot; &gt;&gt; mips.prj %xilinx%\\bin\\nt64\\fuse.exe -nodebug -prj mips.prj -o mips.exe mips_tb &gt;nul IF ERRORLEVEL 1 ( echo An error occurred when compiling. pause exit )%编译结束，退回上级目录% cd ..%创建result文件夹，方便组织输出% md result cd result%开始调度：以result为工作目录，对每个测试数据调用atom.bat进行处理% for /f %%i in ('dir /b ..\\code') do ( start ..\\atom.bat %%i )%处理完成，退回上级目录% cd ..%输出提示：只有在所有测试都完成，即上面start指令弹出的窗口都关闭时，才可按键继续，开始比较；否则会出现找不到文件的情况% echo Please continue only when EVERY TEST IS DONE. pause%进行对拍比较% echo Performing comparison... cd result for /f %%i in ('dir /b ..\\code') do ( echo %%i cd %%i fc /3 isim_out.txt mars_out.txt cd.. )%比较结束，退回上级目录，方便后面clear.bat执行% cd ..%暂停，方便查看输出% pause%结束时，清除一下编译产生的临时文件% clear.bat atom.bat每组数据的实际处理程序。 由于iSim的运行限制，为了实现并发执行，我们不得不把编译好的程序，复制到每个测试数据的输出目录下，在得到输出后再将其删除。这显然会带来存储空间带来压力，但真的没有更好的办法了。 我对P7的编译结果进行了查看，总大小是3mb左右；正常测试点数量规模下，占用还是能控制到1gb以下的；况且我们最后还是要给它删掉的嘛… 12345678910111213141516171819202122232425262728293031323334353637@echo off%提示在处理哪组数据% echo %1%在result目录下建立各组数据的输出文件夹% md %1 cd %1%获取机器码和mars输出% java -jar ..\\..\\mars.jar db mc CompactDataAtZero a dump .text HexText code.txt ..\\..\\code\\%1 &gt; nul java -jar ..\\..\\mars.jar db mc CompactDataAtZero nc ig coL1 ..\\..\\code\\%1 &gt; mars_out.temp%复制编译结果% md temp call xcopy /s /e /y ..\\..\\temp\\ .\\temp &gt; nul%获取行为仿真结果% cd temp copy ..\\code.txt code.txt &gt; nul call mips.exe -nolog -tclbatch ..\\..\\..\\mips.tcl &gt; ..\\isim_out.temp %获取波形（如果有必要...）% copy isim.wdb ..\\isim.wdb &gt; nul%完事，退回上一级% cd .. %过滤输出% python ..\\..\\isim_filter.py &gt; nul python ..\\..\\mars_filter.py &gt; nul %删除输出临时文件% del *.temp %删除复制的编译结果% rmdir /s /q temp%完成，退回result% cd ..exit clear.bat只用清掉最开始的编译结果就行了。结果在下次执行时自动删除。 12@echo offrmdir /s /q temp 其余的就不必说明了。 本方法未完善之处不大好解决的 在数据组数较大的情况下，生成的临时文件总大小过大。 这个在上面已经说过了，欢迎有解决办法的朋友积极指出，在此本人感激不尽！ start一次，开一个窗口。 这好像也可以算特性了？ 我对这个结果不大满意。在我的设想里，并行调用atom.bat时应该没有任何反应。在所有并发任务都结束之后，再自动进入比较环节。在座的各位一定有更好的办法。 调度策略过于鲁莽。 在本实现中，我们运用批处理的start来实现并行；读了上面的实现，我们不难发现，我们此时**有多少个测试点，就会同时开多少个atom.bat；若测试规模足够大，恐怕没有电脑能吃得消（看下面的分析，甚至8个就够呛）… 我的优化想法，是在make.bat里调用atom.bat的时候，不直接用start+循环调用，而是调用一个任务分配程序，由它按照配置好的最大并行数，进行数据测试任务的分配。再次，欢迎有解决办法的朋友积极指出，在此本人感激不尽！ 同时，由于我对Windows的批处理并行稍微熟悉，这部分我选择用.bat来写；相信python等在并行方面有更好的办法。 性能分析这里，我选择同时测试3组P7的测试点来进行性能分析。 我的电脑配置如下： 在CPU占用上，每一个mips.exe的CPU占用就已在10~20%左右波动；这也是为什么我上面说，现在的调度策略行不通： 内存占用其实还好，算上命令行和mips.exe的，总体还在可接受范围： 好解决的 必须人为判断各测试是否已完成（即start调用的窗口是否已经全部关闭）后，才能进行比较。 各路仙人的评测机已经有不少解决方案了。 比较方法较为原始。 这个可以用python的difflib等解决，不赘述了。 演示下载技术演示 - https://bhpan.buaa.edu.cn/link/AA86CF06932380478FBD0AB8D9A22178D8文件名：experiment_parallel.zip有效期限：永久有效提取码：9eXL ！！在运行前，请先配置好xilinx用户环境变量，具体见：http://cscore.buaa.edu.cn/#/discussion_area/1461/1777/posts ！！ 点击!make.bat运行，运行前先在/src里放好Verilog源码，在/code里放好待对拍.asm。","link":"/2025/02/04/%E6%8A%80%E6%9C%AF%E6%BC%94%E7%A4%BA%20-%20%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E7%9A%84%E5%A4%9A%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%8B%8D%E8%84%9A%E6%9C%AC/"},{"title":"建站第一日","text":"今天做成的事情不多，主要是做了一下侧边栏的结构，改了个色，加了个favicon，然后基本就没了。 上述工作的确很简单，但为何忙了一天，却只完成了这几件事呢？问题出在评论区功能和图床的实现上。 先说图床。这个Blog显然不会是一个纯文字的博客，后续放图进文章的问题肯定要考虑到。Github Pages没记错的话，库大小似乎是有限制的（1GB？），把所有文章的图片直接存库里固然不现实。找了一天，暂时还没有找到一个成本为0或接近0的方案，基本都要涉及到买域名/配置云服务。目前看到一个PicGo + Github的方案似乎可行，之后有空再试。 再说评论系统。为了和各位读者相互交流，评论区肯定是少不了的。但是，正是在评论区实现的方案选择上，我近乎浪费了一整个早上。为什么呢？还请继续往下看： NexT主题集成了几个评论系统：disqus, 畅言，livere，gitalk和utterances。disqus在国内访问速率堪忧，甚至大概率打不开，不在考虑范围内；livere在国内倒是能用，但是必须要社交平台账号登录，不大符合我允许匿名留言的想法；gitalk和utterances必须要求Github登录后才能评论，门槛之高不言而喻，且同样无法实现匿名评论。那畅言呢？要求登录是其一，其美观程度之差是其二，本着不妥协的原则，这个方案也行不通。 在上述方案都不符合预期的情况下，只得求助各路教程，而各路教程都不约而同地指向了valine。valine允许匿名，外观简洁，看起来就是最佳之选了。在一番了解后，发现valine原本被集成在NexT内，但出于不再开源和安全问题的原因被移除，以单独插件形式存在。安装并配置好后，却发现其无法正常使用：起初是出现401报错，后变为不报错，但评论无法正常发表，点下发表后毫无反应。 一番折腾后，评论区的建设仍毫无进展，只得暂时作罢。 Blog的基本框架现在已经成型。接下来的建设任务，我想就是攻克下这两个难题了。至于小细节，留到日后吧。","link":"/2023/11/28/%E5%BB%BA%E7%AB%99%E7%AC%AC%E4%B8%80%E6%97%A5/"},{"title":"本人背单词的粗劣经验","text":"写在前面：本文本来是写给本人一位英语学着有些吃力的好友的一篇私货；但由于自己在给梦拓学弟们写闲聊的时候扯到了我自己学英语的经历，索性就把我自己写的这篇烂文发出来给各位参考（或公开处刑）吧。如果本文有不足/误导/错误之处，欢迎您在本文的评论区中直接指出（更是欢迎语言学相关的朋友给予专业的指导），小弟必感激不尽！ 本文将对本人背英语单词的粗劣经验进行简单分享。 由于本人表述能力极差，加上我（自己觉得我自己）是个话痨，本文可能充斥着大量没必要的废话。如果这对您的阅读理解造成了极大的不便，本人在此深表歉意（） 希望下面这些内容，对你背单词有所帮助！ 奇怪的习惯自言自语 其实，我非常喜欢自言自语，就假装自己在跟身边一位好兄弟聊天。 考虑到本人自言自语频率实在太高，容易被人当成疯子，且自己说了什么，被人听到过于尴尬，我喜欢用英语自言自语。虽说学过英语的也能听懂，但这应该够阻止大部分人理解我在说什么了，2333 有这样一个需求之后，自然引起了一个问题。比如，欸！我要吐槽说，电梯又坏了，怎么维护做得这么差！？用英语自言自语，好，“电梯”和“维护太差”怎么说？为了将就这个怪癖，只能查一查了。一查，哦！电梯是elevator，维护是maintenance。 终于，我可以顺畅地自言自语出：”Why is the elevator not working again? How poor the maintenance is!” 嗯，终于吐槽出来了，爽了（笑） 这个办法理论上还能顺便练练口语？ 当然，除非你自己非常感兴趣，不要刻意这么做。一是容易被人当疯子，二是会损失自言自语本身的乐趣。自言自语本身也是一个不用麻烦别人，就能说出自己内心想法的好方法；有些话，哪怕是对自己说，也总比一直闷着好，至少我是这么觉得的（） “这个用英语怎么说？” 就算不用英语自言自语，主动找身边物体/概念对应的英语表述也是值得一试的。问就是，“以备不时之需”！ 那么，怎么查呢？词典是英汉，肯定不行；这就必须要借助一点网络的力量了。我认为这个要分两步。 第一步，先在网上查一下：对有道词典之类的网络词典，直接输中文应该就找得到；对于百度嘛，按“XX 英语”去搜也可以。但是，无论哪种方法，查出来都难免有偏差，尤其是词组！这就是第二步的必要性。 第二步，用词典再查一遍单词的释义，看看跟查到的能不能对得上号。就当是检验一遍，保险起见。具体查词典的操作，详见后文（） 背词典…？ 相信你以前看到过，也听别人说过，我抱着词典背这种事？ 个人认为，这个说法欠妥。某种意义而言，我是把英语词典当成没有难度上限的乱序单词书在用的，23333 当时，我也没刻意这么用词典过。只不过，在查词的的时候，我注意力一般都不大集中。查着查着，就看到了一个有意思的释义；然后，在查一个词的过程中，我就顺便记了不少和我查的词毫不相干的其他词（） ”有意思“又指什么呢？可能是我觉得会用得上的吧（考虑到我自言自语的奇怪嗜好，2333） 在要查的词周围，一般也会出现由这个词变出来的其他词，这也算是符合用词根法背词的需求了 然后，鉴于当时英语课不能干其他事，翻字典就成了我消磨时间的一个好方法（）。基本做法是，随便翻一页，看到我感兴趣的就记一下，嗯。 这也是我不喜欢电子词典或者词典笔之类东西的原因。查不准之类的另论，主要是因为它们每次只能查一个词，完全就没有这种发现新词，或者一次背一连串词的快感了！！ 把手机或者电脑的语言设成英语 直到现在，我也是这么干的（） 最开始的动机，还是强迫症！看到中文掺英语，我就不爽！恰好，我用的一些软件没有中文，这是其一。其二是，系统的有些中文翻译，我觉得很别扭，比如Windows 10系统著名（这里应该用notorious？哈哈）的“坐和放宽”（笑）。然后，我就把系统语言设成英语了。 反正常用的功能我记得怎么开、在什么位置，开英语不仅没有什么问题，反而在中英对照之下，我多记了几个词。（） 硬要说这么做有什么道理的话，我想，就是创造了一个自己能天天用上英语的环境吧，嗯。 查词用词典查单词 *这个栏目是在假设你不会的情况下写的。如果你会的话，请立即跳过这一部分 众所周知，英语词典没有检字表。那怎么找词呢？ 首先，英语词典的单词是从左到右，按字母顺序排序的。其次，跟中文字典类似，英语词典每一页的侧面，都有这一页可查单词的首字母标记；在词典的侧面看，这些标记组成了各个色块，呈V字排列。 这样一来，我们就可以快速找到每个首字母对应的区域，这是第一步。第二步，就是顺着字母顺序找词了？词那么多，怎么找？我一般是这么办的：比如查blame，我先在b开头的区域随便抽一页，然后看看这一页的词长啥样：如果第二个字母是e，在l前面，那就往后翻；如果是r，在l后面，那就往前翻。翻的时候，也不用一页一页地翻，一次多翻几页，然后反复重复上述步骤即可（） 用有道词典等电子词典查单词 这个不是直接输单词就能查了吗，为什么还要单独列出来呢？ 这是因为，电子词典一般都会有“简明释义”“网络释义”。然而，就个人经验而言，这些解释往往都不准确，甚至是错的；在你的拼写是错的情况下，它甚至都能给出意思，极具误导性。更何况，现在还有AI推荐结果，我个人试下来，觉得是靠不住的。 这里就只以有道词典为例吧。只有在查词界面能看其他词典（如：牛津、柯林斯、韦氏）的释义时，查到的词义解释才能保证是准确的。这个时候，为了绝对准确，还是要点开牛津词典的释义界面看看，不要看了默认的简明释义界面就跑（） 最后，尽量不要用百度查单词！！！！！ 2024/08/08补充：这部分是为不愿意折腾的同学写的。愿意折腾的话，不妨了解一下欧路词典，我现在就在用，可以解决有道词典查词不能由衍生词查原词等一些小问题 查词组 众所周知，无论是用词典，还是在网上查，直接按词组整体查，一般是查不到的。哪怕查到，能查的解释也不详细，有的时候甚至是错的。 这里查词组的办法，主要是针对词典的情况。为方便理解，我们认为词组都有一个“中心词”。一般情况，在这一中心词的字典释义下有一词组版块，在那里我们就能查到要查的词组。 那么，如何确定“中心词”呢？“中心词”一般是动词或名词，只有在极少数情况是介词，代词基本不会出现。比如，for instance的中心词就是名词instance，而不是for；stumble upon（意外遇见）的中心词就是动词stumble。 在要查的词组有多个中心词，比如同时有动词和名词的时候，可以大致猜一猜意思集中在动作还是在名词上。如果意思集中在名词上，那就可以把名词当中心词，然后去查。可以与其他很多次组成词组的，一般也不会是中心词。比如：take place里面，take可搭配的词实在太多了；只有在place的注释里才查得到take place的释义。 在实在拿不准的情况下，那就逐个词地查吧，总有一个词能找到这个词组的意思。如果还是查不到，那基本就证明：这不是什么有特殊意义的词组，直接逐词理解就可以了（） 查词要讲基本法 这又是什么意思？ 看了上面用有道词典查词的办法，也许你会奇怪，为什么有些词明明拼对了，也不会显示出牛津等其他词典的释义界面？假如你手机上正好有有道词典，你可以试着搜一下sustainability，正好就会发生这种情况。 这是因为，sustainability是sustainable的派生词。如果你这个时候去查sustainable，你会在其释义里发现，sustainability是被归在sustainable的派生词一栏的。 在用词典查词的时候，派生词（比如：加-ly变出来的副词，加后缀变出来的名词）一般是查不到的。这个时候，我们就要查他变之前的原词。在原词的注解下面，往往才会出现我们要查的派生词。 用纸质词典会简单一点：因为，原词和派生词往往长得很像，且派生词一般只在原词的基础上加后缀；在你按字母顺序翻词典的时候，你往往能在派生词理论所在位置的附近找到原词，并在原词的派生词栏目下，找到要查的派生词。 但用有道字典查的话，就没有上下文可参考了。这个时候，就只能猜他是怎么变化的了。这就需要记住一些常见的变法（比如，加什么后缀），有点难度。 背词的办法对单词本身 这个最好说！先讲这个。 不知道你现在怎么记单词的拼写？是逐个字母记吗？虽说从追求准确性的目的出发，这个办法没什么问题；但是，如果要大量背词的话，私以为这样效率有一点低。 现有一我自认为效率高一点的办法，就是按发音来记。 读前注意！这个办法只能记住拼写的“大概”；用这种方法记了之后，强烈建议不时用词典等工具，检验一下自己记对没有!! 一个单词的发音，是可以拆成几个音节的。如information就可以拆成in·for·ma·tion。按各部分的发音，可以大致推出音节的拼写，进而把整个词都拼出来。 音节怎么断？能发得出一次音的就能断，会发出两次音的证明断少了，发不出的就不能断。仍然用information举例，如果第一个部分断成”inf”，那么就会出现”in”和”f(u)”两个音；如果断出一个“rm”，这怎么都发不出音，自然也就有问题。能不能发出音，也可以作为检查拼写的一个手段。读着太奇怪，或者直接读不出来，有可能就是拼错了。（仍然建议查词典，以防特例存在） 按发音记的话，可以回避一个有关冠词选用的坑。比如“university”，按“AEIOU”的规则，看似冠词该用an，但他用的实际应该是a。为什么呢？因为他的”U”发音是”iu”，而不是unknown等其他U开头词的”ang”（抱歉，我打不出音标符号，只能这样示意一下）。据老师所说，”iu”这种叫半元音，故不能按元音规则加冠词。 e.g. a usual occurrence （一件常事） 这样背还有一个好处，就是记重读在哪会简单一点：只用记重度在哪个音节就可以了。 在拆词的基础上，有一个能解构单词并猜意思的办法。当然，在背单词的时候，也可以用这种办法把词拆成几个小部分，然后再记下来。详见下文“说文解字”栏目，虽说我解释的也不一定准确（笑） 对一个词衍生出的其他词 相信你也听说过所谓“词根法”吧？即以一个词作为词根，顺路记下它的反义词，还有动词、形容词等其他词性下的形式。 用这个办法就可以了。 由于这类变化一般不是太难，一般只对单词的前后动手（是为前缀与后缀），记住词根之后，其它衍生词只用记怎么由词根变化就行。效率还是很高的。 除此以外，词典（以牛津词典为例）一般在释义里附有“SYN”和“OPP”；前者是synonym，表示同义词；后者是opposite，表示反义词。牛津词典对有些词，还有”Word finder”和”Word family”等介绍其他有关词的栏目。查词的时候，如果碰到且感觉有用的话，就顺便记一下吧。 “说文解字”读前声明：这个办法是用来猜意思的，真要知道是什么意思，还是得查！ 英语不是拼音文字吗，这怎么解？其实，这里的“说文解字”，道理跟所谓“词根法”是相通的。 跟作为象形文字的中文一样，语言的发展，必定需要新的表述。对象形文字，这个新的表述是新的字，或新的词；而对拼音文字，新的表述就只能是词了。英语的很多词，其实都是造出来的，有一定规律可循。 除了对背单词有帮助，这个办法在做阅读题，碰到不会的词时也有用处。用这种办法，可以大致猜一猜不会的词的意思。 英语造词的现象，在医学、化学术语上的体现最为明显。比如说，医学上的低血钾，英语表述是hypo·kal·emia。hypo是低的意思，kal意为钾（potassium），即kalium，这是元素周期表内的正式写法；而emia表示在学业中的含量。*参考自一个叫Chubbyemu的医学UP主 换个简单的词？比如mistake，mis-一般表示错误的（e.g. mis·inform，在inform前面加个mis，表示误报），take就不说了，“拿错了”不就是“过失”了吗？ 最简单的一种解构办法，从一个词的前缀和后缀入手。 就用前缀（prefix）和后缀（suffix）这两个词举例吧。可以发现，他们都有”fix”这一共同的部分，只是前缀不同。”fix”作动词有固定的意思，前缀的“pre”是常见表示“在……之前”的前缀；这么一来，词义就很好理解了，不是吗？ 同时也要注意，不要什么都解构一番。能简单记住意思的，就别浪费精力了，这样反而容易影响对词义的理解。比如说，inform（告知）还要解构，就成”in”和”form”了；form是表格，这怎么理解？与其猜这么细致，还不如直接记意思来的快。 还有一类词拆不出来，那就是外来词。英语的外来词里面，来自法语和拉丁语的很多，比如restaurant来自法语，常见表省略的etc.（全写是 et cetera）来自拉丁语。 说起法语外来词：genre（（音乐等）流派）这个词怎么读？它的发音跟“g”根本不沾边，查了之后，想必你会大吃一惊，23333 当然，来自其他语种的外来词也很多，比如说koi来自日语的罗马音，是锦鲤的意思（笑） 文末附一些常见的前后缀，主要是针对一个词的不同形式变换的，欢迎参考；但是也只能是参考，不要全盘照搬！！ *这里可以来个笑话轻松一下：为什么开头我一定要强调“猜了要查”？众所周知，听写的英文是dictation；嗯，想必它对应的动词词根是dictate吧！好，是老师在弄听写，表示“做……的人”在后面加个er/or就行；那么，我这个时候，是不是可以称老师为dictator？查词典之后，你会惊奇的发现，dictator的意思是独裁者/专横霸道的人！！假设你的班主任恰好是英语老师，这个笑话的杀伤力更会成倍的上涨，蛤蛤蛤蛤 基本就分享到这里了。常见前后缀，由于实在太多太杂，就不一起放进来了。也感谢你能一直看到这里，祝你在英语这门学科上，也能取得优异的成绩！ 附：常见的前后缀全凭印象写的，不保全（因此，如果你对此感兴趣，可以尝试上网搜“形容词后缀”等关键词自行参考，别人整理的可能比我全得多），不保严谨，乃至不保真。不要尝试全部记下来，有个印象即可，刻意记会变得不幸！请务必以词典确切查到的单词为准。全是经验所得，没有经过任何正式文献的查证，**仅供参考，切勿滥用！ 后缀 这里的后缀，主要是针对词性间转换的；-ing甚至都算一种 有具体意义的（如：-meter表示“……计”，thermometer就是温度计），由于实在太多，且不一定用得上，这里就不列出了。 下面的后缀，有的时候可以多种一起用，比如civil - civilize - civilization 名词· -tion / -sion多出现于动词的名词形式。-tion出现于大多数情况，而-sion的形式多出现于动词以s结尾时。如：object（作动词表反对） - objection, possess（拥有）- possession需要注意的是，视单词不同，在加这一后缀之前，单词往往会出现多加一个a/去e/把e变成i等变化（注意“等”字）；伴随着这一变化，单词的重读往往也会移到tion前的一个音上。其他后缀也可能出现这种情况，下文不再重复提及。有时也会出现”-cion“的情况。如：suspect - suspicion如：pose - position, define -definition, apply - application · -ment常见于动词的名词形式。如：employ - employment · -ty多出现于形容词的名词形式。如：sane（有理智的）- sanity, able - ability, real - reality, sensitive - sensitivity, electric - electricity提到able变ability，大部分以-able作结的形容词，变名词都可以直接把-able变成-ability。如：sustainable（可持续性的） - sustainability · -ness常见于形容词的名词形式。如：shy-shyness， happy - happiness · -ce常见于形容词的名词形式。一般用于-ant/-ent结尾的形容词。如：significant - significance, important - importance · -er/-or/-r多加在动词后，表示做某事的人或物在大部分情况下加-er即可。但在少数情况，尤其是加在t之后时，用的是-or，虽说t后加-er的情况也有。猜了之后，请务必对其进行查证。如：cook - cooker（注意，是厨灶！厨师对应的英文就是cook）, simulate - simulator （模拟器）staple - stapler（订书机） · -ist加在某些具有特征的词背后，表示专业人士/信仰某种主义的人对于”信仰某种主义的人“，一般可以把”-ist“粗暴地换成“-ism”，得出这一主义的英语表述如：scientist，communist - communism · -an同样指做……的人。如：librarian（图书管理员），physician（医生！！物理学家是physicist） · -ceive（动词）→ -ception（名词）如：receive - reception 需要注意的是，由动词变化所得的名词，描述的一般是动作本身，而非动作对应的具体物品。这一规律对前文类似的变化也适用。比如，reception常见的解释是”接待“这一动作，receipt（凭条）才指的是动作对应的具体物品。类似的还有conceive - conception - concept，conception偏向于”设想“这一动作，而concept则偏向于指”概念“这一实物。 · 表述某些研究领域这种情况，一般是-logy结尾。更有甚者，直接加个s完事如：aerodynamics（空气动力学），physics，psychology（心理学；psycho是疯子，那么这就是研究疯子的学问，嗯！2333） 动词· -ize / -ise 或 -ze / -se常见于其他词性单词对应的动作，意思可理解为“……化”。-ize为美式英语用法，-ise为英式英语用法。考虑到我们学的基本是美式英语，用-ize就好了如：emphasis - emphasize（强调）, real - realize, civil - civilize（开化）又如：analysis - analyze （分析） · -fy(等以y结尾的？这个我真的无法确定，仅供参考)更偏向于一个动词的特征，而非后缀。也可以理解成“……化”。如：specify（具体说明），quantify（量化） · -en一般加形容词后，表加重某种性质。如：deepen，soften，sharpen 形容词· -ble多表示“能够……的”，“值得……的”。如 remark - remarkable, value - valuable , sense - sensible · -ful可以理解成（……很多的）如：beautiful，grateful · -y多出现于非正式的口语化形容词上。如stick - sticky（粘（乎乎）的），chubby（胖乎乎的） · -ous也是可以表示”…….很多”的如：spacious（空间宽敞的） · -ish一般指含有某种贬义性质。如：foolish，selfish · -less表示少的，没有的如：homeless，selfless（无私的） · -al怎么说呢？可能表示“属于某个概念”吧。如：space - spatial（空间上的，可以跟spacious区分一下），biology - biological，physical，nation- national · -ic解释不出来，直接举例吧（悲）后续没有解释的，也是出于同样的原因（悲）如：specific，electric · -ive如：· expense - expensive, sensitive, creative, object - objective说到objective，object不是有反对的意思吗？但是，objective只能被用于表示“客观的”之义，不能表示“反对的”，可以注意一下。 · -ory / -ary如：satisfactory，complimentary（有赞美性质的），compulsory 说到complimentary，有一个一字之差的词，叫complementary（互补的）。两词发音相似的这种情况，我背的时候，一般会把其中一个音稍微处理一下，方便记忆。比如，这里的e和i，我会选择”i”的音发短一点，”e”的音发长一点。 手机拍照依靠的组件，不是叫CMOS吗？它的全称叫互补金属氧化物半导体，对应英语就是Complementary Metal Oxide Semiconductor（semi-表示“半”）。闲来无事的话，你也可以猜猜身边英语缩写的全称？ 前缀能用上前缀的地方，除了造合成词，基本就是转反义词了。 反义前缀· un-最常见的一个反义前缀。如：unknown填空题实在想不出反义词的时候，可以试试直接加-un蒙一下。能记住到底加什么当然是最好的 · in- / im-如：insignificant（不重要的），impossible但是！有一个很常见的反例，叫invaluable；它表示的不是没有价值（那是valueless），而是无法用价值衡量的，珍贵的。 · dis-如： dissatisfaction，disconnect（断开连接），discontinue（中止） · ir- 或（i+首字母）一般是首字母为r的用。如：irregular, irrational（不理智的）又如：immature，illegal · ab-我只见过abnormal一个。 · a-直接加个a甚至都行！如：asymmetric（不对称的） 表示特定意思的 · over-超过。如：overpriced（价格太高的） · under-低于。常跟上面的over-互为反义如：underestimate（低估）- overestimate（高估） · out-在…….之外的。如：outdated（过期的） · pre-在……之前。如：precaution（预防） · post-在……之后。常见于合成词。如：post-war（战后的） · sub-低于，在……之下。如：subway（地下铁嘛），sub-zero（零度以下），submarine（潜艇） · fore-提前。如：forecast（预报），foresee（预见） · re-重新，返回。如：review，renew（翻新） · inter-表示”相互……的“。如：Internet（互联网），interact · trans-跨…….的。如：transplant，transport 等等等等，不再一一枚举。实在太多了！！有兴趣欢迎自行上网查阅（晕）前缀甚至还能表示数（如：mono-表单个，tri-表三个）和单位量度（如nanometer, millimeter等）","link":"/2024/08/08/%E6%9C%AC%E4%BA%BA%E8%83%8C%E5%8D%95%E8%AF%8D%E7%9A%84%E7%B2%97%E5%8A%A3%E7%BB%8F%E9%AA%8C/"},{"title":"航砖祭祖后日谈","text":"本文将对BUAA_CO_2024进行简要回顾，并给出自己的一些主观建议，仅供参考。 预习建议主要针对实验部分进行预习。理论部分听课/考前看408资料即可。有简单/复杂两个预习方法。 简单玩法，我推荐游玩图灵完备（Turing Complete）。玩到汇编之前基本就差不多了，当然能打完是最好，2333 复杂玩法（地狱难度！！），我力推“一生一芯”项目。做到B阶段，在体系结构方面的理解就足够薄纱课程组给的实验方案了；课上测试另说（笑） 要完成“一生一芯”，请预留至少两个月时间。难度真的很高，做之前做好思想觉悟！！ 只不过，一生一芯用的指令集是RISC-V，跟课程组选用的MIPS有所不同。二者都属于RISC，不过有一些实现细节的不同，我认为影响不大。 哪怕你在大二上上完了计组，如果你对体系结构感兴趣，我还是推荐你抽时间做一做一生一芯这个项目。因为在你上完后（至少我上完后），你会发现，本校的计组在硬件实现方面的知识实在欠缺，想不到吧？ 课程概况最终目标：要求实现支持数条MIPS指令，以及异常、中断的五级流水线处理器。 要求实现的指令集十分精简，具体可看本人P7的设计文档。 课程分为理论课与实验课两部分。理论课讲述的是正常的计组课程内容。理论课部分的资料，出于课件版权问题，不在此放出。在课程正式开始时，建议咨询各路学长/学姐获取资料。 实验课即是各个Project。 P0~P1：利用Logisim构建一些简单电路 P2：利用MARS编写MIPS汇编程序 P3：使用Logisim搭建单周期MIPS处理器 P4：使用Verilog实现单周期MIPS处理器 P5：实现五级流水线，处理各类冒险（数据冒险等） P6：进一步完善P5的设计，主要是添加MDU与新指令 P7：支持异常与中断 实验部分，在线上测试平台(cscore.buaa.edu.cn)，对各位的设计进行测试。 细说实验部分包含机房上机、课下作业两环节。 对每一Project，需完成课下提交，方有上机测试资格；在完成上机测试之后，该Project才视为通过。各Project实行闯关制，唯有前一Project通过才可进行下一Project。 在本届中，闯关制在P3才正式启动；也就是说，P0-P2课下/课上未通过，也不会影响后续进度，到P3开始才影响。但考虑到实验部分成绩会算入最终成绩，我仍然建议尽力而为。 在学期的第1-3周为Pre阶段；同学在此期间在课程网站的教程部分，学习后续要用到的知识。其中有一些习题，由于判分标准始终不明，我还是建议尽力而为。 4-15周则是实验正式开始阶段。期间，你需要完成“一周一P，打下计组Project那些事”（P7例外，给了两周）。12周对8个Project（0-7），还包括P0-P2的保送，容错其实还行。 课下测试是弱测，仅对你的实现是否基本正确进行测试，在边界条件下的正确性可能不会测试。在线上测试时，除对你的新加指令进行测试外，还会对你的课下提交进行强测，覆盖更多的边界条件。 若你课下没考虑周全，看到课下提交通过就认为完事的话，那你很有可能会在课上满脸痛苦的找bug，还找不出，最后喜提再来一次… 这也是为什么，我们需要在课下造评测机，数据生成器等等，自行尽可能全面测试。 机房上机类似于考试，在本届设在每周一晚7点开始，共持续2小时，闭卷。 每次上机考三个题，三个过两个记为通过，全过记为优秀。过两题和过三题的给分区别至今无人明确，我继续建议尽力而为。同时，在时间不够的时候，切勿盲目追求三题全过。 P0-P2就是做一下Pre练习类似的题目，有一定难度； P3-P6是三个加指令题。这部分就有意思了，这里加的不是MIPS指令集中的指令，而是课程组自行编写的新指令。具体题型建议参考往届学长/学姐博客。 P7则是对课下提交进行强测，并附带一个异常有关的加指令题。只要课下写得好，P7其实更简单。 在每次上机完成后，还要简要回答一些问题。这部分就是助教挑几个问题问，大家基本都能答上，不用担心。 讨论区课程平台设有讨论区。在此鼓励各位积极水帖，积极分享交流经验。 你可以分享： 解题思路 架构搭建经验 数据生成思路/实现 评测机搭建思路/实现 其它可以提高效率的窍门：比如我自己就找到了命令行调用ISE的办法，直接抛弃臃肿的GUI🤤 杂项有关硬件实现前面有稍微提到，本课程设计在硬件实现方面有所欠缺。何出此言？ 在P6时，我们要求加入MDU，以支持乘除操作。但是，课程组给出的要求是用*、/、%行为级描述乘、除、取余操作，其硬件实现在实验教材中并未提及（在我这一届）。在理论课那边呢？这要看老师，有些老师可能会提，也有不提的，这是一点。 第二点，自2023年（我的上一届），课程设计去掉了P8 - FPGA实验。自此，实验设计中唯一跟硬件沾边的部分被砍没了。 因此，只看实验教程，你不会知道： 怎么把自己的设计搬上FPGA 时序约束文件怎么写 FPGA上怎么调用IP核，用上板载DRAM/SRAM 自己设计的时序情况如何，怎么进行时序优化 第三点，课上测试。有一些指令逻辑对应的电路设计很难实现，且需要搭建专门模块，在我看来不大符合“通用处理器”的设计初衷。有些题目，在我看来，考察的其实是面向过程编程能力和读题能力，跟体系结构没什么关系。但从考察对自己架构的熟悉程度而言，这种设计也合理。 因此，如果你实在对体系结构感兴趣，我推荐你课下自己多花时间了解，不要窘于课程设计。当然，如果你对体系结构不感兴趣，这种课程设计也确实足够了。 和理论课的脱节这个情况主要对2306。对于高工的同学（2318）是另外一个故事，我看他们的实验性实验设计挺不错的。 主要是，理论课讲了Cache，实验课没有考察实现。这个问题在高工部分的新版实验解决了，那个实验有考察Cache部分的内容，不知道这个实验2406会不会采用。 还有就是，理论课进度取决于老师。比如，P5实验开始，有的老师可能已经讲完了流水线和冒险有关知识，而有的老师还没开始，这就会导致实验进度与理论课进度的脱节。这问题没啥好解法，自己看往年课件吧。 在这两点以外，其实就没什么好吐槽的了，挺好的。","link":"/2025/02/04/%E8%88%AA%E7%A0%96%E7%A5%AD%E7%A5%96%E5%90%8E%E6%97%A5%E8%B0%88/"},{"title":"通过命令行，更优雅地利用ISE进行开发","text":"归档于250204，供后来者参考。 众所周知，在使用ISE进行开发的时候，您可能会遇到以下问题： 每次开干，都要手动创建一个新项目 创建文件的操作极为繁琐 仿真一次需要多次操作鼠标 ISE项目文件内文件繁多，文件管理堪称灾难 但在本文的方法下，以上问题均可一一化解！ 本文是教程中ISE、VCS 与自动化测试的一小点拓展。 摆脱ISE的项目文件夹在教程中，我们发现：在通过命令行使用ISE时，我们实际需要的只有.prj, .tcl, （模块名）.v这些文件； 也就是说，我们完全可以在ISE项目文件夹外新开一个文件夹，存储我们的源代码，并利用命令行调用ISE！ 观察.prj的内部结构，发现它其实是支持相对路径的： 12345678910verilog work &quot;./src/NPC.v&quot;verilog work &quot;./src/IFU.v&quot;verilog work &quot;./src/GRF.v&quot;verilog work &quot;./src/EXT.v&quot;verilog work &quot;./src/DM.v&quot;verilog work &quot;./src/CTRL.v&quot;verilog work &quot;./src/CMP.v&quot;verilog work &quot;./src/ALU.v&quot;verilog work &quot;./src/mips.v&quot;verilog work &quot;./src/mips_tb.v&quot; 注意！在ISE自动生成的.prj中，是没有将testbench包含在内的；若想使用本文中方法进行开发，请务必如上文所示，将testbench顺路包含在.prj文件内！ 于是，我们就可以把所有的.v源代码统一放进工作目录下的一个文件夹内进行管理。 在工作目录下，我们必须放好.prj, .tcl文件，以及读入IFU的机器码code.txt。 最后结构如下所示。 这样就实现了项目目录的有效管理，开新模块的时候也不会有烦人的对话框了。 这也为我们纯使用VSCode+插件等外部编辑器方案提供了极大的便利。 241103更新：自动生成.prj自己手动敲prj还是难受，还是自动生成吧！ 要做到这点也很简单，利用cmd的dir指令和for指令，在进行编译前生成一下mips.prj即可： 1for /f %%i in ('dir /b src') do echo verilog work &quot;./src/%%i&quot; &gt;&gt; mips.prj 实验证明，包含include的宏定义文件包含进去不会出问题，使用了这一写法的各位大可不用顾虑。 但需要注意的是，请确保执行之前，目录之内没有已存在的mips.prj文件。 小事：利用设置好的环境变量 此处主要针对Windows用户，相信用Linux看这部分的仙人都知道在Linux上怎么做 在教程内，我们已经知道了自动化运行的指令了；但是，前面跟一大串目录，不觉得很烦人吗？ 恰巧，教程里已经提示过你，要将ISE的安装目录加入环境变量了。我们在这部分不妨再说说，怎么利用设置好的环境变量，简化掉指令前面那一大串难看的安装目录。 在正式开始前，我们不妨先Win+R一下，输入%windir%，发现他会自动跳转到你的Windows系统目录内。这说明，Windows（至少cmd）是支持由环境变量名进行目录跳转的！ 要做的事情也很简单了；添加一个值为（ISE安装目录，如C:\\Xilinx\\14.7\\ISE_DS\\ISE），名为xilinx的环境变量（系统还是用户环境变量均可，实验下来这里都可以）。 然后，我们就可以把命令改写为%xilinx%\\bin\\nt64\\fuse.exe -nodebug -prj mips.prj -o mips.exe mips_tb，更加美观。 使用命令行生成波形教程这部分有所欠缺，实际上是可以通过命令行看波形的。 小事：有关.tcl正式开始之前，我们先多说一点.tcl相关的事。 教程内提到的.tcl，其实就是给ISE的ISim用的一个脚本;编译出来的mips.exe其实就是ISim的一个实例。 我们不加入任何参数执行mips.exe，会进入iSim的命令行模式： .tcl里写入的指令，其实就是在这个命令行程序下执行的！ 此时我们自然一头雾水，遂输入help查看帮助：![image.png](./assets/Screenshot 2024-10-30 231837.png) 猛然发现，有一条wave指令，可能跟我们生成波形的需求有关！ 查询后得知，wave log指令最有帮助，帮助文档说明如下： 回顾我们编译时执行的指令：%xilinx%\\bin\\nt64\\fuse.exe -nodebug -prj mips.prj -o mips.exe mips_tb，此时我们实际上是把mips_tb当作了顶层模块。 值得注意的是，此时的object_name是对于模块内（即此时的mips_tb）的实例的。 众所周知，ISE自动生成的testbench，待测模块实例默认为uut，故我们将其作为object_name传入，同时带上-r参数递归包含所有子模块，我们就可以在波形文件中得到所有子模块的端口，wire等信号的波形。 最后，经修改后的.tcl如下： 123wave log -r uut run 200us;exit 在执行了mips.exe -nolog -tclbatch mips.tcl后，我们会发现工作目录里多了一个isim.wdb文件，这就是我们仿真所得到的波形。 查看波形一番搜索后，使用这一命令即可查看生成的波形： 1%xilinx%\\bin\\nt64\\isimgui.exe -view isim.wdb 通过上述操作，我们的确得到了满意的效果： 此时，你大可将当前视图内的信号全选，全部删除，然后再在UI左侧的Instances and Processes与Objects里，选择自己感兴趣的信号加入视图。此时删掉再加信号，并不需要重新仿真才能得到波形，即加即有！！ 你问为什么GUI里不是即加即有？因为我们执行的wave log -r uut 实际上记录了所有的信号，而在GUI里，若你不将要观察的特定信号加入视图，iSim是不会记录这个信号的波形的。 事实上，不加wave log -r uut也会生成波形文件，不过里面没有记录任何波形 编写一键仿真脚本 小白向，各路仙人可以直接跳过 要做的事情很简单，写个批处理文件就行了。 123%xilinx%\\bin\\nt64\\fuse.exe -nodebug -prj mips.prj -o mips.exe mips_tbmips.exe -nolog -tclbatch mips.tcl%xilinx%\\bin\\nt64\\isimgui.exe -view isim.wdb 将我们要执行的这三条指令写入一个.bat文件，双击即可执行，一键完成编译-仿真-查看波形三个步骤。 对于$display输出的文本，此时将在弹出的命令行窗口内显示。 241103更新：更完善的自动化脚本run.bat！！请注意，此处除clear.bat外的实现可能存在问题，请看下文241130的更新版本！！ 241110：针对P5以后的输出格式，进行了输出过滤正则表达式的完善，再次感谢姜宇墨同学的提醒 主要进行了以下完善： 考虑到波形查看并不必要，故run.bat默认不打开波形视图，另给出一打开波形试图的run_waveform.bat 自动生成mips.prj 添加了编译错误的判断（感谢罗浩宇同学的帖子给出的脚本编写思路） 在运行后自动进行缓存文件的清理。为此，引入了另一脚本clear.bat 对输出进行了简单的过滤 在命令行内直接查看输出 run.bat: 1234567891011121314@echo offfor /f %%i in ('dir /b src') do echo verilog work &quot;./src/%%i&quot; &gt;&gt; mips.prj %xilinx%\\bin\\nt64\\fuse.exe -nodebug -prj mips.prj -o mips.exe mips_tb &gt;nulIF ERRORLEVEL 1 ( echo An error occurred when compiling. pause .\\clear.bat exit)mips.exe -nolog -tclbatch mips.tcl &gt; isim_out.tempfindstr &quot;@&quot; isim_out.temp &gt; isim_out.txttype isim_out.txtpause.\\clear.bat run_waveform.bat: 123456789101112131415@echo offfor /f %%i in ('dir /b src') do echo verilog work &quot;./src/%%i&quot; &gt;&gt; mips.prj %xilinx%\\bin\\nt64\\fuse.exe -nodebug -prj mips.prj -o mips.exe mips_tb &gt;nulIF ERRORLEVEL 1 ( echo An error occurred when compiling. pause .\\clear.bat exit)mips.exe -nolog -tclbatch mips.tcl &gt; isim_out.tempfindstr &quot;@&quot; isim_out.temp &gt; isim_out.txttype isim_out.txtpause%xilinx%\\bin\\nt64\\isimgui.exe -view isim.wdb.\\clear.bat clear.bat 123@echo offrmdir isim /s /qdel mips.exe fuseRelaunch.cmd fuse.* isim.wdb isim_out.temp mips.prj 注意，在run.bat意外中断时，若缓存文件未成功清理，请手动点击clear.bat进行清理，以免后续再次仿真时出现问题。 241105更新：上机实践经验在上机过程中，孩子对这一方法进行了实验，确定了上机时这一方案的可用性。不过，注意到有同学反馈上机时使用存在问题。一番总结发现，在使用的时候，需要注意以下几点： 目录中不能出现中文字符或特殊符号，cmd对其支持可谓极差，出现了会导致找不到当前目录下生成的mips.exe的问题 上机的时候，请先提前手动配置好环境变量。ISE的安装目录，可通过对桌面快捷方式右键-打开文件所在的位置找到。 需要注意的是，快捷方式指向的目录并不是我们最终要找的ISE安装目录。我们要找的安装目录，是快捷方式指向的文件夹内，那个叫ISE的文件夹。 上机环境的环境变量，请使用桌面“此电脑”快捷方式-右键菜单，属性-“设置”页中的“高级系统设置”选项-“高级”选项卡中的“环境变量...”进行编辑。 运行目录请务必放在D盘，切勿放在C盘。 因为上机环境的C盘有读写权限限制，在C盘运行脚本会导致mips.exe无法生成，导致运行失败； 运行时可能会弹出烦人的SmartScreen弹窗。由于这部分我手上没有Win10环境进行测试，这里可能需要各位自行搜索关闭SmartScreen的方法 // 上机环境下，由于权限设置，SmartScreen无法关闭。要规避这个问题，建议在打包脚本的时候，先以.txt的格式保存脚本内容，再在上机时，将.txt中脚本，粘贴到用机房电脑创建的.bat文件里。你问怎么写？新建.txt，粘贴内容，改扩展名就行了 241110更新 感谢姜宇墨同学的提醒… 在P5开始，输出格式发生了变化，每一行以当前运行的时间数为开头，本文先前使用的正则表达式匹配方法存在问题，现已修正。 241118:两次上机实验发现的问题这部分我实在没有头绪，希望各位能给出一些完善的思路。 在本人两次于三号机房肝P5时，我没有一次成功查看波形，但是输出正常。查看未过滤的mips.exe输出，发现在执行波形输出时，出现了FATAL ERROR； 但此前在4号实验室时考P4时，波形输出并没有问题。 初步怀疑是cmd并行执行指令引起的问题；如各位有解决这一问题的办法，欢迎私发本人/在评论区提出，万分感谢！ 241130：上机遇到问题的临时解法.bat导致SmartScreen拦截在上交文件前，把拓展名.bat改成.txt；此后，要么直接把拓展名改回来，要么将.txt中内容，复制到另一份用机房电脑创建的.bat文件中。我个人倾向后者，因为理论而言后者能最稳妥地绕开SmartScreen。 并发执行，导致波形无法查看利用call使得各指令顺序执行，尝试避免并行执行引起的问题。注意，这一改法尚未上机实验，请不要把其作为上机时使用的唯一方法；也欢迎各位上机后反馈使用效果！ run.bat: 1234567891011121314@echo offfor /f %%i in ('dir /b src') do echo verilog work &quot;./src/%%i&quot; &gt;&gt; mips.prj call %xilinx%\\bin\\nt64\\fuse.exe -nodebug -prj mips.prj -o mips.exe mips_tb &gt;nulIF ERRORLEVEL 1 ( echo An error occurred when compiling. pause .\\clear.bat exit)call mips.exe -nolog -tclbatch mips.tcl &gt; isim_out.tempcall findstr &quot;@&quot; isim_out.temp &gt; isim_out.txtcall type isim_out.txtcall pausecall .\\clear.bat run_waveform.bat: 123456789101112131415@echo offfor /f %%i in ('dir /b src') do echo verilog work &quot;./src/%%i&quot; &gt;&gt; mips.prj call %xilinx%\\bin\\nt64\\fuse.exe -nodebug -prj mips.prj -o mips.exe mips_tb &gt;nulIF ERRORLEVEL 1 ( echo An error occurred when compiling. pause .\\clear.bat exit)call mips.exe -nolog -tclbatch mips.tcl &gt; isim_out.tempcall findstr &quot;@&quot; isim_out.temp &gt; isim_out.txtcall type isim_out.txtcall pausecall %xilinx%\\bin\\nt64\\isimgui.exe -view isim.wdbcall .\\clear.bat clear.bat不用修改，按上面的实现就可以了。 241209：确认问题解决在两次试验241130中的修改后，波形已确保可以稳定生成。本方法自此可确认可靠。 在上机使用时，仍需注意SmartScreen引起的问题，解法见上文。 TL;DR：上机怎么用？这里针对直接使用Windows环境，Linux仙人可能需要自己钻研一下（当然用Linux的一般也不用看这个教程吧，笑）… 课下准备把脚本改成.txt后缀，再塞进自己的提交里 课上：配置名为xilinx的环境变量 为适应不同ISE安装目录而开发。若觉得配置环境变量太麻烦，建议直接把脚本里的%xilinx%直接换成ISE的安装目录，因为ISE的默认安装目录应该都是一样的。 此电脑-属性-高级系统设置-环境变量-（新建用户环境变量） 其中，ISE的目录在上机时应该也是C:\\Xilinx\\14.7\\ISE_DS\\ISE； 最保险的方法是，对着ISE的桌面快捷方式右键-打开文件位置-打开弹出的&quot;ISE_DS&quot;文件夹内的&quot;ISE&quot;文件夹-复制路径 。 注意！ISE快捷方式直接打开的文件夹不是我们要的目标！！要多点进一个文件夹，不要忘了！ 课上：用机房电脑创建脚本机房电脑由于权限设置，不可能关掉SmartScreen。 为了绕开这个当前场景无用的安全检查，我们只能这么绕一下。 这里主要针对要双击运行的run.bat。clear.bat由于在run.bat内间接调用，这个安全机制无效，可以不用处理。 用机房电脑，创建跟你的脚本同名的.bat（创.txt再改后缀，这里不赘述了）。 等到开始考试时，把你的脚本.txt内容拷贝进刚刚创建的.bat。 把准备好的.bat放进你的源码文件夹（结构见上文），即可绕开SmartScreen，双击即可直接运行。 本文就到此结束了，速速实践，摆脱ISE臃肿的GUI吧！🤤","link":"/2025/02/04/%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%8C%E6%9B%B4%E4%BC%98%E9%9B%85%E5%9C%B0%E5%88%A9%E7%94%A8ISE%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"title":"第一次尝试","text":"万事开头难。 有关建设个人博客这件事，本人其实早在2022年5月，就已按各路教程，用Hexo和Github Pages搭好了环境。苦于当时的学业压力，加上后续也没有任何写随笔的时间和欲望，这一项目就此搁浅，主页上也只留着默认的“hello world”。 转眼，过了一年半，这个想法又被提上了日程。主要的推动力，我想是高宁老师在几周前《大国领袖》课程上的点醒。的确，写作使人深刻。思想在矛盾中产生进步，而若不以文字记录下所思所想，任何进步所获，都将被时间冲淡，最后终将导致自己寸步未进。听得此话，如醍醐灌顶。也许，真的是时候认真记录一下自己的所思所想了。 初入大学数月，感受颇丰——无论是学业上，还是这几个月来自己学余的所见所闻。这几个月，有看完MyGo!!!!!、补完少歌之后的感动，有学业繁重、认识到自己与各路大神差距的压力，有对自己选择信息类，而非三年前自己所热爱的航空学的怀疑，更有初中以后，自己的精神支柱长期空缺的反思。上述种种，我想，绝非只是自己心里想想，然后任其随时间逝去就能过去的。用文字记录下自己的感受，并在写作中反思，我想才是正解。 当然，自己搭建Blog，也绝非易事。在您观看这篇文章时，本人可能还在潜心研究NexT主题的各类复杂设置，这个博客也大概率还只是一个刚搭好的毛胚房。这也算是我第一次真正使用Github开发自己的项目，要学习的东西自然也是很多。 写到这里，已然词穷。本人Blog的第一篇文章，就到此草草作结吧。 但愿写完这篇文章之后，我还能记得继续写吧（笑","link":"/2023/11/27/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95/"},{"title":"“法律、科技与社会”课后思考题答案 - 2024","text":"本文记录了本人复习“法律、科技与社会”课程时，对课后思考题给出的答案。 众所周知，本课的期末考试就是从课后思考题中抽集体来考，怎么复习想必大家都知道了。当然，不知道这几个思考题之后会不会变。 以下答案均为本人手搓，在考试获得了95分，当然这个给分可能有玄学成分在里面，仅供参考。 技术是中立的吗？为什么？ 不是。 技术置身于社会中，具有社会性。 技术是占有世界的媒介，同时也是人类活动的一种形式。其背后包含了人类思维结果。 监控资本主义是一个不可避免的趋势吗？还是我们有什么办法改变它？ 用户行为数据将为资本带来利益；从资本逐利的本质而言，监控资本主义的趋势不可避免。 这一趋势可以被抑制。 立法与管制 提高公共意识与参与度 探索技术向善路径，减少技术对个人隐私的侵害 学校是否有权使用人脸识别对学生进行考勤？为什么？ 自隐私方面：若学校方面明确了：1.收集的人脸识别信息仅用于考勤，2.且收集的信息将按照相关法律法规进行处理，3.并在事前提前征得了同学的同意，则这一方案可认为可行； 然而，根据我国目前出台的相关法律法规，此时也需保证人脸识别不作为考勤的唯一方式。 更严格而言，根据《个人信息保护法》，在公众场合所收集的身份信息只能用于维护公共安全目的，此时考勤并不在维护公共安全范围之内，故可以认为学校无权这么做。 什么是自动驾驶的电车难题？自动驾驶系统应该如何应对电车难题？ 自动驾驶系统在事故不可避免时，是优先保全车上人员安全，还是行人等车外人员的安全。 首先是在技术上，要尽可能减少“不可避免事故”的发生； 其次，在设计自动驾驶系统时，应注意伦理方面的考量，确保系统决策符合人类伦理。 是否应该禁止或限制性爱机器人的研发、生产与销售？为什么？ 是 存在物化女性的风险 有悖伦理 存在因此引起的技术以来与奴隶问题。 情感与亲密关系的简化。 什么是致命性自主武器？是否应该禁止或限制致命性自主武器的研发和使用？为什么？ 指无需有意义的人类控制即可选择目标并施加武力的系统。 应该。 道义角度：其决策远离了人的判断，在道义上这无法接受。 法律角度：其违背了《国际人权法案》和《武装冲突法》的精神，可能会对非作战人员产生杀伤。 战略角度：研发出的致命自主武器可能会扩散到潜在敌人中。 什么是算法歧视？形成的原因是什么？如果解决算法歧视问题？ 算法歧视是指算法在决策过程中，偏向特定人群或不公平对待某些群体的现象。 形成原因： 数据偏差：算法主要依赖于测试数据；数据不全面，则算法可能会因此产生偏见。 设计偏见：开发者在设计算法时融入了个人偏见。 反馈循环：在一些算法系统中，用户行为会反馈到算法中，这可能扩大原有的偏见 改进方法： 改进数据质量 提高算法透明度与解释性 引入公平性评估和偏差测试 用户反馈与持续优化 在人工智能和大数据时代，个人隐私还存在吗？如何才能更好地保护隐私？ 存在。 个人角度：提高个人隐私意识，以正当手段维护自己的个人隐私 立法角度：完善相关法律法规，自法律角度约束个人敏感信息的使用 数据收集者角度：尊重用户隐私，避免过度收集用户敏感信息；完善技术手段，减少敏感信息的使用，避免敏感信息的泄露 作为计算机专业的学生，你如何看待人工智能的未来？ 自生产工具的角度而言，人工智能将促进人类社会的生产力发展，从而促进人类社会的进步，我们应继续追求人工智能在技术层面的进步，从而进一步发展社会生产力；同时，我们也应积极接受并利用AI这一生产力工具。 自道德伦理角度而言，人工智能的使用，可能出现潜在的道德伦理问题，当前也出现了深度伪造、AI合成假新闻等问题。这需要我们在技术层面加以防范，； 自社会角度而言，人工智能必然会因人工智能的出现，对已有的部分人工进行替代。同时，人工智能的出现，也为我们带来了新的就业机会。因此，我们需要积极顺应这一变化，积极学习AI相关知识，同时提高自身创新能力与软实力。","link":"/2025/02/04/%E2%80%9C%E6%B3%95%E5%BE%8B%E3%80%81%E7%A7%91%E6%8A%80%E4%B8%8E%E7%A4%BE%E4%BC%9A%E2%80%9D%E8%AF%BE%E5%90%8E%E6%80%9D%E8%80%83%E9%A2%98%E7%AD%94%E6%A1%88%20-%202024/"}],"tags":[{"name":"面向对象","slug":"面向对象","link":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"梦拓","slug":"梦拓","link":"/tags/%E6%A2%A6%E6%8B%93/"},{"name":"心得","slug":"心得","link":"/tags/%E5%BF%83%E5%BE%97/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"计组","slug":"计组","link":"/tags/%E8%AE%A1%E7%BB%84/"},{"name":"英语","slug":"英语","link":"/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"水课","slug":"水课","link":"/tags/%E6%B0%B4%E8%AF%BE/"},{"name":"FKS","slug":"FKS","link":"/tags/FKS/"}],"categories":[{"name":"课程相关","slug":"课程相关","link":"/categories/%E8%AF%BE%E7%A8%8B%E7%9B%B8%E5%85%B3/"},{"name":"梦拓相关","slug":"梦拓相关","link":"/categories/%E6%A2%A6%E6%8B%93%E7%9B%B8%E5%85%B3/"},{"name":"建站历程","slug":"建站历程","link":"/categories/%E5%BB%BA%E7%AB%99%E5%8E%86%E7%A8%8B/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"}],"pages":[{"title":"","text":"google-site-verification: google5fd05e1f229f752d.html","link":"/google5fd05e1f229f752d.html"},{"title":"归档","text":"","link":"/archives/index.html"},{"title":"","text":"This is your new vault. Make a note of something, [[create a link]], or try the Importer! When you’re ready, delete this note and make the vault your own.","link":"/blog_source/Welcome.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"关于苯人","text":"最后更新于 2024-08-14 思来想去，还是写一篇文，简要介绍一下自己的复杂成分吧😋 主要是为了尽可能想全，把自己老早以前玩过/看过的都全翻出来了，供各位一笑233333 电动孩子基本不碰手游，是忠实的PC玩家。以前在手机上倒是会玩玩Lovelive : SIF/AS，但它卒了；以前也尝试过Arcaea，邦多利之类的音游，但是发现自己的手已经残了，打Easy都不能FC，索性放弃（） 孩子其实现在打游戏打的真不多（尤其是竞技类的），但是要拉我起来玩的话，我当然是支持的😋 本人Steam好友码为173366823，欢迎各位加了自行查询成分（） 彩6（Y1S4入坑的超级老登，退了一段时间了） CS（打了N年，最高只到官匹黄金2，5e 1500分） 绝地潜兵2 战地1/5（1！5！） 地平线5 女神异闻录系列（目前只通了P3R，P4G和P5R在慢慢玩） 红烧天堂（唉河豚） 少歌：遥远的黄金乡（哇嘎里玛斯） 欧卡2/美卡 都市天际线1/2 钢铁雄心4（原版/TNO/千禧黎明/KR） 叛乱：沙暴 严阵以待 塔科夫（下来基本没碰过，说来惭愧） NEEDY GIRL OVERDOSE 大表哥2/GTA5 PUBG端游（退了好多年了） L4D2（好多年前就通关了） Unturned （小学玩得多，现在拉我回来也可） 胡闹厨房（有团建需求可以拉着玩这个，23333） GMOD（好多年没碰了，上次碰在六年级） 各类单机游戏，过于复杂，就不说了 模飞：P3D/MSFS/X-Plane，我相信这个一般捞不到人，但如果真有的话，欢迎交流！拉我连飞也行，不过我没有连飞经验23333 番/漫比起16年-18年各类番剧百花齐放的时候，孩子现在追番的频率真不算高。 以前是只看番，现在开始慢慢尝试看漫 现在孩子是个（万恶的）白河豚，爱看各类百合作品（蒜这类工业糖精还是不在兴趣范围内的），番和漫都有🤤 简要列个表吧，看到有自己感兴趣的欢迎自爆： 最近在看： Girls Band Cry mygo和快出的ave mujica（一年怎么这么久？😭） 小市民 恋语轻唱（漫，动画实在难绷） 安达与岛村（主要是追漫，动画也不错） 看过： 少女歌剧（哇卡里玛斯，不过现在主要是看同人作品） 新海诚，问就是奔着画风去的，里面喜欢秒速五厘米，你名，还有一个比较冷门的 邦多利（看得不全） Lovelive：本篇、水团、虹团看得多，星团看得少，剩下的基本没看 京阿尼各作品：京吹（花田老贼你罪该万死！），k-on等 芳文社：最近都不咋看了，自己看的有代表性的有学园孤岛，点兔等（都是好久以前的事了） 抽象的：serial experiment lain，漂流少年 女神异闻录系列的动画化作品，玩P系列玩的 Key社经典作品：CLANNAD，Angel Beats! 其它一些经典作品： 魔法禁书目录及其衍生的炮姐（）、四谎、未闻花名、16年流行的干物妹小埋，龙女仆等等，Angels of Death（看到梦拓组里一位组员的名字和头像，好眼熟啊，2333333） 剧感兴趣的主要是英、美剧。 这个也是最近才开始的，看得也不算多。最近在看绝命毒师。 有打算看的： 汉弗莱、是，大臣、卷福、风骚律师、高堡奇人、纸牌屋 歌听得很杂。可以大概分为以下几类： 交响乐：听肖斯塔科维奇居多（说起来，曲库里基本都是俄国作曲家，草） 日语歌曲：YOASOBI,夜鹿，鱼韵；加上邦多利、拉拉、少歌等动漫的衍生歌曲（ 后朋克：列托夫，维克多崔 各类曲目的钢琴改编 其它业余爱好现在上面两个都不算大头，孩子大量时间主要花在这🤤 但是也算是非常冷门的爱好，大家看看就好（ 航空相关爱好囊括模拟飞行、拍机和模型。 模拟飞行是初二入的坑，当时主要在玩P3D，常飞机模主要是PMDG那几个，FSL320偶尔会玩；现在在试着过渡到MSFS 拍机的话，这个是进大学才有的机会；主要就在北京拍了；去香港的时候一般也会去飞机维修区拍拍🤤 技术尚不娴熟，J网目前只过了一张，欢迎点击查看本人屑图：https://www.jetphotos.com/photographer/291623 日后或许也会考虑在这发点拍机的图？ 随便甩点图： 模型的话，看图吧（ 下面那盒IL86本来说高考假弄的，鸽了不知道多久了，况且我也不算是胶佬（ 公交相关远在小学的时候接触过OMSI，受香港那边的巴士文化影响有点大 目前就是到处拍车🤤 若您感兴趣，欢迎点击查看本人拍摄的更多照片：https://buspedia.top/user/5py8lp 摄影虽说本人的摄影主体绝大多数情况下都是各类巴士和飞机，但正经摄影孩子还是会一点的 这就拍得很杂了，基本就是随心拍摄，风景、人文、打鸟等等都有 只不过拍人很少干，除了活动就没拍过了。如果看到这的hxd能够帮我凑齐人像三要素，我自是万分感激🤤 文昌阁，贵阳，2023年冬 “开往春天的列车”，居庸关，2024年春 沙河校区的喜鹊 沙河校区的麻雀 孩子为数不多拍过的人像，也是孩子为数不多满意的照片；摄于军训文艺展演 折腾电子产品算是个垃圾佬，自己曾经在中考完的时候攒了台9400f+2060的台式机；当然这台现在就放在家了 目前还没有折腾过ITX和分体水这些，以后有时间，关键是有钱之后再说吧😵‍💫 笔记本不敢折腾太多，问就是手残，经常把排线拆废；这方面唯一的折腾经验是把手里的蓝天x370换了个风扇和硅脂 手机也有一点折腾的经验；唯一一次尝试是把一台Softbank版的索尼XZ3 root+刷进Lineage；各类神奇模块还没怎么捣鼓过 顺带一提，要是Windows Phone还在的话，孩子换机肯定首选Lumia，微软你罪该万死… 本人成分大概就这样了🤤","link":"/about/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"友情链接","text":"Jiyuan Zhao https://lucky-sheltered-boy.github.io// 大骥骥的博客🤚😭🤚 Old joy https://www.oldjoy.top/ 好哥们的博客👆🤓 大仓鼠的博客 https://buaa.spotterblog.cn/ 向巨🤚😭🤚","link":"/links/index.html"},{"title":"图床测试","text":"通过阿里云OSS+PicGo的方案，本博客成功实现了图床功能。 Github在国内访问速度太慢，为了实现图片快速加载，只能加点钱上阿里云了 :( 不过一个月也就6块钱，也就约等于一个月少喝一瓶东方树叶嘛😋","link":"/butai_shoujo_kokoroe/index.html"}]}