<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>OO_U2 - HW5,6阶段性总结</title>
    <url>/2025/04/17/OO_U2%20-%20HW5,6%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>我的调度算法，与我的架构实现耦合度较高，因此我不得不先提一些我自己的电梯实现；不需要的同学，欢迎直接跳开“电梯实现”部分。</p>
</blockquote>
<p>这算是本人两周以来的一个总结吧，终于有时间写了…</p>
<span id="more"></span>

<h1 id="浅提电梯实现"><a href="#浅提电梯实现" class="headerlink" title="浅提电梯实现"></a>浅提电梯实现</h1><p>读前注意，本人的设计并非最佳，其中有不少会引起复杂度增加的设计，请各位参考时务必谨慎。</p>
<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>在完成HW6后，本人的整体架构如下：<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020250406221034.png" alt="Pasted image 20250406221034.png"></p>
<p>其中，电梯信息与电梯运行进程分离，便于维护。</p>
<p>我的电梯，将运行状态分为以下几类：</p>
<ul>
<li>IDLE：闲置，此处与常理理解中的闲置是一致的，不多赘述</li>
<li><strong>RESERVED</strong>：<strong>预约</strong>，<strong>在闲置状态的电梯</strong>，收到<strong>起点与电梯当前所在位置不同楼的请求</strong>时，进入的<strong>移动状态</strong>。</li>
<li>RUNNING：运行，电梯处在<strong>非预约状态</strong>时的正常移动状态。</li>
<li>WAITING：等待，电梯停靠，进行上下客时进入的状态。停靠完成后，<strong>视情况</strong>转入RUNNING&#x2F;RESERVED&#x2F;IDLE状态。</li>
</ul>
<p>同时，我们还需要记录电梯的<strong>运行方向</strong>，现规定：</p>
<ul>
<li>1：上行</li>
<li>-1：下行</li>
<li>0：仅在进入IDLE时设为此值。</li>
<li>在电梯进入WAITING时，<strong>方向将被设置为下一步要移动的方向</strong></li>
</ul>
<p>电梯内亦有一子请求表，记录满足以下条件的请求：</p>
<ul>
<li><strong>请求与电梯运行方向一致</strong></li>
<li>记录当前方向的所有请求；比如，我们的电梯正在处理一个<code>F1-F3</code>的请求，现在处于<code>F2</code>；此时，若有一<code>F4-F5</code>的请求，则该请求可被指派给电梯，加入子请求表</li>
</ul>
<h2 id="存储状态的额外信息"><a href="#存储状态的额外信息" class="headerlink" title="存储状态的额外信息"></a>存储状态的额外信息</h2><p>上面提到，我们的子请求表只允许同向请求加入；在我们现在的实现下，这种情况当然会产生：</p>
<ul>
<li>电梯在<code>F3</code>，IDLE</li>
<li>出现了一个<code>F1-F7</code>的请求，电梯进入RESERVED，空放到<code>F1</code></li>
<li>电梯从<code>F3</code>空放去<code>F1</code>途中出现一个<code>F2-F1</code>的请求，我们自然希望捎带它，将其加入子请求表</li>
</ul>
<p>也就是说，<strong>空放方向与发出预约的请求的方向反向。</strong> 我们自然需要一个地方暂存这个预约请求；我选择通过<strong>继承</strong>的方法，<strong>将其存在状态内</strong>。</p>
<p>具体而言：</p>
<ul>
<li>上面四个状态均属于一个<code>Status</code>类，内有一<code>enum Type</code>属性，记录当前状态类型</li>
<li>若一个状态需要记录额外信息，则该状态作为<code>Status</code>的子类，<strong>额外信息作为子类的属性</strong>，存在子类中。</li>
</ul>
<p>我们此时只需对RESERVED，WAITING两个状态记录额外信息。</p>
<p>RESERVED：</p>
<ul>
<li><code>allowPickUp</code>：中途是否允许捎带</li>
<li><code>requester</code>：进行预约的请求。允许为null。</li>
</ul>
<p>WAITING：</p>
<ul>
<li><code>prevStatus</code>：进入WAITING前的状态。</li>
</ul>
<p>欲知为何如此，请继续看下文。</p>
<h2 id="兼容SCHE请求"><a href="#兼容SCHE请求" class="headerlink" title="兼容SCHE请求"></a>兼容<code>SCHE</code>请求</h2><p>不知各位是否发现，在HW6引入的临时调度，跟我们上面提到的RESERVED略有相似之处？</p>
<p>我们要让我们的现有设计兼容<code>SCHE</code>请求，只需做这么几件事情：</p>
<ul>
<li><code>SCHE-BEGIN</code>前，把途中无法捎带的请求赶回请求池；</li>
<li>在临时调度至不同层时，<code>SCHE-BEGIN</code>对应转入一个 <strong><code>requester = null</code>，不允许捎带</strong>的RESERVED状态</li>
<li>确保已有的RESERVED状态下的电梯运行规则，能够处理上述的<code>RESERVED</code>情况</li>
</ul>
<p>就这样，我们就做完了<code>SCHE</code>请求的电梯运行部分；剩下的，只需要实现指派电梯进<code>RESERVED</code>的逻辑，很省事吧！？</p>
<h2 id="等待状态的转移规则"><a href="#等待状态的转移规则" class="headerlink" title="等待状态的转移规则"></a>等待状态的转移规则</h2><p>WAITING的状态转移规则如下：</p>
<ul>
<li>先前为<code>RUNNING</code>：<br>若仍有请求未到终点，则恢复RUNNING<br>若请求已全部满足，则进入IDLE</li>
<li>先前为<code>RESERVED</code>：<br>若未到预约者起点，则恢复RESERVED<br>若到达了预约者起点，则进入RUNNING，同时<strong>将暂存的请求加入子请求表</strong></li>
<li>先前为<code>IDLE</code>：<br>直接进入<code>RUNNING</code>，<br>因为我们保证，IDLE下的电梯被预约后，直接进入RESERVED状态，<br>此时必是因为，有一起点与IDLE状态下电梯所在位置的请求被分给了电梯。</li>
</ul>
<h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><p>交互方面，我采用的是一<code>Dispatcher</code>对多个<code>Elevator</code>的实现，与绝大多数做法一致。</p>
<p>大家都知道影子电梯，不过它需要<strong>模拟电梯的整个运行过程</strong>，实现略显复杂；那么，有没有一个在复杂度和影子电梯的高效率之间折中的方案呢？</p>
<p>是有的。我的这个策略在思路上与影子电梯有颇多相似之处，只不过：</p>
<ul>
<li>只需要计算（模拟）<strong>当前请求</strong>的运行时间</li>
<li>已指派给电梯的其它请求的估计，<strong>利用优先级机制实现</strong></li>
</ul>
<h2 id="是否允许加入"><a href="#是否允许加入" class="headerlink" title="是否允许加入"></a>是否允许加入</h2><p>进行计算之前，<code>Dispatcher</code>需要得知当前正在评估的电梯，能否接受当前待加入的请求。</p>
<p>可加入的规则如下：</p>
<ul>
<li>若电梯此时在IDLE状态下，直接允许加入，否则进行下述流程</li>
<li>请求方向需与电梯当前运行方向一致；方向有关的说明见上文。</li>
<li>电梯同向，且电梯此时没有超过请求的起点</li>
<li>如果状态为（RESERVED）&#x2F;（WAITING，且前一个状态是RESERVED），则：<br>RESERVED状态需允许捎带<br>若预约请求方向与当前运行方向相反，则待加入请求的终点不得超过预约请求的起点</li>
<li>加入后，不会出现电梯满员的情况</li>
</ul>
<p>“电梯满员”视个人实现不同，判断逻辑可能不同；我这里就以我的实现为例，谈谈我的判断逻辑。</p>
<p>正如上文所述架构实现，我们一个电梯的子请求队列不仅包含了当前在电梯内的请求，还包含了将来电梯要捎带的请求；</p>
<p>我们的判断逻辑是，假设请求加入了子请求表，<strong>得出各楼层处，最多同时出现的请求数；</strong> </p>
<p>这一“同时出现的请求数”，反映了那一运行区间内，电梯内的人数。</p>
<p><strong>若各区间的同时出现请求数的最大值，大于电梯容量，则认为此时加入请求会导致超员。</strong></p>
<p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020250406214224.png" alt="Pasted image 20250406214224.png"></p>
<p>如图所示，待加入请求在<code>F2-F3</code>区间会导致超员，故我们不应加入这一待加入请求。</p>
<p>需要注意的是，如果采用了上文RESERVED状态的实现，若预约请求方向与电梯空放方向一致，此时还需将预约请求放进上面的图里进行比较。</p>
<h2 id="计算评价指数"><a href="#计算评价指数" class="headerlink" title="计算评价指数"></a>计算评价指数</h2><p>在上述复杂的判断后，我们终于可以开始计算了…</p>
<p>我们的计算公式如下：</p>
<p>$$index &#x3D; index_{base} + priorityPenalty * elevStopTime$$</p>
<h3 id="index-base"><a href="#index-base" class="headerlink" title="$index_{base}$"></a>$index_{base}$</h3><p>我们先需要得知：</p>
<ul>
<li>$dis$：电梯所在位置，与请求起点的楼层数</li>
<li>$travel$：请求跨越的楼层数</li>
<li>$stopCount$：请求沿途需要停靠，以让自己进电梯&#x2F;捎带其它请求；<code>stopCount</code>即中途停靠的次数</li>
</ul>
<p>随后即可算出当前请求的运行时间，作为我们评价指数计算的第一步；</p>
<p>$$index_{base} &#x3D; (dis + travel)*elevSpeed + stopCount * elevStopTime $$</p>
<h3 id="priorityPenalty"><a href="#priorityPenalty" class="headerlink" title="$priorityPenalty$"></a>$priorityPenalty$</h3><p>优先级惩罚，是所有请求的优先级惩罚之和：</p>
<p>$$priorityPenalty &#x3D; \sum_{i&#x3D;1}^{n}{penalty_{R_i}}$$</p>
<p>对于一个请求$R$，设其优先级为$priority$，楼层跨度为$travel$，则我们规定该请求允许的中途停靠次数$maxAllowedStops$如下：<br>$$maxAllowedStops &#x3D; round(travel * (1 - \frac{priority}{100}))$$<br>其中，$round(x)$取$x$最靠近的整数。</p>
<p>在我们进行评价指数的计算时，我们先假设待加入请求已被加入；随后，对原有的请求$R_i$，算出加入后的<strong>总停靠次数</strong>$stops$。</p>
<ul>
<li>若$stops &lt;&#x3D; maxAllowedStops$：$penalty_{R_i} &#x3D; 0$</li>
<li>否则：$penalty_{R_i} &#x3D; (stops - maxAllowedStops) * priority$</li>
</ul>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>由此，我们就可以算出各个（可加入请求的）电梯的评价指数，选择评价指数最低者加入。</p>
<p>上述是一个相对简单的模型，相信各位有更好的实现。</p>
<h1 id="评测方案"><a href="#评测方案" class="headerlink" title="评测方案"></a>评测方案</h1><p>我选择构建评测机框架，<strong>留出随机数据生成器（dataGen）与正确性检查器（Checker）的接口</strong>。这样有利于提高不同题目下评测的灵活性。</p>
<p>评测机框架方面，我构建了一个可以评测<strong>多程序、多测试点</strong>的多线程评测机，按照以下两种策略运行：</p>
<ul>
<li>测试深度优先：评测机优先对一个待测程序，测试多个测试点</li>
<li>测试广度优先：评测机优先对一个测试点，测试多个程序</li>
</ul>
<p>评测机框架建议允许添加数据生成器生成的数据以外的数据，从而为人工构造高强度数据提供可能。</p>
<p>运行测试程序方面，我选用了Python的<code>subprocess</code>库，其中的<code>POpen</code>方法十分有用，不仅可以指定子进程的工作目录，还可重定向子进程的输出。</p>
<p>注意到，我们的数据投喂器读取的是**当前工作目录下的<code>stdin.txt</code>**；因此，我们可以通过指定不同工作目录的方法，来让投喂器同时测试多个样例。</p>
<p>随后，我们即可使用数据投喂器+打包好的<code>.jar</code>进行评测；两个子进程需要用管道串起来，实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_process = subprocess.Popen(</span><br><span class="line">                [<span class="string">&#x27;input.exe&#x27;</span>],  <span class="comment"># input.exe 读取当前目录的 stdin.txt</span></span><br><span class="line">                cwd=case_dir,    <span class="comment"># 设置工作目录为测试用例目录</span></span><br><span class="line">                stdout=subprocess.PIPE,</span><br><span class="line">                stderr=subprocess.DEVNULL,</span><br><span class="line">                text=<span class="literal">True</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">java_process = subprocess.Popen(</span><br><span class="line">                [<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;-jar&#x27;</span>, os.path.join(target_dir, jar_file), <span class="string">f&quot;-Xmx<span class="subst">&#123;memLimit&#125;</span>&quot;</span>],</span><br><span class="line">                stdin=input_process.stdout,</span><br><span class="line">                stdout=fileout,</span><br><span class="line">                stderr=fileerr,</span><br><span class="line">                text=<span class="literal">True</span></span><br><span class="line">            )</span><br></pre></td></tr></table></figure>

<p>据闻Python的<code>psutils</code>库有办法记录CPU使用时间，不过我的尝试没有成功，希望做过尝试的同学多多分享经验:P</p>
<p>我两次作业的随机数据生成器与Checker均先由AI生成，再由人工进行细节修改。</p>
<p>注意到，AI生成的Checker并不完全准确，在HW6时这一问题尤为显著，需要多处人工修正；<strong>在寻求AI工具的帮助，节省时间的同时，请务必仔细检查AI生成的工具是否能如预期般工作。</strong></p>
<h1 id="之前写过的一些总结"><a href="#之前写过的一些总结" class="headerlink" title="之前写过的一些总结"></a>之前写过的一些总结</h1><ul>
<li><a href="http://oo.e2.buaa.edu.cn/assignment/623/discussion/1684">使用ReentrantLock，实现更灵活的锁管理策略</a></li>
<li><a href="http://oo.buaa.edu.cn/assignment/621/discussion/1682">在IDEA内部，进行更高效的死锁调试</a></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>本单元，我感觉最需要的其实是细心，不然线程间交互很容易出现问题。</p>
</li>
<li><p>架构设计同样起到了关键的作用。本人架构中<code>RESERVED</code>状态的抽象，大大节省了本单元的开发时间。</p>
<p>我认为，只要架构：</p>
<ul>
<li>易于维护；</li>
<li>复杂度低（可以归进上条）；</li>
<li>运行效率在可接受范围内；</li>
</ul>
<p>就可以算一个好设计。</p>
<p>不过，我自己不得不承认，我本单元架构在不少实现细节上的复杂度实在太高，因此带来的BUG与维护的不便不在少数。</p>
</li>
<li><p>本单元亦让我直观地感受到了<strong>算法和数学模型，于程序的重要性何在。</strong> </p>
<p>本人实现中，判断电梯是否满员的问题，可以抽象为计算一个二维空间内，所有线段的最多重叠次数；没有算法的帮助，计算效率很难提升。</p>
<p>处理优先级问题的方法，其实就是简单的数学建模。</p>
</li>
<li><p>感受到了AI的力量。使用AI生成<code>checker</code>+人工修改的效率，远比纯手搓要高。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>课程相关</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>OO_U1 - 数学表达式</title>
    <url>/2025/02/28/OO_U1%20-%20%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Hw1"><a href="#Hw1" class="headerlink" title="Hw1"></a>Hw1</h1><p>这本是一个描述本人思路的草稿，后决定还是整理一下，发到公屏交流一下））</p>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>读入一个含：</p>
<ul>
<li>加，减</li>
<li>乘</li>
<li>乘方</li>
<li>至多一层括号（建议考虑多层的拓展）<br>的 <strong>单变量（e.g. 字母x）</strong> 表达式。</li>
</ul>
<p>输出：</p>
<ul>
<li>展开所有括号</li>
<li>结果尽可能短<span id="more"></span></li>
</ul>
<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>我们可以继续沿用先前的逻辑，不过需要针对乘方进行优化（用一个我看得懂，杂揉了RegEx的写法，严谨定义请参阅参考书）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Expr：(+|-)&#123;0,1&#125;term | expr(+|-)term</span><br><span class="line">- Term：Term * Factor | (+|-)&#123;0,1&#125;Factor</span><br><span class="line">- Factor：**变量** | 常数 | Expr</span><br><span class="line">- 变量：x(^【一个正数，可能有前导0和+】)&#123;0,&#125;</span><br><span class="line">- 常数：(+|-)&#123;0,1&#125;\d+</span><br></pre></td></tr></table></figure>


<p>为了处理幂函数，我们引入Factor的下一级SubFactor：当前定义下，为<code>^</code>两端的对象，可为数字，变量或表达式。</p>
<p>此时，我们的指数一定为一个正数，这里SubFactor涵盖指数会不会有问题？在Parser标记的过程，不会；但在后面由标记好的Expr，得到多项式的过程中，就有可能出问题了。</p>
<h2 id="多层括号嵌套"><a href="#多层括号嵌套" class="headerlink" title="多层括号嵌套"></a>多层括号嵌套</h2><p>看了OOpre.hw7的都知道，那边的实现之所以不能处理多层嵌套，是因为在最低层次中引入了SubExpr；我们只需把SubExpr换成Expr，就可以处理多层括号嵌套了。</p>
<h2 id="发病"><a href="#发病" class="headerlink" title="发病"></a>发病</h2><p>这是一个在参考书的定义下不可能出现的情况，但仍然值得考虑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-++---+++-009+b</span><br></pre></td></tr></table></figure>
<p>对应regex：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(\+|-)&#123;0,1&#125;((\d|\+|-)+)</span><br></pre></td></tr></table></figure>

<p>实际情况中，至多只可能出现三个连续的符号，但考虑一下也好。</p>
<h2 id="继续构造"><a href="#继续构造" class="headerlink" title="继续构造"></a>继续构造</h2><h2 id="lexer"><a href="#lexer" class="headerlink" title="lexer"></a>lexer</h2><p>将输入tokenize。<br>分以下几类：</p>
<ul>
<li><code>+</code></li>
<li><code>-</code></li>
<li><code>*</code></li>
<li><code>^</code></li>
<li><code>(</code></li>
<li><code>)</code></li>
<li>数字：调用parseNum()，分析出数字。此时我们先不考虑符号数的问题。</li>
</ul>
<p>空字符直接跳过，毕竟在我们的定义中，空格不存在语义；不关心其数量而直接跳过，并无影响。</p>
<p>为什么在parse前要tokenize？这对后续拓展其实是有利的，比如说，变量名字不是一个字符x，而是多个字符时。</p>
<h2 id="符号化简"><a href="#符号化简" class="headerlink" title="符号化简"></a>符号化简</h2><p>我们认为，此时各个Term的连接应该都是加号。因此，我们需要想一个处理正负的方法。</p>
<p>我们需要对符号进行简化，得到唯一的正负标识<code>reversed</code>。</p>
<p>这个<code>reversed</code>标记该放到哪一层呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此时，我们应在最小单元处，进行加减号的化简；因此，我们决定，在parseSubFactor()过程中进行加减号的吞并，同时使用一标识符，指示SubFactor是否取反。</span><br><span class="line"></span><br><span class="line">事实上，我们只需要对Num，Var记录这一取反符号</span><br></pre></td></tr></table></figure>

<p>仔细思考发现，上述思路对于以下样例处理存在问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-5+-x^5</span><br></pre></td></tr></table></figure>

<p>幂函数整体是一个正值。因此，我们处理正负的问题，应该停留在Factor层次。处理连续符号的过程，因此也放在Factor处进行。</p>
<p>为此，我们还需修改Factor类的构成：除SubFactor容器外，还需记录一个<code>boolean reversed</code>.</p>
<p>具体实现为：</p>
<ul>
<li>Expr：parse方法需提供<code>reversed</code>，指示默当前正负；直接向下parse，并传递<code>reversed</code>。</li>
<li>Term：符号可认为只对第一个乘数有影响，故只将该<code>reversed</code>传递到第一个Factor，其余Factor的reversed全设为false；继续向下parse</li>
<li>Factor：<strong>先处理符号。</strong> 当前读到+保持<code>reversed</code>不变，读到-对<code>reversed</code>取反。完成处理后，使用处理好的<code>reversed</code>新建Factor对象，再进行下一层的parse（方法同现有的类似，不再赘述）。</li>
<li>SubFactor：分三类情况，数字，变量和表达式。仿照现有思路处理即可。<strong>不过</strong>，对于表达式，我们此时调用parseExpr()时，传入的<code>reserved</code>应为false，因为我们已经在其上一级Factor处理好了符号。</li>
</ul>
<p>这样一来，我们逐层向下传递了各个Factor的正负属性，从而为下文进行多项式转换提供便利。</p>
<h2 id="多项式转换"><a href="#多项式转换" class="headerlink" title="多项式转换"></a>多项式转换</h2><p>我们通过<code>Parser.parseExpr()</code>，得到了一个处理（或者说，标记？）后的<code>Expr</code>。</p>
<p>考察最终化简式，可以得知其形式为：<br>$$\sum a*x^b$$<br>因此，我们需要构造：</p>
<ul>
<li><code>Mono</code>类：一个单项式</li>
<li><code>Poly</code>类：一个多项式，使用容器存储其包含的单项式</li>
</ul>
<p>同样，我们认为，此时各单项式间连接只有加法。</p>
<p>如何定义Mono？其中包含：</p>
<ul>
<li><code>BigInteger multiplier</code>：a</li>
<li><code>String var</code>:x</li>
<li><code>BigInteger exp</code>: b</li>
</ul>
<p>针对纯数字的表达，我们规定：</p>
<ul>
<li>值全部存储在<code>multiplier</code>中</li>
<li><code>var</code>此时为空串<code>&quot;&quot;</code>，为变量可能为多字符的情况准备</li>
<li><code>exp</code>恒为1</li>
</ul>
<p>在这个思路的指引下，我们引入一个处理器<code>Flattener</code>，将已进行标记的表达式<code>expr</code>“拍扁“，得到一个满足上式的多项式。此时，我们并不需要考虑化简的问题；化简的过程，我们在Poly类内实现一个方法即可。</p>
<p>为何要多一个Flattener? 感觉上，边Parse边获取单项式似乎是可行的，但为了高内聚低耦合，还是把获取单项式的过程独立出来吧。</p>
<p>Flatter中需要实现的方法：</p>
<ul>
<li><code>getPoly()</code>：将表达式转为多项式</li>
<li><code>getMono()</code>：逐层得到单项式，返回一个<strong>单项式容器</strong>；显然，要根据传入的是Expr&#x2F;Sub&#x2F;Factor来进行不同的处理</li>
</ul>
<p><code>getPoly()</code>调用<code>getMono(Expr)</code>，随后将容器包装为Poly对象。</p>
<p>我们在此仍然采取递归下降的思路，对已标记的Expr进行处理。根据传入对象类别划分：</p>
<ul>
<li><p>Expr：创建一单项式容器<code>monoList</code>；遍历包含的Term，由getMono()得到子容器；此时是加号，简单合并各容器即可。</p>
</li>
<li><p>Term：遍历Factor，得到各子容器；此时是乘号，调用一个<strong>多项式乘法方法</strong>，得到存有单项式的一个容器</p>
</li>
<li><p>Factor：过程略有复杂。<br>在当前定义下，必为<code>a^b</code>的形式。若为<code>x^b</code>，直接构建新的<code>Mono</code>，加入将返回的单项式容器；若为<code>&lt;num&gt;^b</code>，则直接进行计算，按照上文中，纯数字下单项式的约定，构建单项式；若为<code>&lt;expr&gt;^b</code>，则调用一个<strong>多项式求幂方法</strong>，得到一系列单项式，最后加入容器。</p>
<p>在得到单项式，返回容器之前，还记得Factor的<code>reserved</code>属性吗？此时，若其为true，则需要调用一个<strong>取反方法</strong>，将各个单项式的系数取反。</p>
</li>
</ul>
<p>好的，现在我们还要做：</p>
<ul>
<li>多项式乘法：多次<strong>单项式乘法</strong></li>
<li>多项式求幂：多次调用多项式乘法即可</li>
<li>取反：将各个单项式的系数取反。</li>
<li>单项式乘法：功能不赘述。<br>不过，我们的乘数为0，乘后指数为0的情况都需要在此处理。</li>
</ul>
<p>这三者的实现其实很简单，这里就不再赘述，不过可以提一下多项式求幂：</p>
<p>在定义中，<code>m^0=1</code>，我们怎么实现这个逻辑呢？显然，我们求幂返回的是个单项式容器；故，我们在方法被调用的开始，初始化一个只含单项式：<strong>数字1</strong>的容器；随后，根据次幂，将其同底数多项式相乘指数次即可。</p>
<p>一番操作后，我们就得到了一个未化简的多项式对象Poly了。</p>
<h2 id="多项式化简"><a href="#多项式化简" class="headerlink" title="多项式化简"></a>多项式化简</h2><p>思路很简单：遍历单项式容器，合并同次幂单项式。</p>
<p>需要对单项式为数字（即，<code>var.equals(&quot;&quot;)</code>）单独开情况处理。不用担心指数为0的情况，上面的单项式乘法里，我们已经处理掉了。</p>
<p>限于篇幅，且实现也不困难，这里就不展开说了。</p>
<h1 id="Hw2"><a href="#Hw2" class="headerlink" title="Hw2"></a>Hw2</h1><p>引入了两个新功能：</p>
<ul>
<li>三角函数：<code>sin</code>，<code>cos</code></li>
<li>自定义递推函数</li>
</ul>
<p>其他的定义可以认为没改。我们逐个分析。</p>
<h2 id="递归函数解析"><a href="#递归函数解析" class="headerlink" title="递归函数解析"></a>递归函数解析</h2><blockquote>
<p>也可以参考<a href="http://oo.e2.buaa.edu.cn/assignment/608/discussion/1656">这篇帖子</a>，其思路也很不错，本人思路也有不少与之相近之处</p>
</blockquote>
<p>这是本次作业里较为头疼的一点，要怎么办呢？</p>
<p>书接上文，我们在解析表达式时，在<code>Factor</code>下再加了一层<code>SubFactor</code>。一番分析可知，<code>递归函数调用</code>正是属于<code>SubFactor</code>这一层次。那么，我们能不能<strong>在<code>parseSubFactor()</code>中添加调用对应的处理规则</strong>，使得我们parse函数调用的时候，得到一个<strong>完全展开的表达式呢</strong>？</p>
<p>是可以的。在此之前，我们需要搓一个**展开递归函数的“求解器”<code>Solver</code>**。</p>
<h3 id="求解器"><a href="#求解器" class="headerlink" title="求解器"></a>求解器</h3><p>我们这里的整体思路是：</p>
<ul>
<li>Parser解析输入表达式时，读到调用，交给Solver处理；</li>
<li>Solver通过调用序号，得到调用对应的表达式；此时，我们<strong>不要求此处得到的表达式完全展开</strong></li>
<li>解析这一表达式；遇到调用，则递归重复上述思路。</li>
</ul>
<p>我们当然先要知道递归函数定义如何。我的处理是：</p>
<ul>
<li><strong>先把各定义Tokenize为Token串</strong>；</li>
<li>非递归定义的Token串：存入一个<strong>以序号为索引的定义表</strong>内</li>
<li>递归定义的Token串：单独存储。</li>
</ul>
<p>至于为什么这么做，这就要看我们的求解过程了；我们此时先不管形参转实参的问题：</p>
<ul>
<li>对传入的调用序号，<strong>先查定义表内有没有该序号</strong>，有则直接解析表项的Token串，没有则继续：</li>
<li>定义表不存在该序号，则<strong>获取递归定义的Token串，并将其中不定序号<code>n</code>对应的Token，换成序号对应的数字Token</strong></li>
<li>解析这一替换好的Token串副本。随后，就是我们上面的整体思路。</li>
</ul>
<p>问题来了，我们要怎么解析递归表达式？我们这里的Token串仍然是表达式，<strong>复用我们写好的Parser</strong>即可，不过需要些许更改：</p>
<ul>
<li>添加SubFactor为调用时的处理方法，并解析出调用的<code>序号</code>与<code>参数</code>(上面已经提到）</li>
<li>序号的解析应该支持<code>&lt;num&gt;</code>和<code>&lt;num&gt;-&lt;num&gt;</code>的形式，为递归做准备</li>
<li>实现<strong>形参替换</strong></li>
</ul>
<h3 id="形参替换"><a href="#形参替换" class="headerlink" title="形参替换"></a>形参替换</h3><p>我们能不能在Parser进行处理的时候，就直接自动把变量解析成实参呢？</p>
<p>答案是有的，我们只需要略微修改Parser，以及<code>parseSubFactor()</code>时，读到变量类型的处理方法：</p>
<ul>
<li>Parser：添加属性：<strong>符号查找表</strong><code>HashMap&lt;String,Factor&gt;</code></li>
<li><code>parseSubFactor()</code>：碰到变量先查表，如有对应实参，则返回实参的Factor对象，没有则返回变量</li>
<li>显然，我们还要把Factor分类到SubFactor里。</li>
</ul>
<p>在我们解析输入函数时，我们向<code>parse()</code>传入空表；而在<strong>解析递归函数时</strong>，我们则先把变量建立好对应的查找表，再在调用的<code>parse()</code>中传入递归函数的符号查找表。</p>
<p>至此，我们即可展开递归函数并传递变量，完成原设计中标记表达式的功能。</p>
<h3 id="获取多项式"><a href="#获取多项式" class="headerlink" title="获取多项式"></a>获取多项式</h3><p><strong>我们这里先不管三角函数。</strong></p>
<p><code>Flattener</code>这里本没有什么好说的，但是：参数必须是Factor类型，而我们把Factor类归在了SubFactor类下，故这里也需补充对应获取多项式的逻辑…</p>
<blockquote>
<p>事实上，参数完全可以视作<code>Expr</code>类，毕竟参数内容是由你的parse方法得到的，而且递归下降的原理也告诉我们，这么处理没问题；视作表达式来处理还更方便，因为不用把Factor归进SubFactor，维持我们Hw1的处理逻辑就行；但题目这么说就这么做吧</p>
</blockquote>
<p>这里我们先在“标记”阶段处理掉了递归函数展开，因而获取多项式的部分不需大改，这算是低耦合的好处吧。</p>
<h2 id="单项式结构的修改"><a href="#单项式结构的修改" class="headerlink" title="单项式结构的修改"></a>单项式结构的修改</h2><p>由于三角函数的引入，我们不得不修改单项式的定义！</p>
<p>现定义单项式如下：<br>$$a*\prod<unit>$$<br>其中：$$unit &#x3D; &lt;Var|TrigFunc&gt;^n$$<br><code>Var</code>代指变量，<code>TrigFunc</code>代指三角函数。</p>
<p>因此，我们只需要一个<code>BigInteger</code>存进乘数，一个<code>ArrayList&lt;Unit&gt;</code>存入后面累乘的幂函数。</p>
<p>在修改了单项式的定义后，是不是需要大规模的重构呢？</p>
<p>先看<code>Flattener</code>：</p>
<ul>
<li>构造方法：我们在构造方法处使用多态，从而<strong>兼容先前构造接口</strong></li>
<li>多项式求幂&#x2F;相乘：只涉及<code>ArrayList&lt;Mono&gt;</code>的相关处理，在这一层次不涉及<code>Mono</code>内部操作，维持现状即可，算是万幸</li>
<li>单项式相乘：<strong>这个没办法，必须重写</strong>；</li>
</ul>
<p>我的重写思路如下：</p>
<ul>
<li>分两步进行：</li>
<li>第一步：简单的乘数相乘，幂函数容器合并</li>
<li>第二步：合并底数相同的幂函数</li>
</ul>
<p>第二步中如何比较底数相等，以及如何合并难度不大，留给读者自行探索。</p>
<p>再看负责多项式化简的<code>Poly</code>：</p>
<ul>
<li>属性不用更改，本来就是<code>Mono</code>容器</li>
<li>出问题了！合并同类项的<code>mergeMono()</code>要大改！</li>
</ul>
<p><code>mergeMono()</code>分两步：</p>
<ul>
<li>比较多项式是否为同类项，是则合并</li>
<li>进行三角函数的化简，这个后面再提</li>
</ul>
<h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><p>这才是本次作业最头大的问题，主要在于化简的复杂度实在太高。</p>
<h3 id="TrigFunc与TrigFuncFactor"><a href="#TrigFunc与TrigFuncFactor" class="headerlink" title="TrigFunc与TrigFuncFactor"></a><code>TrigFunc</code>与<code>TrigFuncFactor</code></h3><p>我们引入这两个新的类。</p>
<ul>
<li><code>TrigFuncFactor</code>在Parser内使用，其内存放三角函数的类型，及参数对应的<code>Factor</code></li>
<li><code>TrigFunc</code>在处理成多项式后使用，其内存放三角函数的类型，及参数对应的<strong>多项式</strong></li>
</ul>
<p><strong>三角函数</strong>与<strong>函数调用</strong>被放在了“变量因子”层次，同之前幂函数在一个层次。因此，我们决定，将与<code>TrigFuncFactor</code>置于<code>SubFactor</code>层次，这对<code>sin()^2</code>情况的处理亦有好处。</p>
<p>需要在Flattener和Parser处编写针对三角函数的规则，这里不再赘述。</p>
<h3 id="化简"><a href="#化简" class="headerlink" title="化简"></a>化简</h3><p>我选择复现<a href="http://oo.buaa.edu.cn/assignment/608/discussion/1657">讨论区内已有方法</a>，化简规则看这个基本就够了。不过这篇帖子里讲的是是单次化简。</p>
<p>考虑这样一个输入：<br>$$(cos(x)^2-sin(x)^2)^2+sin(2x)^2$$<br>理想的化简结果是<code>1</code>；显然，单化简一次是不够的！</p>
<p>我们引入这样一个多重化简机制：</p>
<ul>
<li>两个容器：原始单项式集合<code>monoList</code>和结果<code>newMonoList</code></li>
<li>外层套<code>while()</code>，由一个布尔变量<code>proceed</code>指示是否继续重复化简</li>
<li><strong>引用一个写回缓存区</strong><code>buffer</code>，实现“化简之后，把结果加回正在遍历的结果列表”的效果</li>
<li>判断单项式集合中<code>mono</code>与<code>newMonoList</code>中元素是否可化简：</li>
<li>若能，则<strong>将合并结果写入缓存</strong>，并<strong>将此<code>mono</code>从原始集合中移除</strong>；</li>
<li>若不能，<strong>将此<code>mono</code>移动到结果列表中</strong>；也就是说，<code>mono</code>无论如何都得删。</li>
<li>双层遍历完成后，**若缓存为空，则说明不可化简，<code>proceed</code>设为否；反之，则将缓存内容写回<code>newMonoList</code>**。</li>
</ul>
<p>示意如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean proceed = true;</span><br><span class="line">while (proceed) &#123;</span><br><span class="line">	&lt;for mono in monoList&gt; &#123;</span><br><span class="line">		&lt;第一次进行化简时，把第一个mono放入结果列表&gt;</span><br><span class="line">		&lt;for newMono in newMonoList&gt; &#123;</span><br><span class="line">			// do something</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	if (buffer.isEmpty) &#123; proceed = false; &#125; else &#123;</span><br><span class="line">		newMonoList.addAll(buffer)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Hw3"><a href="#Hw3" class="headerlink" title="Hw3"></a>Hw3</h1><p>引入非递归自定函数与求导因子。</p>
<p>SubFactor引入上述两个新元素，对应修改Flattener规则</p>
<p>求导规定成<code>dx(&lt;Expr&gt;)</code>；在<code>Flattener.getMono(Factor)</code>中，读到求导因子的Subfactor，则将里面的<code>&lt;Expr&gt;</code>化成多项式，随后逐单项式，运用求导规则，获得新的表达式。</p>
<p>可以造一个单项式求导器。</p>
<p>非递归自定函数，按照现有实现改进即可。考虑到我们写递归函数求解器的写法，我们甚至可以直接复用。</p>
<h2 id="改Solver"><a href="#改Solver" class="headerlink" title="改Solver"></a>改Solver</h2><p>复用已有的Solver。</p>
<p>首先要改lexer，把两个自定函数的符号进行分类，分类就继续分到<code>FUNC</code>内；</p>
<p>接下来是Parser部分；我们在处理递归函数的时候，写了这么一个东西：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lexer.forward(); // Skip LCurly  </span><br><span class="line">final int times = parseInvocationTimes();  </span><br><span class="line">lexer.forward(); // Skip RCurly</span><br></pre></td></tr></table></figure>
<p>我们在此次修改时，需要这么做：</p>
<ul>
<li>读取当前Token，看是圆括号还是花括号</li>
<li>圆括号-&gt;普通函数，花括号-&gt;递归函数</li>
<li>圆括号默认<strong>调用次数为0</strong></li>
</ul>
<p>随后，目光转向Solver；</p>
<p>在我初始化Solver时，我采用了如下写法，以获取<code>n</code>行的函数定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Solver(int n) &#123;  </span><br><span class="line">    int lines = n;  </span><br><span class="line">    while (lines &gt; 0) &#123;  </span><br><span class="line">        String expr = scanner.nextLine();  </span><br><span class="line">        Lexer lexer = new Lexer(expr);  </span><br><span class="line">        classify(lexer);  </span><br><span class="line">        lines--;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们初始化一般函数时，<code>n</code>设成1；递归函数，<code>n</code>为3.</p>
<p>其中的<code>classify()</code>方法，是根据输入的定义式，判断递归表达式的类型，从而决定将定义放入递归定义，还是定义表内；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classify() &#123;</span><br><span class="line">	// Skip Name  </span><br><span class="line">	// Skip &#123;  </span><br><span class="line">	Token typeToken = lexer.getCurrentToken();  </span><br><span class="line">	// Skip n  </span><br><span class="line">	// Skip &#125;  </span><br><span class="line">	// Skip (</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用同样的思路，在普通函数时，让typeToken变成”0”；随后，就可顺利复用Solver。</p>
<p>那么，我们怎么实现多个函数的解析呢？</p>
<ul>
<li>首先，我们需要给<code>Solver</code>添加<code>String name</code>属性，从而记录当前求解器解的是哪一个函数；</li>
<li>随后，我们需要构建一个<strong>按名称的函数求解器表</strong>，将其传给Parser；</li>
<li>Parser在遇到函数关键字时，查找求解器表，获得求解器，随后求解得到表达式。</li>
</ul>
<p>这部分就成功解决了，接着看求导。</p>
<h2 id="加求导"><a href="#加求导" class="headerlink" title="加求导"></a>加求导</h2><p>首先，我们要在Lexer里面加<code>dx</code>的规则，这就不多说了。</p>
<p>求导因子会出现嵌套，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dx(dx(x^2)+x^3)</span><br></pre></td></tr></table></figure>

<p>我们此时仍然不用担心，递归下降的原理保证其可以被处理；我们只需在<code>getMono(Factor)</code>处正确获取多项式即可。</p>
<p><code>getMono(Factor)</code>处，读到求导因子，调用一个求导器，获取实际多项式。</p>
<h2 id="求导器"><a href="#求导器" class="headerlink" title="求导器"></a>求导器</h2><p>为方便求导的进行，我们决定对一个<strong>多项式</strong>求导。也就是说，我们需要先将<code>dx(&lt;expr&gt;)</code>中的表达式先转换为多项式，再进行我们求导的过程。</p>
<p>我们需要求导的表达式，符合如下一般形式：<br>$$expr &#x3D; \sum{a*\prod{<base>^b}}$$<br>我们将其分为以下层次，分别求导：</p>
<ul>
<li>多项式：如上</li>
<li>单项式：$a*\prod{<base>^b}$</li>
<li>幂函数：$<base>^b$</li>
<li>底数：$<base>$</li>
</ul>
<p>这样即可应对链式法则中，幂函数之底数为三角函数的问题。</p>
<p>各层规则如下：</p>
<ul>
<li>多项式：对各单项式求导，<strong>合并各次求导所得多项式</strong></li>
<li>单项式：实现<strong>乘法法则</strong>，得到求导后多项式</li>
<li>幂函数：<br>先假设<code>&lt;base&gt;</code>为一个整体，按照幂函数的求导方法正常进行；随后，<strong>将结果与底数求导结果相乘，实现链式法则</strong>。这里可能需要对<code>^0</code>，<code>^1</code>等情况做特殊考虑。</li>
<li>底数：返回一个<strong>多项式</strong><br>数字：求导为0；<br>变量：求导为1；<br>三角函数：sin,cos按各自方式求导（内部表达式视为整体）后，<strong>与内部表达式的求导结果相乘</strong>，实现链式法则。</li>
</ul>
<p>不难注意到，我们上面需要用到多项式乘法；调用我们已实现的方法即可。</p>
<h2 id="拓展三角化简"><a href="#拓展三角化简" class="headerlink" title="拓展三角化简"></a>拓展三角化简</h2><p>在Hw2中，我没有搓sin的二倍角化简。在本次作业中，由于出现可化简情况的概率大幅增大，我们决定补齐这一化简策略。</p>
<p>$$(cos(x)^2)’&#x3D;-2cos(x)sin(x)&#x3D;-sin(2x)$$</p>
<p>为了防止化简后，输出长度不减反增，我们规定其：</p>
<ul>
<li>在其它三角化简后进行。</li>
<li>仅在sin,cos指数均为1时进行</li>
</ul>
<p>还有化简本身的规则：</p>
<ul>
<li>乘数绝对值大于1（因为我们的系数是<code>BigInteger</code>）.</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回顾本次作业，我发现自己的最终成果存在以下问题：</p>
<ul>
<li>Flattener中，<code>ArrayList&lt;Mono&gt;</code>与<code>Poly</code>类混用；这是因为，Poly类是在我发现多项式化简需求后才引入的；我没有狠下心，将单项式容器全部重构为<code>Poly</code>类，导致<code>Flattener</code>处画风相当混乱；</li>
<li>各方法所属的类并未妥善划分；我的多项式&#x2F;单项式乘法全部放在了<code>Flattener</code>中。虽说获取多项式需要这些方法，但仔细想来仍然不合理：多项式有关计算，应该在多项式类中才对；</li>
<li>部分过程未打包为方法，导致可读性下降：最明显的，就是我赶工赶出来的三角函数化简。</li>
<li>不敢<code>@Override</code>，导致实现深克隆的过程未被打包为方法，而直接出现在过程中；</li>
</ul>
<p>日后多加改正。</p>
]]></content>
      <categories>
        <category>课程相关</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>送给组内信类新生的一点点私货</title>
    <url>/2024/08/04/BUAA-freshman-FAQ/</url>
    <content><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>首先，欢迎各位成为北航士谔书院的一员，也很荣幸能与大家共处同一梦拓小组！</p>
<p>本文将尝试对大家初入大一可能遇到的部分问题进行解答，以备各位不时之需；同时夹带大量私货，欢迎各位参考😋</p>
<p>本文是按苯人自己一年来的经验，想到什么写什么写成的，应该能涵盖各位可能碰到的不少问题。若有其它没有覆盖到的问题，欢迎各位联系交流！🤗</p>
<span id="more"></span>

<p>同时推荐一份民间编写的学生指南，供各位参考；<strong>由于这个指南全靠民间热心的各位大神自发更新，里面的消息可能有不少未及时更新或不准确，仅供参考，真有拿不准的问题欢迎问导员或者梦拓！</strong>：</p>
<p>【腾讯文档】北京航空航天大学学生手册<br><a href="https://docs.qq.com/aio/DQXdSc0hXYlFVcnVY">https://docs.qq.com/aio/DQXdSc0hXYlFVcnVY</a></p>
<p>另有一个比较抽象的新生指南：<a href="https://github.com/BUAA-Wjay/BUAANew">https://github.com/BUAA-Wjay/BUAANew</a><br>（可能需要翻墙），里面消息<strong>可能需要自己甄别一下，</strong> 尤其是各类非官方群，毕竟那里通常是<strong>卖课、推销、诈骗的高发区</strong>。</p>
<h2 id="英语课程选A，还是选B？"><a href="#英语课程选A，还是选B？" class="headerlink" title="英语课程选A，还是选B？"></a>英语课程选A，还是选B？</h2><p>在各位联系到作为梦拓的我的不久之后，相信大家已经对英语课程的分级考有所耳闻了。虽说会参考分班考成绩来分，但这个还是需要各位填选A班还是B班的志愿；那么，选哪个呢？</p>
<p>可能有同学担心，两个班的课业压力差别较大；又或者是在各类吹水群里，听说了前一届甚至前几届前辈对A&#x2F;B班的评价，对A&#x2F;B班的学习状态已有了刻板印象……自然，课业上的压力，两个班的区别<strong>当然是存在的</strong>。<strong>但是！A&#x2F;B班的课业压力孰轻孰重，各届的情况存在巨大的差别</strong>，前人的经验或许有帮助，但在这<strong>很有可能不具参考价值</strong>。</p>
<p>比如，我的 <strong>上一届（2022级）</strong> 普遍反映A班的作业和杂事都很多，难度大云云，B班就很轻松；然而！在我的<strong>这一届（2023级），情况却恰恰相反</strong>。我选择的A班反而每周十分轻松。课堂氛围轻松不说，除了课堂展示以外的杂事与作业真不多，作业检查程度也不算太严；反观同寝室另外3位选择了B班的同学，<strong>每周</strong>都会同各类神奇的英语作业（比如：假设自己要留学，做留学的出行等一系列计划）斗智斗勇不说，据其描述课上也很忙……</p>
<p>而且，两个班最后的期末考试考的都是同一套卷子。从只看成绩的角度而言，选两个班的差别可谓是没有。</p>
<p>因此，个人认为，各位<strong>按照自己的实际英语能力进行选择</strong>就好。<em>如果硬要用量化指标界定能力好坏的话，各位前辈得出的经验是：高考英语140分以上，进A班应该就没问题了。这一点我认为还是可以参考的。</em></p>
<h2 id="学习方法要转变吗？"><a href="#学习方法要转变吗？" class="headerlink" title="学习方法要转变吗？"></a>学习方法要转变吗？</h2><p>一个字：<strong>要</strong>。<strong>上大学必须自学为主。</strong></p>
<p>在高中的时候，各位都习惯的是听老师讲课，自己照单全收即可；但是，在大学，<strong>这个想法是非常危险的</strong>！</p>
<p>且不谈当下大学的本科教育质量之差，现在<strong>照念ppt上课的方式已是常态。</strong> 不自己课下深入学习，只靠课上听讲是不可能学好的！</p>
<p>更何况，现在不少老师（包括北航）只管自己讲自己的，完全不管自己讲的时候台下的同学是否能听懂。<strong>我不觉得这种情况下，听课效果能有多理想，这样真不如自学。</strong></p>
<p>我就是在大一上的时候仍然心存听老师上课的幻想，直到大一下才“放弃幻想，准备斗争”，最后成绩并不亮眼；当然，这部分在最后扯有关我的事的时候再说。</p>
<p>总之，<strong>自学为主，这真的很关键！！</strong></p>
<h2 id="有什么办法预习吗？"><a href="#有什么办法预习吗？" class="headerlink" title="有什么办法预习吗？"></a>有什么办法预习吗？</h2><p>有！办法还不少！这里稍微分享一点经验，<em>同时也会简要掺一点各课程的上课概况的私货</em></p>
<p><em>宇宙安全申明：据说培养方案有改，课程开设方案和上课状况可能都有差别，仅供参考！</em></p>
<p>进入信息大类，各位大一上学起来要花点功夫的主要就是<strong>工科数学分析、工科高等代数、C语言程序设计</strong>三门课程。剩下的基本没预习的必要。</p>
<h3 id="两个学习资料的来源"><a href="#两个学习资料的来源" class="headerlink" title="两个学习资料的来源"></a>两个学习资料的来源</h3><p>开始之前，个人先推荐两个学习资料的来源渠道。</p>
<p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/20240806124149.png" alt="image.png"><br>一个是<strong>北航士谔书院的学业支持中心</strong>的北航网盘资料库。里面包含了大一整个学年可能用到的<strong>往年题，课件</strong>等可能有用的学习资料，同时也有一部分竞赛四六级资料。如果各位对预习有所兴趣，完全可以看着里面的课件ppt来预习 <strong>（事实上，大学，至少北航，上课基本不看教材，而基本只看ppt，知识点等等都在上面；更有甚者是念ppt上课，这也很常见）</strong> 。</p>
<p>里面的资料，相信对各位一定有所帮助：<br><a href="https://bhpan.buaa.edu.cn/anyshare/en-us/link/AAE382BC57552F47C3963B94EA8821E684/8432FD008DFD4F3D9256370735A84832/8EA3C8E70B7941ED9AA164501F0950D2/2E077C8617154E118896618A7C295703/8C5F58E5D4F94DD39151E336665D507B/7A3FF43284484037A2515529D9B0478F?_tb=none">https://bhpan.buaa.edu.cn/anyshare/en-us/link/AAE382BC57552F47C3963B94EA8821E684/8432FD008DFD4F3D9256370735A84832/8EA3C8E70B7941ED9AA164501F0950D2/2E077C8617154E118896618A7C295703/8C5F58E5D4F94DD39151E336665D507B/7A3FF43284484037A2515529D9B0478F?_tb=none</a></p>
<p>   <img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/20240806131618.png" alt="image.png"></p>
<p>另一个是一个往届前辈运营的一个微信公众号：<strong>三文鱼卷。</strong> <em>（以防各位顾虑，纯推荐，没接广，23333）</em> </p>
<p>这里面可以查到 <strong>包括但不限于信息类</strong> 的大一学习指南，里面整理的资料也挺全。<em>但是里面整理的资料难免出现分类混乱，质量参差不齐等问题，大家打包下载之后自己注意一下就可以了</em></p>
<p>但是，这个公众号能提供的资料不止信类大一上、下的学习指南。搜索航类大一上、下的学习资料，你又能获得另一份数分、高代的学习资料。这是因为，两个大类的同学除了少数课程，大部分课程都是相近的。（<strong>注意，用之前还是要核对一下，比如航类大一上的线性代数，大一下的物理教材就和信类不一样</strong>）这时，您不妨在航类的资料库里翻一翻，说不定能够补足信类资料库里缺乏的东西。（比如说，电子版教材，这个我只在航类的资料库里看到过）</p>
<h3 id="C语言程序设计"><a href="#C语言程序设计" class="headerlink" title="C语言程序设计"></a>C语言程序设计</h3><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>先从程序设计（下称<strong>程设</strong>）开始吧。这一门课程主要教授C语言（纯C，没有C++&#x2F;C#）的基本使用，教的程度大概也是知道基本常用知识，能用但不知道背后原理 <em>（事实上，也没多少学校会在课上耐心教背后有趣的底层原理，比如头文件是怎么回事）</em> 的水平，并不算太深入。因此，不要对此有太大的心理压力。</p>
<p>如果您<strong>恰好是前oier</strong>，大佬接我一拜😭🛐，这门课您根本不用担心！</p>
<p>这一部分打好C语言的基础就可以了，后面大一下的数据结构课程就是建立在这门课的基础上的。</p>
<p>预习这一部分课程，看 <strong>《C Primer Plus》</strong> 这本经典的C语言教材即可。在各位上课的时候，也可以把这本书当作自己的正式教材。</p>
<p>又或者，试试这个：《Learn C the Hard Way》（<a href="https://wizardforcel.gitbooks.io/lcthw/content/preface.html%EF%BC%89%E3%80%82">https://wizardforcel.gitbooks.io/lcthw/content/preface.html）。</a></p>
<p>只不过，这个教材涉及到Unix&#x2F;Linux，可能更适合对Unix&#x2F;Linux已经有所了解的同学。不熟悉也没关系，如果目的只是学C语言的话，碰到涉及Linux和valgrind等工具的部分跳掉即可，用vscode等IDE就行。至于vscode怎么配置C语言开发环境，网上自行搜索即可，教程挺多的。<br><em>（当然，这个教材对IDE不是很认可。从 <strong>只学C语言的角度，</strong> 可以姑且忽略这个反对的声音，23333）</em></p>
<p>想多练手的话，<strong>力扣（LeetCode）</strong> 和<strong>洛谷</strong>可以考虑做一下。</p>
<h4 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h4><ul>
<li><p>这门课的<strong>作业</strong>，和每周上完课后的<strong>上机小测</strong>和<strong>考试</strong>都是在课程组的<strong>AC编程平台（<a href="https://accoding.buaa.edu.cn/%EF%BC%89">https://accoding.buaa.edu.cn/）</a></strong> 上进行的。形式效仿的是IOI赛制。<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/20240806162926.png" alt="image.png"></p>
</li>
<li><p>一次典型的练习或上机会有 A-J 10个题。<strong>尽力而为就好，千万不要苛求做全，之前没接触过编程的同学很难做到。</strong> 作为参考，本人一般能做A-G题，有时可以接触到H、I题。</p>
</li>
<li><p>平台上出的题目多为前几届的优秀前辈编写。<em>可以把这个当成题目难度离谱的原因</em>，但也正因此，这门课程给的题目<strong>玩的梗奇多！</strong> 相信在看到自己熟悉的梗的时候，你也会会心一笑！</p>
</li>
<li><p><strong>对于第一次接触编程的同学，对这门课程感到压力是再正常不过的事。</strong> 放平心态，不要放弃！</p>
</li>
<li><p>部分题目的测试数据比较偏（但也确实应该在考虑范围内），经常会出现样例能过，但最后得到的测试结果是结果错误（WA）的情况。<strong>做题不要局限于样例数据，多想想题目给的数据范围，还有各种可能看似不可能的可能。</strong></p>
</li>
<li><p>以我的接触，这门课的助教都还算友好。<strong>有关题目</strong>的问题交流一般都会耐心解答，但是<strong>助教</strong>也是各位前辈兼任的，耐心自然也有限，<strong>不建议一遇到问题就直接找助教，也不应该上来就找助教帮忙debug，而是自己多次尝试无解后再去求助。</strong></p>
</li>
<li><p>视助教的友好程度，如果自己实在找不出问题，且不愿过度麻烦助教，可以向助教要题目的测试数据。<strong>但是这是万不得已的办法，不要轻易尝试，就算要到了也千万不要外传题目数据。对自己负责，同时也要对他人负责。更何况，有人可能要到数据就直接打表过关；打表这种做法对能力的锻炼一点好处都没有，后患无穷。要到数据，旨在用数据找到自己没考虑到的可能，然后在对自己的代码进行修改，而不是偷懒。</strong></p>
</li>
<li><p>一些题目可能会涉及不少高阶算法。欢迎网上自行搜索，提高自己的知识水平</p>
</li>
<li><p>助教一般会在每次上机&#x2F;练习&#x2F;考试后在课程群里发题解，<strong>里面助教会分享不少能提高自己能力的知识，值得一看。</strong></p>
</li>
<li><p>Github是个好地方，要学会在上面找参考代码（不限代码，其实什么都有）之类的资料。如果上不去的话，<strong>建议顺便学学怎么科学上网（特殊义）</strong>。</p>
</li>
<li><p>该课程<strong>只上8周</strong>，也就是说在期中那会这课就考完了。当时这节课是我们周四唯一要上的课，上完之后，下半学期的周四一节课都没有，那叫一个舒服啊😋相信各位也有机会享受这种福利（</p>
</li>
</ul>
<h3 id="工科数学分析（一）"><a href="#工科数学分析（一）" class="headerlink" title="工科数学分析（一）"></a>工科数学分析（一）</h3><p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/c3a458bf4308d96022967f7e6b759be0.jpg" alt="c3a458bf4308d96022967f7e6b759be0.jpg"></p>
<h4 id="正文-1"><a href="#正文-1" class="headerlink" title="正文"></a>正文</h4><p><strong>数分</strong>可谓大一除程序设计外的第二大难关。课程难度自然存在，但是还是能学好的。预习无非以下几个手段：</p>
<ul>
<li><strong>看课件</strong>。但是，课件有些部分还是写得过于简略，这里还是建议配合教材使用。<em>北航版数分电子版教材，不妨在上面提到的<strong>三文鱼卷</strong>里的<strong>航类大一上资料库</strong>获取</em></li>
<li><strong>看本校教材</strong>。这就不加赘述了。本校教材就是这张梗图里的教材，黄色封面。</li>
<li><strong>看外校教材</strong>。个人感觉，北航自己编写的教材在部分内容上的讲解并不算细致，这时各位不妨参考以下外校的教材。上面提到的三文鱼卷的资料库里似乎也有，需要各位自己翻一翻。<br>由于苯人在大一下才开始尝试这么办，这方面经验并不是很足；若要找推荐书目，建议在网上寻求建议，<em>当然也可以拜托我询问一下其它梦拓</em></li>
<li><strong>网课</strong>。B站大学，懂的都懂；由于我没试过，这方面的建议我也只能留个白（）</li>
</ul>
<h4 id="个人感受-1"><a href="#个人感受-1" class="headerlink" title="个人感受"></a>个人感受</h4><ul>
<li><p>要学好数分，除了做好习题真的别无他法。在各位完成作业的时候，<strong>千万不要因为写不完&#x2F;一时想不出解法而直接抄答案</strong>，<strong>后患无穷！！！</strong> 哪怕花的时间有点多，好好练是很关键的！</p>
</li>
<li><p>此外，由于一节课要学的内容非常之多，建议各位课前先看书&#x2F;课件预习（甚至直接自学完，课上顺便听听老师花了什么重点就行，我大一下就这么干的）。</p>
</li>
<li><p>以防出现上了就忘这种情况，建议各位上课稍微记记笔记，或者课下花一点点时间总结。<strong>此外，就我们这一届的经验而言，每周交作业的时候还会让你另外写一份学习心得。与其水过去，不妨就顺便在里面把自己本周学到的东西总结一下。</strong> 本人一室友就是这么做的，他最后数分成绩也还不错；反观我偷懒得多，最后成绩并不是很理想（</p>
</li>
<li><p>在这门课上，各位会接触到一个叫<strong>智慧树</strong>的校外学习平台。在这个平台，除了提交每周作业外，你还需要在上面 <strong>“提高知识点的掌握度”，即做题目</strong>。我个人对这一平台并无好感（主要是事多和有些题目过于偏、难、怪，且<strong>上面的掌握度（须每个达到80%以上，做的时候错一个题基本就没戏）、测试成绩还要算进成绩里面</strong>），<strong>但是这个提高掌握度的事是必须在期末前做完的。</strong> </p>
<p>怎么解决它呢？一种办法是每次上完课就做一个知识点的习题。<strong>还有一种是完成每章的单元测试，满分后对应知识点的掌握度自动提升到80%以上，就不用每个知识点都做一遍题了。</strong></p>
<p><strong>但是！千万不要因为它烦人，就把它拖到期末来做。其恶心程度会让你本就难受的考期雪上加霜！！</strong> 反正都得做，平常还得多练，干脆就把它当练习吧（笑）</p>
</li>
<li><p>平日的作业量<strong>有点小多</strong>，全用周末时间来写有点可惜。数分一周有两节（以我为例，我是周三、五上），不妨上了一节课就尽可能写现在能写的题目，避免出现题目想不出等问题。至于作业题目，开学课程群发的<strong>课程教学日历</strong>应该会全部列出来，<strong>不用等智慧树平台上出现了作业窗口再开始做</strong>。<strong>（当然，老师另有要求的话，以老师说的为准）</strong></p>
<p>另有一个小事，就是当时我们的数分老师<strong>建议课后习题全做。</strong> 我认为这个对各位的要求太高了，各位在做完要求的作业的基础上<strong>量力而行</strong>即可，算是多练习的一个手段</p>
</li>
<li><p>如果感觉老师上课的节奏不适合自己，我建议全靠看ppt&#x2F;看教材自学。<strong>这是很正常的情况，因为各位同学可能遇到老师在课上大费周章地讲书上写好的证明过程、解题方法讲的不细致等情况，此时自学效果反而会比听课好</strong></p>
</li>
</ul>
<h3 id="工科高等代数"><a href="#工科高等代数" class="headerlink" title="工科高等代数"></a>工科高等代数</h3><h4 id="正文-2"><a href="#正文-2" class="headerlink" title="正文"></a>正文</h4><p>这门课的难度其实不大，说实话没有什么预习的必要。</p>
<p>先上的是解析几何。这一部分主要就是空间解析几何的一些基本知识，不难。</p>
<p>上完之后，就进入到线性代数的部分了。这一部分学的主要是矩阵与行列式的知识，可能会稍微烧点脑筋。</p>
<p>教材用的是李红裔、赵迪的《空间解析几何简明教程》与李尚志的《线性代数》。当然也可以试着看其他教材作为参考，不过这方面小弟经验不多，就不多说了。</p>
<p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/20240806153253.png" alt="image.png"><br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/d9802a3a6c4a441eceffdbf1f89f305c.png" alt="d9802a3a6c4a441eceffdbf1f89f305c.png"></p>
<h4 id="个人感受-2"><a href="#个人感受-2" class="headerlink" title="个人感受"></a>个人感受</h4><ul>
<li><strong>如果要深入学习这门课程，强烈建议抛开课程自学</strong>。就以线性代数部分为例，在课上你只会学到矩阵是什么，有什么性质，却并不会教你<strong>学这个有什么用</strong>。甚至介绍性质的时候，有些老师也只会说<strong>这个性质”很好”，而不说”好”在哪里</strong>。如果你恰好对<strong>计算机图形学</strong>感兴趣的话，这门课更要学好，因为<strong>它是计算机图形学重要的数学基础之一</strong>。</li>
<li>有些老师上课进度有些拖沓。<strong>感受到这个问题的时候，请果断地选择看课件&#x2F;教材自学。</strong></li>
</ul>
<h3 id="其他必修课程"><a href="#其他必修课程" class="headerlink" title="其他必修课程"></a>其他必修课程</h3><p>这里就写得简略一些，也不会很全，感受居多。</p>
<ul>
<li>习概：应该还是王海宇老师在教。至少就王海宇老师的课，这门课平日是打着习概名号的社会科学导论课。如果对人文社科感兴趣的话，可以听一听，甚至课下跟老师多多交流，王老师是真的和善！😋不感兴趣也没关系，直接水掉是可以的，只要该完成的课堂展示等作业完成了即可。临近期末的时候会按教材勾复习重点，课上可以不听（</li>
<li>思修：假设是付丽莎（Lisa）老师上的话，那还是很推荐的！平日就是正常的思修课堂，但是Lisa老师平日会准备一些小惊喜（如期末的明信片等），人也很和善！临近期末也会划重点，课程组也有一个公众号<strong>一航思修</strong>，上面会发课程总结等等，值得一看。</li>
<li>体育课-足球课。北航的体育课是自己选的，我自己选了一个学年的足球课。原因无他，黄烨军老师和善不说，整个课上的氛围也很轻松活跃。也不知道黄老师是不是只上沙河的足球课，各位在学院路的话，可能就上不到了；<strong>如果在学院路也有的话，力荐！</strong></li>
<li>（也不知道这个搬到学院路了还有没有）如果各位有入党的意愿的话，在大一上应该会进入学院的士信党建工作坊学习。这时各位应该会上高宁老师的《大国领袖》课程，<strong>强烈推荐各位上课认真听！！！</strong> 高宁老师的思政课，各届同学公认精彩，<strong>上了都说好！！</strong> 就算不打算入党，感兴趣的话也可以将高宁老师的《大国领袖》课当通识课来选，真的建议听一听！</li>
</ul>
<h2 id="需要关注哪些信息渠道？"><a href="#需要关注哪些信息渠道？" class="headerlink" title="需要关注哪些信息渠道？"></a>需要关注哪些信息渠道？</h2><h3 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h3><ul>
<li><strong>北航士谔书院</strong>微信公众号。这个是士谔书院的官方公众号，上面一般会分享<strong>各类学院活动的预告、学习经验分享等消息，</strong> 包括后面的<strong>冯如杯竞赛（必选）的通知，大类分流各专业的宣讲（大一下）预告</strong>，也是在这里发布。</li>
<li><strong>微言航语</strong>微信公众号。这上面主要分享的是<strong>生活指南还有各类校级文娱活动的预告</strong>。后者一定要试着参与一下，<strong>真的很丰富多彩！！</strong> 例如：<strong>周末航影（免费在校看电影）</strong> 就是在这里发的预告；周末航影每周都会选取一部电影 <em>（包好看，比如有一次放的是《爱乐之城》）</em> 在学校的咏曼剧场放映，投票选电影和抽票的消息都是在这发的。还有<strong>厨艺课堂</strong>，教各位做甜点、咖啡、饺子等等的，有兴趣也可参与。有时还有剧团&#x2F;乐团进校园等活动。<strong>而这些例子只是校级文娱活动的一小部分！</strong></li>
<li><strong>智慧北航</strong>。<strong>在用统一认证账号登陆后才可使用，这个各位新同学弄好账号之后就能访问了，稍安毋躁</strong>。一个集成服务平台，查成绩等很方便。</li>
<li><strong>航财通</strong>微信公众号。不关注不行啊，你<strong>充饭卡</strong>就在这充！</li>
<li><strong>北航后勤服务中心</strong>微信公众号。主要是<strong>停电、停水等通知</strong>。</li>
<li><strong>北航教务处</strong>微信公众号。主要是教务有关的通知，比如<strong>四六级有关事项，选课通知，考试通知等</strong>。</li>
<li><strong>北航总务</strong>公众号。类似于北航后勤中心，但是这里有<strong>交电费的入口，比较方便。</strong></li>
<li><strong>全球北航</strong>公众号。各类<strong>留学、交换</strong>计划都会在上面宣传，有需求的同学可以看看</li>
<li>各类社团的公众号。这个要看对哪个社团感兴趣。到时候各学生社团会进行宣传（“百团大战”），到时候现场扫码加就可以了。</li>
<li><strong>北航社团中心</strong>。主要是社团（如：“百团大战”日期）相关事宜。</li>
<li><strong>北京航空航天大学学生会</strong>。各大校内活动在上面都有通知，对学生会工作感兴趣的也可以加。</li>
<li><strong>北航学生艺术团</strong>。艺术演出的活动公告一般都是在这里发布的，抢票信息也是！</li>
<li><strong>北京航空航天大学校医院</strong>。在校医院看病的时候可能用得上。</li>
<li><strong>北航图书馆</strong>。可以操作续借等图书馆有关事务。当然在i北航 App&#x2F;北航小程序上也可以做。</li>
<li><strong>北京航空航天大学</strong>公众号。这里主要是对外宣传为主，如果对校级大新闻感兴趣可以关注一下。往常开学期间也会发机场&#x2F;火车站到北航的路径，摆渡车时刻等交通信息，可以留意一下。</li>
<li>（谨慎选择）（非官方）“北航微生活”微信公众号。这是别人写的推荐之一，算是一个非官方的表白墙。本人没加过，不喜欢表白墙这类形式的我也不建议加。</li>
</ul>
<h3 id="两个神奇的非官方论坛"><a href="#两个神奇的非官方论坛" class="headerlink" title="两个神奇的非官方论坛"></a>两个神奇的非官方论坛</h3><p><strong>伴航</strong>：<a href="https://banhang.lyhtool.com:8001/">https://banhang.lyhtool.com:8001</a>  ，据观察里面有不少6系同学</p>
<p><strong>航鸟小窝</strong>：<a href="https://buaa.live/bbs/">https://buaa.live/bbs/</a>  ，不过这个才建好不久，人气较上面那个冷清不少</p>
<h3 id="教务处官网"><a href="#教务处官网" class="headerlink" title="教务处官网"></a>教务处官网</h3><h4 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h4><p>上面会公示<strong>转专业的相关事宜（如果有这个打算的话）</strong>（注，这个需要有统一身份认证账号后才能查，各位新同学弄好账号之后就能查了，稍安毋躁），也可以查询<strong>各个专业的培养方案（对后面专业分流有用）</strong>。后续的选课等，也是要在教务系统里操作的。</p>
<p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/20240806174303.png" alt="image.png"></p>
<p>各专业的培养方案，可以在主页的“培养指南”栏目中查询，会对后面的<strong>专业选择</strong>有所帮助。</p>
<p>至于<strong>大类</strong>的培养方案？这个小弟似乎没有查到过，十分抱歉（</p>
<h4 id="教务系统"><a href="#教务系统" class="headerlink" title="教务系统"></a>教务系统</h4><p><strong>（再次，注，这个需要有统一身份认证账号后才能访问，各位新同学弄好账号之后就能访问了，稍安毋躁）</strong></p>
<h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>在校内的话，是可以在教务处首页点”本研教育管理系统“直接进去的。但在校外不行，需要多一个步骤——由北航VPN访问。</p>
<ul>
<li><p>首先要进入北航官网（<a href="http://www.buaa.edu.cn),在导航栏点”常用链接“,再点”vpn系统“./">www.buaa.edu.cn），在导航栏点”常用链接“，再点”VPN系统“。</a><br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/20240806175433.png" alt="image.png"></p>
</li>
<li><p>进入界面以后，随便选一个即可。此处以VPN4为例。<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/20240806175510.png" alt="image.png"></p>
</li>
<li><p>随后需要用统一身份认证账号登陆。<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/20240806175554.png" alt="image.png"></p>
</li>
<li><p>登陆后，在资源列表里找到”教务处官网“，或在搜索框直接搜”教务“。<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/20240806175748.png" alt="image.png"></p>
</li>
<li><p>随后就进入了教务处的官网，点击本研教务管理系统，就可以正常用账号登入教务系统了。如果遇到这个界面，选新版系统入口就好了。<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/20240806175932.png" alt="image.png"></p>
</li>
</ul>
<h4 id="正文-3"><a href="#正文-3" class="headerlink" title="正文"></a>正文</h4><p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/20240806180116.png" alt="image.png"></p>
<p>相信在日后，<strong>辅导员</strong>等会给出教务系统如何使用的更详细指南。本文主要是教各位怎么用教务系统查开课方案，课程等信息。</p>
<p>信息的获取主要在”查询“一栏。<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/20240806180616.png" alt="image.png"></p>
<p>查询各专业和学院的开课计划这些，主要在”执行教学计划查询“里看。对于大类，院系选择<code>“[70]北航学院”</code>，其它专业的则根据不同专业对应的学院来选择就可以了。这个主要是后面选专业的时候，可以看看要上的课自己满不满意（笑）<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/20240806181826.png" alt="image.png"></p>
<h2 id="有关四、六级"><a href="#有关四、六级" class="headerlink" title="有关四、六级"></a>有关四、六级</h2><p>在大一的时候，我推荐各位就把四六级解决了——大一上干四级，大一下干六级。</p>
<p>说实话，<strong>除了听力</strong>，四六级真不难。阅读题等等，在我感觉看来，就跟高考英语是一个水平。除了题型有所变化以外，难度跟高考英语其实是很相近的，大家<strong>不要对四六级太害怕，干就完事了！</strong></p>
<p>为什么要强调“除了听力”？因为听力可以算是整套题最难的了：高考题是把问题印上卷子的，而四六级的听力要你<strong>先听完全文，再听问题，然后作答</strong>。更难的是，<strong>文章&#x2F;语段大部分只读一遍！</strong></p>
<p>这部分的解法，有两个。一个适用于记性好的同学，就是先<strong>专心</strong>听完全文，期间不要<strong>看选项分神</strong>，再听问题，按印象作答——有一点挑战性。还有一种就是边听边看选项，听的时候发现关键字，就在对应选项旁边标记一下（手速快还可以多写点提示词）；最后听选项的时候，在标记了的选项里面选就好。<em>由于我一般用第一个办法，其他办法我并不是很了解；更好的办法，可能就要另请高明了</em></p>
<p>因此，我的四六级备考建议是：真题看看熟悉题型就行，<strong>重点练听力</strong>。</p>
<h2 id="有关体育锻炼"><a href="#有关体育锻炼" class="headerlink" title="有关体育锻炼"></a>有关体育锻炼</h2><p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/20240806192608.png" alt="image.png"></p>
<p>北航有个叫<strong>TD线</strong>的特色项目，此外还要求各位进行体育活动的<strong>阳光打卡</strong>。TD一天可打3次，阳光打卡一周只能打4次，具体要求在打卡页面就能看到。一个学期的要求据说是TD+阳光打卡共48次，其中必有32次TD+16次阳光打卡。但是为保安全，我建议TD也刷到48次。</p>
<p>TD线通法可视个人喜好而言。想有一定锻炼量可以老实过各项项目；只为了刷完也可以摸鱼一路走过去。<strong>这两个算是正当的方法，不正当的方法就不说了，好孩子不要学（</strong></p>
<p>而且，在各位军训完之后，我建议休整好就尽快弄完，<strong>以防期末忙的时候忘记，导致体育课白扣10分！</strong></p>
<p>此外，有不少体育活动可以<strong>加TD次数</strong>。比如我们这一届在大一上的运动会时，有一个太极扇的表演项目；报名参加的同学，最后都<strong>喜提了48次TD次数。</strong></p>
<h2 id="有关沙河美食"><a href="#有关沙河美食" class="headerlink" title="有关沙河美食"></a>有关沙河美食</h2><p>各位还是要在沙河待个两个星期的。是时候分享一点自己有限的美食储备了：</p>
<p>注意，这里主要是中晚餐。北航食堂在早餐卖的<strong>基本都是包子等面食</strong>，仅有少数窗口卖面、馄饨之类（如西区1f的一个窗口），可能需要各位适应一下。</p>
<ul>
<li><p>西区：只推荐-1f的清真食堂与1f的食堂。</p>
<p>清真食堂可吃<strong>刀削面（现做），盖饭，炒饭，炒菜</strong>。<br>刀削面8元一位，好吃但分量较少；盖饭本人推荐黄焖牛肉（17.8一份）和普通的牛肉盖饭（可自选搭配蔬菜，15一份）；炒饭和刀削面在一个窗口，各个口味都不错，10块一位；炒菜本人力推<strong>小炒羊肉和金蛊牛肉（如果还有的话）</strong></p>
<p>1f我主要是吃早餐：推荐<strong>叉烧包，白菜肉包子，燕麦包</strong>。早餐我一般是两个包子+一碗豆浆。</p>
</li>
<li><p>东区：仅推荐3f的鼓瑟轩。如果各位军训的时候只能在东区解决饮食的话，那就将就吃1f&#x2F;3f的菜吧，没办法了（</p>
</li>
</ul>
<p>至于学院路的？孩子才搬过来，还不知道有啥好吃的，再探完了再报😋</p>
<h2 id="信类只有计算机一个”好“选择？"><a href="#信类只有计算机一个”好“选择？" class="headerlink" title="信类只有计算机一个”好“选择？"></a>信类只有计算机一个”好“选择？</h2><p>答案很简明：<strong>不是</strong>，而且现在选计算机<strong>也不见得是好选择</strong>。</p>
<p>此处且借梦拓培训时，上一届学长的分享内容一用（注：国奖 &#x3D; 国家奖学金）；<strong>里面的一些错误观点也可供各位参考</strong>：<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/20240806194045.png" alt="image.png"><br>计算机<strong>人才过饱和</strong>，这已经是不争的事实了；<strong>上一个出现这种情况的叫土木工程。</strong></p>
<p>【[打灰爱音&#x2F;填词] 搅拌机下——“不提桶跑路已是我最后仅存的善良”】 <a href="https://www.bilibili.com/video/BV1eM4m1m74i">https://www.bilibili.com/video/BV1eM4m1m74i</a></p>
<p>不妨把这首二创歌曲的对应部分改成计算机对应的内容，说不定你能发现周围人吹嘘计算机和曾经吹嘘土木的一些相似之处？（笑）</p>
<p>薪资呢？如果你觉得干开发就能赚大钱的话，不妨打开一个叫Boss直聘的软件，搜一下热门的前&#x2F;后端开发的普遍薪资是多少。总之是<strong>不存在</strong>”一毕业就有40w薪资“这种事情的。</p>
<p><strong>也许各位的确是奔着6系（计算机）来到北航的。但是，希望在大一这一年里，你能找到自己真正喜欢的专业方向，在大一下专业分流的时候，找到真正适合自己，且自己真心喜欢的选择。</strong></p>
<p><strong>千万不要按着分数选专业。</strong> 就像上文截图，这种想法反而是<strong>分数禁锢了自己</strong>。选自己<strong>真心喜欢</strong>的才重要。更何况，北航这几年的大类招生已经<strong>相对理性</strong>了许多：这一次的大类分流，6系甚至招到了全年级700名（23级大类内共有1000余人），应该不会再出现往年300名都挤不进6系的”盛况“了。</p>
<p><strong>更何况，信类的优势专业也不止计算机一个。</strong> </p>
<p>电子信息工程学院（2系）和自动化科学与电气工程学院（3系，但是注意”电气工程“只有空壳，<strong>千万别选</strong>）也是本校的强项，在师资、设备、资源等方面都不比计算机学院差。<strong>如果你再留心看看北航被评上院士的各位教授的院系，更会发现，院士全在计算机外的其他院系，2系和3系（e.g. 23年刚评上的郭雷院士、焦宗夏院士）就有。</strong> 此外，如果你成绩亮眼的话，进2&#x2F;3系福利也有不少：例如2系可以进<strong>北斗实验班（约等于院士班？）</strong>，3系对大类前200名分进的同学<strong>有保研上的优惠</strong>，<strong>更能提早选科研导师，在大二就能接触科研项目</strong>，岂不美哉？</p>
<p>其它的系呢？也有强的啊！仪器光电与科学学院（17系）实力也十分不错，在这方面北航可谓在全国占有绝对优势，<strong>不要因为报考的同学普遍成绩较差就不选它</strong>；还有一个集成电路学院（41系），师资也不错，在学院路的一号楼地下修了一个<strong>智能微纳中心，设备之齐全令人发指</strong>，保研也很方便。（常见问题：2&#x2F;41二者差别？这个建议以<strong>大一下的专业宣讲</strong>为主进行参考，这里我就不多嘴了。）</p>
<p>总之，希望各位在<strong>大一下</strong>的时候能多参与一下各学院的专业宣讲，对大类里各个专业都<strong>有了明确的认识之后，再做选择</strong>。</p>
<p>除此之外，各位在开学的时候会被要求选一个学业导师。这个制度有一个好，就是可以通过导师举办的<strong>导学活动认识各个学院</strong>。我当时就是报了41系的郑翔宇老师，得以参观41系的微纳中心。<strong>如果你现在对某个学院感兴趣，不妨到时候选一个来自该学院的老师。</strong></p>
<p><strong>此外，选好导师可能会有你意想不到的福利！我有一位同学，当时选了3系的yjs老师；然后一次导学活动，他们导学小组竟然能有体验747-400型客机全动模拟驾驶舱的机会，这个机会加钱都不一定能有！！！当时的我，看到的时候眼都馋哭了😭</strong></p>
<p>顺带一提，上文截图的”21系“是软件学院。某种意义上，6&#x2F;21二者差不多。硬要比就是毕业得的学位，师资这方面的差别。</p>
<p>这一部分，我想借用一位我很尊崇的长者的话作结：<strong>“一个人的命运啊，当然要靠自我奋斗，但是也要考虑到历史的进程。”</strong></p>
<h2 id="北京”航空航天“大学？"><a href="#北京”航空航天“大学？" class="headerlink" title="北京”航空航天“大学？"></a>北京”航空航天“大学？</h2><p>进入北航信类的你，肯定时常会想：”<strong>航空航天</strong>“跟我<strong>信类</strong>学生有啥关系？宣传这个有什么用？</p>
<p><strong>是有的。</strong> 上一栏提到的2系、3系干的活很多都跟航空航天有关。就以3系为例，无人机系统、飞行控制就是3系的主要业务范围。航空机载设备跟17系关系很密；雷达等电子设备，战机隐身和反隐身是2系的业务范围，等等…就连规模相对较小的41系，在研究的MRAM的主要用途也是抗辐射的航空航天机载设备。</p>
<p><strong>我想报6系，那又有啥关系呢？</strong> 航电设备难道不用写程序？（笑）。而且飞机设计这些是需要电脑跑流体仿真的，这个又能牵扯到计科的高性能计算（HPC）领域，又怎么能说无关呢？</p>
<p>也许你对”航空航天“四字无感，或对信类有关航空航天的宣传感到不解。<strong>我能理解这种感受，这是非常正常的，特别是被6系的金子招牌吸引而进入北航的各位同学</strong>。</p>
<p>但是，身为一名航空爱好者（兼半个伪航天迷？航天我了解真不多，2333），我希望各位还是能给”航空航天“四字一点尊重，<strong>更需要尊重那些愿意在沙河待上4年、7年乃至更久的航类同学；因为他们确实是抱着对航空航天事业的热爱而选择的航类，并为这份伟大的事业做出了不少的牺牲。</strong></p>
<p>哪怕各位可能会觉得自己读的应该叫“知春路计算机应用学院”，但别忘了国内最权威的航空学术期刊《航空学报》是哪个单位主办的。</p>
<p>这部分就写到这吧。可能各位对上述观点不大认同，那也没关系，就当是我对校内一些不良风气发的牢骚即可；但，如果各位认同小弟上述愚见的话，小弟自是非常感激。</p>
<h2 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h2><p>这篇私货就写到这吧。如果日后有想到什么，再写点东西发给各位看官（</p>
<p>本来是想再写写自我介绍的，但是时间实在紧迫……先这样吧，过几天我再写一个有关我自己的碎碎念。</p>
]]></content>
      <categories>
        <category>梦拓相关</category>
      </categories>
      <tags>
        <tag>梦拓</tag>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>OO_U2 - HW7简要总结</title>
    <url>/2025/04/17/OO_U2%20-%20HW7%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>讨论区已有一众仙人分享了自己的实现，但我认为我有在降低修改复杂度上更进一步的办法。</p>
<p>考虑到本次作业为本单元的最后一次作业，我的修改方法更注重于<strong>降低修改的复杂度，可能存在部分性能的牺牲。</strong> 在各位进行参考时，请注意这一点。</p>
<p>本人实现的亮点在于：UPDATE请求的处理，与双轿厢目标楼层的规避，<strong>全部利用线程交互实现</strong>。</p>
<span id="more"></span>
<h1 id="支持UPDATE请求"><a href="#支持UPDATE请求" class="headerlink" title="支持UPDATE请求"></a>支持UPDATE请求</h1><h2 id="特殊请求由谁分给电梯？"><a href="#特殊请求由谁分给电梯？" class="headerlink" title="特殊请求由谁分给电梯？"></a>特殊请求由谁分给电梯？</h2><p>针对上一单元的SCHE请求与本单元的UPDATE请求，<strong>我都选择交由<code>Dispatcher</code>实例进行处理。</strong></p>
<p>原因无他，为了减少进程交互的复杂性。 我的电梯运行线程<code>Scheduler</code>与电梯信息类<code>Elevator</code>是分离的，我希望<code>Elevator</code>只有<code>Dispatcher</code>与<code>Scheduler</code>两者在竞争。</p>
<p>这两类特殊请求都将直接加入请求池。那我们怎么保证Dispatcher优先处理这两种特殊请求呢？</p>
<p>答案是，将请求池改为用<strong>优先队列</strong>实现。这是因为，<strong>优先队列的比较条件（提供了Comparator接口）可以自行实现</strong>，这为我们当前情况的需求提供了极大的便利。</p>
<p>我们需要保证：</p>
<ul>
<li>SCHE&#x2F;UPDATE请求在优先队列的首位</li>
<li>剩下的普通请求在后面。</li>
</ul>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;SubRequest&gt; &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(SubRequest o1, SubRequest o2)</span> &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">o1Index</span> <span class="operator">=</span> calcIndex(o1);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">o2Index</span> <span class="operator">=</span> calcIndex(o2);  </span><br><span class="line">        <span class="keyword">return</span> o1Index - o2Index;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcIndex</span><span class="params">(SubRequest subRequest)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (subRequest.isSche()) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (subRequest.isUpdate()) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 按你自己的方法，处理普通请求！</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Dispatcher从头遍历优先队列时，我们此时即可保证特殊请求被优先处理。</p>
<h2 id="UPDATE请求的处理"><a href="#UPDATE请求的处理" class="headerlink" title="UPDATE请求的处理"></a>UPDATE请求的处理</h2><p>现在，我们的UPDATE请求放在了Dispatcher处理；此时，聪明的你不难发现一些问题：</p>
<ul>
<li>在UPDATE请求处理完成前，Dispatcher是不是会被阻塞，不能分配其他请求？</li>
<li>UPDATE显然需要一个<strong>类似总控的东西，来控制有关的交互</strong>；这个总控难道就是Dispatcher线程本身？</li>
</ul>
<p>这样肯定不对。<strong>因此，我们在Dispatcher内引入一个子进程，作为UPDATE请求处理的“总控”。</strong></p>
<p>这个子线程怎么创建呢？<strong>使用Lambda表达式，可以快速创建新线程</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">th</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">    <span class="comment">// Do something!</span></span><br><span class="line">&#125;);  </span><br><span class="line">th.start();</span><br></pre></td></tr></table></figure>

<p>这样，Dispatcher线程就可在处理升级请求的过程中，继续分配其他可分配的请求，而不会发生阻塞。</p>
<p>如果你不放心，还可以用<code>th.join()</code>，在Dispatcher线程的某处，强制处理UPDATE请求的子线程完成后，再继续执行。</p>
<p>总控与两台待升级的电梯的整体交互逻辑如下：</p>
<ul>
<li>告知两台电梯需要升级，<strong>等待两电梯就绪</strong></li>
<li><code>Scheduler</code>读取<code>Elevator</code>中信息，得知电梯需要升级，进行疏散乘客等“预处理”操作</li>
<li>处理完成后，通知总控该电梯已就绪，<strong>等待总控对其进行升级</strong></li>
<li>总控在两台电梯均就绪后，输出<code>UPDATE-BEGIN</code>，随后修改电梯的运行属性，完成升级</li>
</ul>
<p>具体实现上，我的电梯信息类<code>Elevator</code>采用了<code>ReentrantLock</code>实现锁管理，上文中的两个等待，我们通过创建两个<code>Elevator</code>锁的<code>Condition</code>实现。</p>
<p>电梯如何指示自己已就绪？我采取给电梯增加一个<code>UPDATE</code>运行状态；在电梯完成了“预处理”后，电梯就将进入这一运行状态，并使用<code>Condition.signal()</code>唤醒总控。</p>
<p>下述伪代码仅作示意之用。更进一步的细节，需要各位根据自己的架构实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Elevator</span><br><span class="line">ReentrantLock lock;</span><br><span class="line">Condition schedulerUpdateCond = lock.newCondition()</span><br><span class="line">Condition dispatcherUpdateCond = lock.newCondition()</span><br><span class="line"></span><br><span class="line">setUpdateStatus() &#123;</span><br><span class="line">		this.status = new Status(&quot;UPDATE&quot;);</span><br><span class="line">		this.dispatcherUpdateCond.signal();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">updateA() &#123; // updateB()同理</span><br><span class="line">	// 修改属性，并将电梯运行状态设为IDLE</span><br><span class="line">	this.schedulerUpdateCond.signal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Scheduler</span><br><span class="line">elevator.lock.lock();</span><br><span class="line">...</span><br><span class="line">if (elevator.shouldUpdate()) &#123;</span><br><span class="line">	evacuatePassengers();</span><br><span class="line">	elevator.setUpdateStatus;</span><br><span class="line">	elevator.schedulerUpdateCond.await();</span><br><span class="line">	elevator.respondUpdate; // 解除指示电梯需要升级的flag</span><br><span class="line">	// await()结束后，电梯已被更新为新的状态，按照原有的运行逻辑运行即可！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Dispatcher</span><br><span class="line">Thread th = new Thread(() -&gt; &#123;  </span><br><span class="line">    Elevator elevA, elevB;</span><br><span class="line"></span><br><span class="line">	// 由两层await()，实现两电梯均就绪后再继续</span><br><span class="line">    elevA.lock.lock();</span><br><span class="line">    if(elevA.getStatus() != &quot;UPDATE&quot;) &#123;</span><br><span class="line">	    elevA.dispatcherUpdateCond.await();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	elevB.lock.lock();</span><br><span class="line">    if(elevB.getStatus() != &quot;UPDATE&quot;) &#123;</span><br><span class="line">	    elevB.dispatcherUpdateCond.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// UPDATE-BEGIN</span><br><span class="line">		//重新分配被取消RECEIVE的请求</span><br><span class="line">		elevA.updateA();</span><br><span class="line">		elevB.updateB();</span><br><span class="line">	// UPDATE-END</span><br><span class="line"></span><br><span class="line">	// 放elevA/B的锁</span><br><span class="line">&#125;);  </span><br><span class="line">th.start();</span><br></pre></td></tr></table></figure>

<h2 id="“三角死锁关系？”"><a href="#“三角死锁关系？”" class="headerlink" title="“三角死锁关系？”"></a>“三角死锁关系？”</h2><p>看到上面的实现后，聪明的你不难发现，这一实现中，如果调度策略是影子电梯，总控、<code>Scheduler</code>、<code>Dispatcher</code>三者都可能争夺<code>Elevator</code>的锁，很容易出现死锁，不是吗？</p>
<p>事实上，只要锁管理得够好，这个问题仍然是可以避免的。下面，我将从这三个竞争者在处理UPDATE请求的情况下，分析如何避免“三角死锁”。</p>
<ul>
<li>Dispatcher:（事实上，关键的只有这一处）<br>在进行普通请求分配时，先判断当前电梯的是否仍在响应UPDATE请求（<strong>这一判断不获取电梯的锁</strong>），再获取锁</li>
<li>Scheduler&#x2F;总控：<code>await()</code>在开始等待前会自动放锁，等待结束后会自动重新获得锁；仔细观看上面的实现，你会发现，冲突此时并不存在！</li>
</ul>
<h1 id="楼层冲突规避"><a href="#楼层冲突规避" class="headerlink" title="楼层冲突规避"></a>楼层冲突规避</h1><h2 id="基本分析"><a href="#基本分析" class="headerlink" title="基本分析"></a>基本分析</h2><p>很遗憾，我们不能通过不到“目标楼层”的方法，规避楼层冲突的问题，否则全部都被改造成双轿厢，且目标楼层均在同一层时，会导致跨越目标楼层的请求全部无法完成。</p>
<p>产生冲突的情况，我们大致可以分为三类：</p>
<ul>
<li>相向而行：两电梯同时将要到达目标楼层</li>
<li>同向而行：一个电梯尚未完全离开目标楼层，而另一电梯即将到达</li>
<li>一动一静：一个电梯闲置于目标楼层，或正在目标楼层下客，而另一电梯即将到达</li>
</ul>
<p>在我的实现中，与电梯移动有关的逻辑是这样，相信各位的实现与其大同小异：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Scheduler </span><br><span class="line">while (true) &#123;</span><br><span class="line">	elevator.lock.lock;</span><br><span class="line">	try &#123;</span><br><span class="line">		if (/*一般情况*/) &#123;</span><br><span class="line">			normSchedule();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		// 以防中途开锁</span><br><span class="line">		if(elevator.lock.isHeldByCurrentThread()) &#123; elevator.lock.unlock(); &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">normSchedule() &#123;</span><br><span class="line">	if (elevator.status == RUNNING)</span><br><span class="line">		runningSchedule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runningSchedule() &#123;</span><br><span class="line">	elevator.lock.unlock();</span><br><span class="line">	// 唤醒Dispatcher；开锁是为了允许Dispatcher此时为其分配可加入的请求</span><br><span class="line">	sleep(speed);</span><br><span class="line">	elevator.lock.lock();</span><br><span class="line">	// 更改楼层</span><br><span class="line">	// 输出ARRIVE</span><br><span class="line">	// 判断下一步状态：是下客的WAITING，还是继续RUNNING？</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了防止不必要的判断，这一判断只应在<strong>当前电梯即将进入目标楼层时进行。</strong></p>
<p>在判断之前，我们自然<strong>要获取对方电梯的锁，以免对方电梯的状态在判断时改变。</strong></p>
<p>观察我们上面实现的锁管理情况，我们不难发现：</p>
<ul>
<li>为了避免死锁，我们尽量确保一个线程一次只拿一把锁；</li>
<li><code>runningSchedule()</code>中恰好有一个开锁的窗口，为一次只拿一把锁提供了可能</li>
<li>对方电梯正前往目标楼层时，由于我们上面的锁机制，<strong>读取到的对方当前楼层，一定是目标楼层的前一层</strong></li>
<li>在对方电梯的当前楼层为目标楼层时，读出的状态不可能为<code>RUNNING</code>，只可能为闲置的<code>IDLE</code>，或正在下客的<code>WAITING</code></li>
</ul>
<p>因此，上述三种冲突情况，我们只需要对“相向而行”这一情况特殊考虑；其余情况，都可以通过判断对方当前位置是否为目标楼层判断。</p>
<p>“相向而行”特殊在哪呢？特殊在<strong>无法直接确定需要等待的电梯</strong>。其他两种情况中，我们可以确定等待的是当前不在目标楼层的电梯，这一情况不行。</p>
<p>对此，我规定：<strong>下方的电梯，规避上方的电梯。</strong></p>
<p>为了减少复杂度，我并没有考虑轿厢中乘客的问题，性能可能因此下降；如各位希望争取这一部分性能，可以以这一条件为最低级条件，将轿厢内请求加入判断条件中。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>自然，为了避免死锁，我们的判断放在在<code>runningSchedule()</code>那一开锁的窗口内。</p>
<p>下文中以<code>cooper</code>称呼对方电梯。（coop-er，能想出的最简洁称号就这个了，笑）</p>
<p>为双轿厢电梯单独写一套运行逻辑自然不大明治。我们将这一判断逻辑融入原有的运行逻辑中，判断<strong>只在电梯已被改造为双轿厢（对方电梯<code>cooper !=null</code>）时</strong>进行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">runningSchedule() &#123;</span><br><span class="line">	elevator.lock.unlock();</span><br><span class="line">	// 唤醒Dispatcher；开锁是为了允许Dispatcher此时为其分配可加入的请求</span><br><span class="line">	</span><br><span class="line">	if (elevator.willEnterTargetFloor &amp;&amp; cooper != null) &#123;</span><br><span class="line">		cooper.lock.lock();// 获取对方的锁</span><br><span class="line">		judge(); // 判断</span><br><span class="line">		// 放锁；这样放锁当然有目的，详见下文</span><br><span class="line">		if(cooper.lock.isHeldByCurrentThread()) &#123;cooper.lock.unlock(); &#125; </span><br><span class="line">	&#125;</span><br><span class="line">	sleep(speed);</span><br><span class="line">	elevator.lock.lock();</span><br></pre></td></tr></table></figure>

<p>电梯避让的等待&#x2F;唤醒，使用挂在电梯信息类<code>Elevator</code>的锁上的Condition实现，命名为<code>conflictCond</code>。</p>
<p>整体交互如下：</p>
<ul>
<li>在判断出我方需要等待后，我方执行<code>conflictCond.await()</code>，同时通知对方需要规避</li>
<li>通知对方规避时，唤醒对方的Scheduler，以处理对方正处在IDLE，Scheduler正休眠的问题</li>
<li>每当对方<strong>远离目标楼层</strong>时，就让对方执行我方方法<code>conflictCond.signalAll()</code>，唤醒等待冲突解除的我方。</li>
</ul>
<p>随后，我们就可得出如下判断逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">judge() &#123;</span><br><span class="line">	if (elevator.isElevB()) &#123; // 是在下方的B电梯  </span><br><span class="line">	    switch (cooper.getStatus().getStatusType()) &#123;  </span><br><span class="line">	        case RUNNING:  </span><br><span class="line">		        // 相向而行</span><br><span class="line">	            if (cooper.getFloorBeforeTargetFloor() == cooper.getCurrentFloor() </span><br><span class="line">	                &amp;&amp; cooper.towardsTargetFloor()) &#123;  </span><br><span class="line">	                cooper.setAvoid();  // 通知对方规避</span><br><span class="line">	                cooper.lock.unlock();  // 避免同时获取两把锁</span><br><span class="line">	                elevator.lock.lock(); // 没锁就await()，会发生什么？ </span><br><span class="line">	                elevator.conflictCond.await();  </span><br><span class="line">	                elevator.lock.unlock();  </span><br><span class="line">	            &#125;  </span><br><span class="line">	            break;  </span><br><span class="line">	        default: break;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	// 其他情况</span><br><span class="line">	if (cooper.getCurrentFloor() == cooper.getTargetFloor()) &#123;  </span><br><span class="line">	    cooper.setAvoid();  </span><br><span class="line">	    cooper.setUnlock();  </span><br><span class="line">	    elevator.lock.lock(); </span><br><span class="line">	    elevator.conflictHangUp();  </span><br><span class="line">	    elevator.lock.unlock();  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断写好之后，该通知对方规避了，响应机制当然也得有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Elevator</span><br><span class="line">public void setAvoid() &#123;  </span><br><span class="line">    this.awaitingAvoid = true;  </span><br><span class="line">    this.idleCall();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void respondAvoid() &#123;  </span><br><span class="line">    this.awaitingAvoid = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改完这些还不够，我们需要对WAITING&#x2F;IDLE两个状态的转移规则稍加修改，使得在一动一静的情况下，两种状态转移后，可以响应规避请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">waitingSchedule():</span><br><span class="line"></span><br><span class="line">... // 原有实现</span><br><span class="line">// 接在原有实现之后</span><br><span class="line"></span><br><span class="line">if (entersIdle) &#123;</span><br><span class="line">	if(shouldAvoid) &#123;</span><br><span class="line">		/*让电梯移动到下一层，类似SCHE，但到了之后不开门*/</span><br><span class="line">		respondAvoid()</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		setIdle()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idleSchedule(): </span><br><span class="line">if (keepsIdle) &#123;</span><br><span class="line">	if (shouldAvoid) &#123;</span><br><span class="line">		/*让电梯移动到下一层，类似SCHE，但到了之后不开门*/</span><br><span class="line">		respondAvoid()</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// 原逻辑</span><br><span class="line">	&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于同向而行的情况，我们还需要继续修改RUNNING下的运行逻辑，使得避让请求被正确响应：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">runningSchedule() &#123;</span><br><span class="line">	... // sleep()完成</span><br><span class="line">	/*更改楼层*/</span><br><span class="line">	/*在楼层更改时，若远离了目标楼层，暂存一个flag*/</span><br><span class="line">	.... // 状态转移</span><br><span class="line">	// normSche原有逻辑结束</span><br><span class="line">	if (flag) &#123;</span><br><span class="line">		elevator.setUnlock(); // 同样，此处开锁是为了保证一个线程只拿一把锁</span><br><span class="line">		respondAvoid()</span><br><span class="line">		cooper.lock.lock();</span><br><span class="line">		cooper.conflictCond.signal();</span><br><span class="line">		cooper.lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">	// 需要Scheduler线程的`while(true)`处能够正确处理中途开锁的锁释放问题，可以看看本文前面的实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做到这里，我们就成功的使用纯线程交互的方法，完成了楼层冲突的处理，<strong>不需要引入任何新的类来进行管理。</strong></p>
<h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><p>再次，我们本单元求稳为先，选择的方法<strong>不一定最优</strong>。</p>
<p>我的原调度逻辑（见<a href="http://lajipz.top/2025/04/17/OO_U2%20-%20HW5,6%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/">HW5，6总结</a>）类似影子电梯，在出现双轿厢的时候也犯了难。比起编写新逻辑，我选择最大程度复用原有的调度逻辑。</p>
<p>在原有的调度基础上，我们<strong>需要添加是否在运营范围内的判断。</strong></p>
<p>调度第一步，沿用原有逻辑，<strong>对所有电梯</strong>评估请求是否可分配，选评价指数最低者。</p>
<p>同时，在这一步中，<strong>记录下所有的双轿厢电梯。</strong> </p>
<p><strong>此处记录的并不是双轿厢电梯对，而是其中的每一个电梯。</strong> 例如：2、3是一对双轿厢电梯，我们这里记录的是：<code>电梯2、电梯3</code>，而不是<code>[电梯2，电梯3]</code>。</p>
<p>若第一步未能分配，则进行第二步，<strong>“拆请求”</strong>。在第二步中，我们只对<strong>双轿厢</strong>电梯进行评估。</p>
<ul>
<li>将原有请求，以当前评估电梯的目标楼层为节点，按先后顺序分成两段；</li>
<li>在第一段请求完成后，再由Dispatcher分配第二段请求。</li>
</ul>
<p>“拆请求”如何实现？我们需要修改我们已有的乘客请求类<code>passengerRequest</code>，在其属性中加一个<code>passengerRequest followingRequest</code>，存储当前请求的后半段。</p>
<p>在下电梯的时候，需要判断是否包含后续请求，有则<code>OUT-F</code>，并将后续请求放回请求池，没有则<code>OUT-S</code>。</p>
<p><strong>判断是否可加入，与计算代价指数的逻辑不变。</strong> 不过，我们选取电梯的逻辑发生了变化，选取优先级如下：</p>
<ul>
<li>可行楼层跨度最大</li>
<li>原设计中，评估指数最小者</li>
</ul>
<p>选取楼层跨度最大者，是因为，我们无法保证后续换乘的次数；换乘可能会造成额外的等待时间，且额外等待时间难以预知。楼层跨度尽可能大，可以尽可能减少换乘次数，一定程度缓解这一问题。</p>
<h1 id="线程交互"><a href="#线程交互" class="headerlink" title="线程交互"></a>线程交互</h1><p>不难注意到，对于双轿厢电梯对的其中一个电梯，在IDLE，无请求，且closed的条件下就结束，在这里肯定不对劲。不这样的话，目标楼层的冲突没法规避。</p>
<p>我采取了一个相对粗糙的办法：</p>
<ul>
<li>电梯的<code>close()</code>由Dispatcher调用，这是我的原有设计</li>
<li>在close时，Dispatcher用一<strong>不加锁的方法</strong>，获取当前所有电梯的状态；只在所有电梯都处在IDLE状态时，才将所有电梯<code>close()</code>，否则<code>wait()</code></li>
<li>保证电梯在进入IDLE时，会唤醒Dispatcher</li>
</ul>
<p>至此，我们完成了HW7所需的所有改造。</p>
]]></content>
      <categories>
        <category>课程相关</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>OO_U2 - 电梯</title>
    <url>/2025/04/17/OO_U2%20-%20%E7%94%B5%E6%A2%AF/</url>
    <content><![CDATA[<p>这是一篇导航帖。</p>
<p>本单元任务较忙，故我没有时间整合出一篇概括所有内容的文章。</p>
<p>博客周作业做了一些概括，但是我觉得里面我自己省掉了不小好玩的细节。</p>
<p>以下文章均与本单元有关，欢迎各位按需查阅：</p>
<ul>
<li><a href="https://bbs.csdn.net/topics/619679170?spm=1001.2014.3001.6377">CSDN上的博客周作业</a></li>
<li><a href="http://lajipz.top/2025/04/17/OO_U2%20-%20HW5,6%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/">HW5，6总结</a></li>
<li><a href="http://lajipz.top/2025/04/17/OO_U2%20-%20HW7%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/">HW7总结</a></li>
<li><a href="http://lajipz.top/2025/04/17/%E4%BD%BF%E7%94%A8ReentrantLock%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E9%94%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/">ReentrantLock使用</a></li>
<li><a href="http://lajipz.top/2025/04/17/%E5%9C%A8IDEA%E5%86%85%E9%83%A8%EF%BC%8C%E8%BF%9B%E8%A1%8C%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E6%AD%BB%E9%94%81%E8%B0%83%E8%AF%95/">利用IDEA查死锁</a></li>
</ul>
<span id="more"></span>
<h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><h2 id="单元前序知识：Java多线程"><a href="#单元前序知识：Java多线程" class="headerlink" title="单元前序知识：Java多线程"></a>单元前序知识：Java多线程</h2><p><code>synchronized</code>关键词有三种可能的修饰对象：</p>
<ul>
<li>实例方法：<code>public synchronized void method() &#123;&#125;</code>；<br>锁<strong>实例（this）的锁</strong>，或者说，<strong>对象锁。</strong><br>其他线程在该锁释放前，无法访问<strong>该实例的<code>synchronized</code>方法</strong>（言下之意，非<code>synchronized</code>可以访问）</li>
<li>静态方法：<code>public static synchronized void method()&#123;&#125;</code><br>锁定<strong>类</strong>，锁定后，其他线程无法访问该类的<code>sync</code>方法</li>
<li>代码块：锁<strong>对象锁</strong>，和第一个一致。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void method() &#123;</span><br><span class="line">	synchronized (Object) &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="对象锁的行为"><a href="#对象锁的行为" class="headerlink" title="对象锁的行为"></a>对象锁的行为</h2><p>经过实验，发现：</p>
<ul>
<li>在对象锁被一个进程占用时，其他线程无法访问该对象的<code>synchronized</code>方法，<strong>但可以访问没加<code>sync</code>的方法，甚至由此对对象的属性进行更改</strong></li>
<li>在<code>Obj</code>的对象锁被一个进程占用时，其他线程在执行到<code>synchronized (Obj) &#123;&#125;</code>代码块处会被阻塞。</li>
<li>对象锁针对的是<strong>对象</strong>，而不是<strong>方法</strong>；因此，调用一个sync方法<code>method1()</code>，<code>method1()</code>又调用另一sync方法<code>method2()</code>，是<strong>不会被阻塞的</strong>，因为当前线程一直拿着对象的锁。可能会带来预期外的不阻塞</li>
</ul>
<h2 id="wait-，notifyAll"><a href="#wait-，notifyAll" class="headerlink" title="wait()，notifyAll()"></a><code>wait()</code>，<code>notifyAll()</code></h2><p><code>Obj.wait()</code>会暂停线程A（A此时拥有<code>Obj</code>的锁）的执行，直到另一线程B使用<code>Obj.notifyAll()</code>将其唤醒。</p>
<p>同时，<code>Obj.wait()</code><strong>会释放线程A拥有的<code>Obj</code>锁</strong>。</p>
<p><code>notify()</code>会<strong>随机唤醒</strong>等待池中的<strong>一个</strong>程序，而<code>notifyAll()</code>是<strong>全部</strong>唤醒。</p>
<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p>涉及<code>Runnable</code>的太复杂，我们选择直接<code>extends Thread</code>，随后重写<code>run()</code>实现启动线程。</p>
<p>只有<code>start()</code>会创建新线程，<code>run()</code>只会顺序执行代码块。</p>
<h2 id="确定要保护的方法"><a href="#确定要保护的方法" class="headerlink" title="确定要保护的方法"></a>确定要保护的方法</h2><p>在一个对象里，如果出现了要多线程共享的属性，那引用该属性的方法<strong>全部都要保护</strong>。</p>
]]></content>
      <categories>
        <category>课程相关</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>OO_U2 - 电梯</title>
    <url>/2025/05/13/OO_U3%20-%20JML/</url>
    <content><![CDATA[<blockquote>
<p>本文就是本人的博客作业。本单元除了优化方法外乏善可陈，因此我没什么额外要说的。</p>
</blockquote>
<span id="more"></span>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本单元以一个简单的社交网络为背景，要求各位同学按照题目给出的JML规格，进行规格化开发。</p>
<p>此外，本单元中还要求各位同学对部分关键方法构建JUnit单元测试，同时也引导了同学们利用大模型辅助规格化开发。</p>
<h1 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h1><h2 id="不同类别的测试"><a href="#不同类别的测试" class="headerlink" title="不同类别的测试"></a>不同类别的测试</h2><p>按照要求，我们把集中类型的测试先简要介绍一遍：</p>
<ul>
<li>单元测试：从开发者角度，对最小可测试单元的测试，比如方法</li>
<li>功能测试：从用户角度，对程序的某个特定功能进行测试</li>
<li>集成测试：各个功能组合起来，整体进行测试</li>
<li>压力测试：集成测试上更进一步，以大数据量&#x2F;多边界条件等，测试程序的性能和正确性</li>
<li>回归测试：在原有程序基础上进一步开发后，测试修改后程序是否保证原有功能的正确性</li>
</ul>
<p>这集中测试，在我看来，是软件开发的不同阶段进行的：</p>
<ul>
<li>单元、功能、集成测试：在开发过程中进行，旨在验证当前完成的开发工作是否正确</li>
<li>压力测试：在开发工作已有整体成果后进行，旨在验证Corner Case等严格条件下的正确性&#x2F;效率</li>
<li>回归测试：在原有基础上继续开发后进行，旨在验证原有功能不受新增功能影响</li>
</ul>
<h2 id="数据构造策略"><a href="#数据构造策略" class="headerlink" title="数据构造策略"></a>数据构造策略</h2><p>我选择使用数据生成器，并按照一定的指令出现权重来随机生成指令。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">possible_instructions = [</span><br><span class="line"><span class="string">&quot;ap&quot;</span>, <span class="string">&quot;ar&quot;</span>, <span class="string">&quot;mr&quot;</span>, <span class="string">&quot;at&quot;</span>, <span class="string">&quot;dt&quot;</span>, <span class="string">&quot;att&quot;</span>, <span class="string">&quot;dft&quot;</span>,</span><br><span class="line"><span class="string">&quot;qv&quot;</span>, <span class="string">&quot;qci&quot;</span>, <span class="string">&quot;qts&quot;</span>, <span class="string">&quot;qtav&quot;</span>, <span class="string">&quot;qba&quot;</span>, <span class="string">&quot;qcs&quot;</span>, <span class="string">&quot;qsp&quot;</span>,</span><br><span class="line"><span class="string">&quot;coa&quot;</span>, <span class="string">&quot;doa&quot;</span>, <span class="string">&quot;ca&quot;</span>, <span class="string">&quot;da&quot;</span>, <span class="string">&quot;foa&quot;</span>, <span class="string">&quot;qbc&quot;</span>, <span class="string">&quot;qra&quot;</span>,</span><br><span class="line"><span class="string">&quot;am&quot;</span>, <span class="string">&quot;arem&quot;</span>, <span class="string">&quot;afm&quot;</span>, <span class="string">&quot;aem&quot;</span>, <span class="string">&quot;sm&quot;</span>, <span class="string">&quot;sei&quot;</span>, <span class="string">&quot;dce&quot;</span>,</span><br><span class="line"><span class="string">&quot;qsv&quot;</span>, <span class="string">&quot;qrm&quot;</span>, <span class="string">&quot;qp&quot;</span>, <span class="string">&quot;qm&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">weights = [</span><br><span class="line"><span class="number">12</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="comment"># ap, ar, mr, at, dt, att, dft</span></span><br><span class="line"><span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="comment"># qv, qci, qts, qtav, qba, qcs, qsp</span></span><br><span class="line"><span class="number">8</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="comment"># coa, doa, ca, da, foa, qbc, qra</span></span><br><span class="line"><span class="number">10</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="comment"># am, arem, afm, aem, sm, sei, dce</span></span><br><span class="line"><span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span> <span class="comment"># qsv, qrm, qp, qm</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>注意到，本单元作业的输入，可能存在以下情况：</p>
<ul>
<li>增删密集型（频繁<code>ap/mr/coa</code>等）</li>
<li>查询密集型（频繁<code>qtvs/qcs/qsp/...</code>）</li>
<li>上述两者兼备</li>
</ul>
<p>我们由此可以对应调整数据生成器中，各类指令的权重，以生成多种情况下的测试数据，补足随机测试过于随机的短板。</p>
<h1 id="大模型辅助"><a href="#大模型辅助" class="headerlink" title="大模型辅助"></a>大模型辅助</h1><p>本单元中，我主要利用大模型，辅助了<strong>规格阅读、自动测试</strong>两个部分。</p>
<p>当前的大模型在具备了思维链等技术后，<strong>并不需要过多的提示词，多了反而会影响模型的表现。</strong> 我们要做的，就是<strong>给足大模型需要参考的信息</strong>。就本单元而言，大模型需要的信息，无非指导书，以及各个文件里存放的JML规格。</p>
<p>如果需要模型按某个流程执行任务，再在提示词里面描述清楚自己想要的流程，就可以了。</p>
<h2 id="规格阅读"><a href="#规格阅读" class="headerlink" title="规格阅读"></a>规格阅读</h2><p>随着大模型的日趋成熟，以及JML语料每年的增长，当前的大模型已经可以做到：用户用极少的提示词，给足必要的信息，即可让大模型在JML有关问题上，输出质量较高的结果。</p>
<p>以下是我使用Deepseek辅助阅读JML的一次尝试；其输出结论确与规格描述的结果一致。</p>
<p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/defa235b050fdc689ac5e48c8d368341.jpg" alt="defa235b050fdc689ac5e48c8d368341.jpg"></p>
<p>考虑到AI输出有时仍不可靠，在本单元中，我均采用了先本人阅读一遍规格，得出规格想要规定的结果后，再让AI阅读一遍，随后将自己的结论与AI的结论进行比较的模式，以确保我对规格的理解正确。</p>
<h2 id="自动测试"><a href="#自动测试" class="headerlink" title="自动测试"></a>自动测试</h2><p>在第二单元尝到了利用已有评测机框架，由AI代劳数据生成与Checker的甜头后，我在本单元继续延续了这一自动测试思路。</p>
<p>具体而言，我向AI提交了这些输入：</p>
<ul>
<li>课程指导书（通过网页审查元素，可以得知其存在一个<code>content.json</code>中）</li>
<li>存有规格内容的各个<code>.java</code>文件，合并为一个文本文档，规避AI工具的文件上传次数限制</li>
<li>示例<code>datagen.py</code>与<code>checker.py</code>，旨在让AI在已有评测机接口下，编写数据生成与正确检查器</li>
<li>一定的提示词</li>
</ul>
<p>本单元中，我的提示词如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请参考main.txt中，各类的JML规格描述及Runner类的行为，以及exception.txt中各种异常的输出，参考content.json中指导书的数据范围限制，为我编写本次作业的数据生成器（datagen）与正确性检查器（checker）。上传的datagen与checker作为示例，你需要保留其中的接口。</span><br></pre></td></tr></table></figure>


<p>而在第二单元，一次作业的指导书，依赖上一次作业的指导书补全不变的设计要求的情况下，我的提示词是这样的；此时，我在文件中上传了各次作业的指导书。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请帮我生成一个第七次作业的数据生成器（datagen）和正确性检查器（checker）；你应该先查看第五、第六次作业，再查看第七次作业在先前两次作业上做的修改，再开始工作；我已附上写好的datagen和checker，请仿照其格式进行编写。</span><br></pre></td></tr></table></figure>

<p>在自动生成datagen&#x2F;checker的过程中，我尝试了Deepseek-R1&#x2F;Gemini 2.5 Pro&#x2F;o3-mini等模型，均能取得一定成果。生成的datagen一般不存在问题，但生成的Checker虽整体框架无误，但在边界条件的检查上往往会存在疏漏。</p>
<p>针对这个问题，我选择“边测试，边修改”：在出现Checker报错时，先检查我自己的程序是否有问题，在确认自己的程序无误后再检查checker的问题。如果修改起来很方便，自己改了即可，不方便则直接指出问题，让AI工具进行修改。这一模式我已在多次作业中确认可行，且获得了可观的成果，可以在后续的第四单元继续使用。</p>
<p>生成的datagen出问题的情况也存在，主要表现在部分指令不在生成范围内。这个问题，一般给AI指出问题，并让其修正即可。（假设之前你已经给足了参考信息）</p>
<h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><p>实不相瞒，这单元的架构已经给定了设计，可发挥的空间并不大，也没有什么重复介绍的必要。这一部分介绍的，主要是优化方法。</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>这主要是为<code>isCircle()</code>方法服务。我们需要快速判断关系图内，两个人是否连通。诚然，使用BFS更通用，但是利用并查集，查找的最好情况，复杂度可以达到<code>O(1)</code>。</p>
<p>具体而言，就是对于关系图内各节点（人）进行聚类：</p>
<ul>
<li>每个聚类，选取一个节点作为代表</li>
<li>每个节点记录自己所在聚类的代表</li>
<li>通过比较每个节点的代表是否相等，得出二者是否在一个聚类内</li>
<li>一个聚类中，可以保证各节点关系连通</li>
</ul>
<p>注意到，并查集的维护是个严重的问题。我选择在Network内维护一份完整的关系图，同时引入脏位机制；在发生关系删除时，脏位置高；在查询时，若脏位有效，则按照关系图重建并查集。</p>
<p>并查集内部引入<strong>路径合并</strong>，以及<strong>按节点数的启发式合并</strong>，避免退化成链表带来的性能下降。</p>
<h2 id="脏位"><a href="#脏位" class="headerlink" title="脏位"></a>脏位</h2><p>众所周知，当我们修改了一个状态后，只要我们不查询它，我们是不知道它改变了的！</p>
<p>因此，我们引入脏位：</p>
<ul>
<li>对于某个不好维护的状态</li>
<li>状态受到影响，要发生改变，且有其他信息知道如何改变时，<strong>不改变状态，而是把脏位置1</strong></li>
<li>在查询状态时，若脏位有效，则按照其他信息重建状态，否则直接返回状态</li>
</ul>
<p>利用这一思路的方法：</p>
<ul>
<li><code>queryCoupleSum()</code> ，在关系权重发生变化时，难以一下就得知配对数变化</li>
<li><code>getBestContributor()</code>，文章删除导致贡献变化，不遍历很难得知最佳贡献着</li>
<li><code>queryBestAcquaintance()</code>，在关系权重发生变化时，不遍历当前熟人，很难得知最佳熟人</li>
</ul>
<h2 id="动态维护"><a href="#动态维护" class="headerlink" title="动态维护"></a>动态维护</h2><p>在我们向一个集合加入一个元素时，我们便可动态维护一个集合整体的属性，从而避免查询该属性时遍历整个集合，导致效率下降的问题。</p>
<p>以<code>queryTagValueSum()</code>为例，每发生一次关系的加入&#x2F;更改&#x2F;删除，Tag内的valueSum属性就对应进行加减。</p>
<p><code>queryTagVar()</code>思路与之类似，不再赘述。</p>
<h2 id="链表的维护"><a href="#链表的维护" class="headerlink" title="链表的维护"></a>链表的维护</h2><p>主要是为了处理<code>queryReceivedArticle()</code>。</p>
<p>在文章发生删除时，我们需要对Person接到的该文章进行删除。链表的删除一直是个问题，一般采取遍历链表，找到目标再删除的方法；很显然，在链表大小较大时，如此删除的开销实在太大。</p>
<p>而且，包装好的LinkedList中的方法，无法做到高效移除链表中所有符合某一规则的元素。在这个情况下，我们希望一下移除链表中，所有文章ID为指定值的节点。</p>
<p>注意到，对于双向链表，如果已知要移除的节点，那么，只需修改其前后节点的连接即可，时间复杂度可以做到<code>O(1)</code>，十分诱人；由此，我萌生了一个想法：在原有双向链表的基础上，再使用哈希表+链表，记录一个文章ID值对应的所有节点。时间复杂度是O(n)，不过n取决于已有的同文章ID节点数，相较遍历整个链表，效率也已经足够了。</p>
<p>随后，我自行实现了一个<code>IndexedLinkedList</code>类，实现了上述思路。较我原有的实现方法，这么做的时间、空间复杂度均有所下降。原有思路见下文“性能优化”。</p>
<p>这么做的性能瓶颈，在于额外HashMap的维护。</p>
<h2 id="杂项-增量化开发"><a href="#杂项-增量化开发" class="headerlink" title="杂项 - 增量化开发"></a>杂项 - 增量化开发</h2><p>众所周知，解引用、条件分支等等都是有时间开销的；为了尽可能减少这一开销，我们引入“增量式编程”。</p>
<p>举一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两次解引用开销</span></span><br><span class="line"><span class="type">int</span> <span class="variable">var1</span> <span class="operator">=</span> persons.get(id).getVar1();</span><br><span class="line"><span class="type">int</span> <span class="variable">var2</span> <span class="operator">=</span> persons.get(id).getVar2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次解引用</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> persons.get(id);</span><br><span class="line"><span class="type">int</span> <span class="variable">var1</span> <span class="operator">=</span> p.getVar1();</span><br><span class="line"><span class="type">int</span> <span class="variable">var2</span> <span class="operator">=</span> p.getVar2();</span><br></pre></td></tr></table></figure>

<p>这能够带来一定程度的效率提升。</p>
<h2 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h2><p>上面提到，我在选择带索引双向链表前，使用了另外一个方法，这里简要做一个介绍。</p>
<p>既然链表删除要遍历，<strong>那我可不可以不删呢？</strong> 答案是可以的。</p>
<p>注意到，<code>articles</code>容器只可能有两种操作：</p>
<ul>
<li>在头部插入新节点</li>
<li>删除容器中所有ID为特定值的节点</li>
</ul>
<p>且：</p>
<ul>
<li>在ID为特定值的所有节点删除后，后续仍有可能加入ID位为该值的节点</li>
<li>删除和加入不可能同时发生</li>
<li>删除的区间，和删除后新加入的区间不相交</li>
</ul>
<p>因此，我们可以：</p>
<ul>
<li>链表只增不删</li>
<li>用一个<code>HashMap&lt;Int, Int&gt;</code>，记录当前链表中，一个ID有效节点的个数</li>
<li>每加入一个节点，对应ID有效次数加1，没有键值就设为1</li>
<li>全部删除时，直接撤销键值对应</li>
</ul>
<p>并在<code>query/getReceivedArticle</code>处动手脚：</p>
<ul>
<li>从头遍历，对于某个ID的节点，以HashMap对应键值，作为遍历中，读取该ID节点的次数</li>
<li>若次数&lt;&#x3D;有效节点数，则认为该节点有效，将其加入返回的容器中</li>
<li>若次数大于有效节点数，则认为该节点是被删除操作删除的操作，忽略之，从下一个节点继续遍历</li>
</ul>
<p>这样就可以规避删除的遍历问题。</p>
<p>但是，这么做有两个严重的问题：</p>
<ul>
<li><strong>内存溢出</strong>：这一机制对链表只加不减，得亏强测强度仍然不算大，不然这样是有可能MLE的</li>
<li>极端情况：考虑两个节点之间，间隔了数量极大个无效节点；这样的话，我们遍历的效率会急剧降低，且这一代价<strong>每次查询都存在</strong>，我们无法保证这种情况不发生</li>
</ul>
<p>因此，我换到了上面使用带索引双向链表的方法。换了之后，对于Hw10的强测测试点，不仅有时间效率的提升，也解决了上面两个严重的问题。</p>
<h1 id="对规格的理解"><a href="#对规格的理解" class="headerlink" title="对规格的理解"></a>对规格的理解</h1><p>在谈这些问题之前，我们需要明确，<strong>规格描述的是什么？</strong> 事实上，<strong>规格描述的是方法执行后的结果，而非方法执行的过程</strong>。</p>
<ul>
<li>规格中出现的“过程”，可以认为是测试流程，也可以认为是用来描述结果的过程。</li>
<li>规格中出现的容器实现等等，<strong>只是为了举例描述一个结果</strong>，可以认为其实现是一个抽象概念</li>
</ul>
<p>因此，我们能发现一个显而易见的结论：<strong>规格不规定达到结果的过程</strong>，规格与实现分离因此合理，我们自然也可以在实现过程这一部分自由发挥，只要保证结果符合规格即可。</p>
<h1 id="JUnit有关"><a href="#JUnit有关" class="headerlink" title="JUnit有关"></a>JUnit有关</h1><p>我认为测试可以分为两部分，一是不同测试上下文，二是<strong>方法自身</strong>的正确性检验。</p>
<p>我们先谈方法正确性检验的部分吧。</p>
<p>上面提到，规格中出现的”过程“，可以认为就是测试流程。因此，按照规格中描述的过程来编写测试，即可保证测试通过与符合规格等价，这是最简单的办法。</p>
<p>当然，我们也可以根据规格描述的结果，以另一个测试流程来检验；不过，既然规格已经告诉你测试流程了，<strong>除非这一新的测试流程，在保证检测正确性的前提下，效率更快， 我们没有不按照规格给的测试流程编写测试的理由。</strong></p>
<p>综上，<strong>照抄规格</strong>，就是实现方法正确性检验的最简便方法。在这个选择下，“Junit测试检验代码实现与规格的一致性的效果”这个问题更不成立，因为我们的method测试流程，本来就是跟规格描述完全一致的。</p>
<p>方法正确性检验后，就是<strong>构建不同的测试上下文了</strong>，换言之，构造测试数据。事实上，我在本单元作业对JUnit的测试中出现的问题，都是因为构建的测试数据不够强大，未能考虑到部分边界条件。</p>
<p>那我们怎么知道要考虑什么边界条件？这就是“利用规格信息”要做的了。我们需要从规格中得知：</p>
<ul>
<li>待测试方法要求哪些属性不变，要变的属性怎么变</li>
<li>待测方法涉及的属性，会受其它什么方法的影响</li>
</ul>
<p>明确好这两点后，我们基本就能找出所有的边界条件了。</p>
<h1 id="本单元学习体会"><a href="#本单元学习体会" class="headerlink" title="本单元学习体会"></a>本单元学习体会</h1><h2 id="算法的重要"><a href="#算法的重要" class="headerlink" title="算法的重要"></a>算法的重要</h2><p>如果说前两个单元是为了考察同学们对程序整体架构的设计能力，这个单元考察的就是：同学们在架构确定的前提下，进行具体实现的能力。</p>
<p>长期以来，我都对算法不甚重视，期望用架构或多线程等方法，代替算法解决问题。<strong>本单元打消了我这一错误的偏见，让我真正认识到了算法的重要性。</strong></p>
<p>具体而言，查询关系是否连通这一问题，在并查集以外，我实在想不出效率更高的办法，这就是算法影响程序效率的一个实例。</p>
<h2 id="测试的重要性"><a href="#测试的重要性" class="headerlink" title="测试的重要性"></a>测试的重要性</h2><p>本单元开始的第一次作业，我认为严格按照规格描述的结果实现，就不会产生问题，我因此没搓评测机。然后在强测就出现了问题，最后检查发现，是自己的一处愚蠢的笔误（笑，把value赋值到id上）造成的；在有评测机的情况下，这个问题很好发现，但我没搓评测机，这个问题我就没发现。</p>
<p>自此以后，我每单元都搓一次评测机，避免这种事情再次发生；后面也确实没有发生过。</p>
<p><strong>时刻认为自己写的程序有Bug，</strong> 这个思维模式还是很重要的。</p>
<h2 id="JML为何难以推广？"><a href="#JML为何难以推广？" class="headerlink" title="JML为何难以推广？"></a>JML为何难以推广？</h2><p>形式化验证的需求的确很小，但我认为JML难以推广，是<strong>可读性出了问题</strong>。</p>
<p>我们简要比较一下，几种语言如何描述结果：</p>
<p>自然语言：操作后，id1对应成员的 | 包含id2对应的成员的 | 所有tag内，不再包含id2对应的成员</p>
<p>JML语言：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@ ensures  (\forall <span class="type">int</span> i; <span class="number">0</span> &lt;= i &amp;&amp; i &lt; getPerson(id1).tags.length;  </span><br><span class="line">@                      \old(getPerson(id1).tags[i].hasPerson(getPerson(id2)))==&gt;!getPerson(id1).tags[i].hasPerson(getPerson(id2)));</span><br></pre></td></tr></table></figure>

<p>（伪）数学语言：<br>$$\forall t \in Persons[id1].Tags[], prev(t.hasPerson(id2))\rightarrow  !t.hasPerson(id2)$$</p>
<p>不可否认，自然语言在表达上最直观凝练，但是它无法避免产生歧义的问题；在形式化验证&#x2F;规格化开发等严谨的前提下，自然语言一般不被使用，或仅作为辅助说明出现。</p>
<p>这就是我们为何要引入规格语言。</p>
<p>但是，不难注意到，与我们上面的（伪）数学语言相比，描述相同的结果，JML语言花费了显然更多的篇幅；这是为什么？</p>
<p>一言以蔽之，<strong>JML的抽象程度还不够，没有脱离具体实现。</strong> 事实上，JML在尝试用一种基础的，具体的实现（比如容器认为是数组），或一种基础的，具体的过程（比如容器的查找过程），来尝试描述自己想要的结果。</p>
<p>在本人对形式化验证的简单了解后，我了解到了<code>TLA+</code>这门形式化验证语言。其<strong>完全基于数理逻辑</strong>，而非软件开发思想，从而做到了高度抽象、脱离具体实现。最后的描述效果，与我们上面随手写的（伪）数学语言基本一致，严谨而简明。</p>
<p>当一个工具带来的收益，远远小于其带来的负面影响时，是否采用它就很值得商榷了。JML确实做到了严谨描述结果，但其带来的可读性问题十分严重。与之比较，作为当前主流的形式化验证语言，TLA+采用了<strong>数理逻辑语言</strong>进行结果的描述；虽然有初始的学习成本，但其保证了描述的可读性。相信这就是JML难以推广的原因吧，<strong>这也让我认识到了选好工具的必要性。</strong></p>
<p>在研究这个问题的时候，我也再次感受到了 <strong>“抽象”</strong> 这一哲学，在计算机科学中的重要作用。抽象不仅有利于找出通用的解决方法，<strong>更有利于准确地描述问题。</strong></p>
]]></content>
      <categories>
        <category>课程相关</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>自己的碎碎念</title>
    <url>/2024/08/07/casualTalk/</url>
    <content><![CDATA[<p>在给各位塞的私货里面，我大段写了一些经验，自己这部分提的不多；故这里再多闲聊一点，让各位能对我大一经历了什么有点了解（笑）</p>
<span id="more"></span>
<h1 id="学业"><a href="#学业" class="headerlink" title="学业"></a>学业</h1><p>本人现就读与计算机学院（6系）的计算机科学与技术专业。</p>
<p>那么，我是大佬吗？<strong>我不是。</strong> 专业分流时，本人成绩<strong>年级排名491&#x2F;1034，分进6系的时候排名是171&#x2F;190+。</strong> 成绩就自爆到下面吧，大家感兴趣可以看（bian）看（shi）:<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/20240807211353.png" alt="image.png"></p>
<p>如各位所见，真不行。</p>
<p>真要反思是怎么回事的话，<strong>可能</strong>是大一上&#x2F;大一下的前半学期过于放纵，<strong>天天都抽时间打电动导致的</strong>。这就导致时间不大充足，数分&#x2F;基物<strong>作业写不及只能抄</strong>，引起了一系列后果。各位<strong>如果十分重视学业，千万引以为戒，</strong> 北航这个<strong>大一</strong>虽然可以比高中放松一点，但还是可以当<strong>高四</strong>读的。（唉大类招生）</p>
<p><strong>但也侧面说明了，其实现在大类招生也理性了很多，不用太“卷”就能整到自己想要的专业。</strong></p>
<p>说来也惭愧，本人这几科里最亮眼的是<strong>英语</strong>。算是唯一可以吹嘘的资本（笑）</p>
<h1 id="为什么选6系？"><a href="#为什么选6系？" class="headerlink" title="为什么选6系？"></a>为什么选6系？</h1><p><strong>兴趣使然居多。</strong> 主要是，孩子从小学就一路在打电脑兼折腾电脑，这方面兴趣浓郁不说，有关计算机的大部分术语我也算熟悉。</p>
<p><strong>编程严谨而言不在我的兴趣范围内</strong>，就当是系统学习计算机知识必须要承担的代价吧。因此各位在大一觉得对编程没兴趣的话，也不要因此对选6系有所顾虑。</p>
<p>我是一开始就决定报6系的吗？<strong>算是，也算不是。</strong> 算是的原因是，我高考填志愿的时候确实是奔着6系的名头，把信息类放到了第一志愿；算不是的原因是，我在大一的时候，对选哪个专业的思想有非常严重的波动。</p>
<p>这里就谈谈这个波动吧。也算是一点分流经验分享？</p>
<p>一开始是因为参观了41系的微纳中心，又看到学校方面的资源给的非常足，加上自己<strong>某种意义上也算是对计算机硬件感兴趣，而对软件不感兴趣</strong>而有了选41的想法。</p>
<p>提到41就不能不提2。为什么2不在考虑范围？因为我的认知是，41偏重CPU之类的大型芯片工程（这里姑且忽略一下41的器（cai）件（liao）和工艺装备系），而2偏重的是MEMS，FPGA之类的小器件，这个我不感兴趣。而且我觉得MEMS这类的市场早就饱和了（虽说需求还是旺的）</p>
<p>2还有个方向是电磁场。由于大一下我基物学得比较痛苦（某种意义也可以怪当时上电磁场这部分的zy老师上得过于无趣），加上数学不好，这个我觉得不行。</p>
<p>而且，打算去41&#x2F;2，我为啥不在高考填志愿的时候填UESTC？</p>
<p>然后有了<strong>编程激发不了自己兴趣，之后学着估计吃力的想法</strong>。在这个想法的驱使下，我拷问了自己报北航的目的是什么：说起来你可能不信，我最开始萌生报北航的意愿，<strong>是航空！</strong> <strong>欸！恰好我自己对航空的兴趣这么多年还真没减退，要不我准备大二转去隔壁5系吧！</strong> <strong>听起来确实很荒谬，但我当时确实就是这么想的！连假期补上工图之类的计划都做了。</strong></p>
<p>这个影响还是有点大的。其一就是转专业的分数要求只要加权平均达到80即可，我有一段时间的学习方针就是<strong>不要太卷，能把平均分保住80分以上就可以了，到时候转去5系即可。当然这个方针对我后续的学习有不小的影响，间接促成了数分、离散、基物比较糟糕的成绩。</strong></p>
<p>最后是怎么想的呢？住七年沙河算是一个劝退点（<strong>实话实说，我觉得沙河校区内的各项环境其实都不错，北京城逛个两三次基本就腻了，沙河的确是潜心治学的一个好去处</strong>）。还有就是转专业太麻烦的问题。</p>
<p>还有一个，就是我觉得我国在航空方面已经够先进了。C919的翼型我认为已经足够完美，歼20的气动设计等等都足够先进，读5系毕业之后，以后估计没我的事。<em>换句话说，喜欢坐冷板凳，但航空的板凳已经够热了？233333</em></p>
<p><strong>还有就是我数学不行。航空对数学要求还是高的，不信请自行了解一个叫Navier-Stokes方程的东西。</strong></p>
<p>然后我又把目光投向了3系，准确来说是305。为什么呢？因为它们说是自动化，实际上飞控，无人机基本就是他们在干。师资力量也雄厚，而且航天口的活也有在干。控制工程我觉得也是个足够吸引我的领域。<strong>进3系算是可以把我的计算机+航空两个爱好能有机地联系起来。</strong></p>
<p><strong>顺带一提，各位选专业的时候，不妨进各学院的官网，看看博士生&#x2F;硕士生导师的师资团队，对学院各个老师的大致研究方向有个概念。当时我就是这么了解41&#x2F;3系的。当时看到305老师的研究课题很多契合我兴趣的时候，我那叫一个激动啊（</strong></p>
<p>那最后为什么不去？还是数学的锅，自动控制原理我觉得对我来说还是有点挑战…</p>
<p>其实我最后还是在3跟6之间摇摆不定，想的就是靠专业系统抽奖。第一志愿考虑初心写的是计算机，第二志愿就是自动化，然后系统抽到了计算机。<strong>嗯，就这样吧</strong></p>
<p>对了，说到志愿、计算机等等，又想起一个事情，<strong>我为什么要选北航？</strong></p>
<p>高考填志愿的时候，我是可以挑战一下南大计算机的。但是，<strong>一是自己对航空的兴趣，二是北京的地理位置，三是危险的可能</strong>促成了我选北航。</p>
<p>第一个就不在这细说了，我们谈第二个。南京我以前去玩过，吃的真不行，鸭血粉丝汤之类的我真吃不惯，而且据说南大食堂也不行；北京能吃的就多得多。<strong>而且有一个重要影响因素，就是北京是全国拍飞机最好的地方之一（其它还有上海、成都等），而南京就没什么好拍的。</strong> <strong>北京人文等方面的优势就不说了，不言自明。</strong></p>
<p>危险的可能是什么呢？当时南大的计算机和天坑专业是放在一起的（好像是环境？），而且我的分数也是刚够到南大的门槛。考虑到这种危险性，我还是放弃填报南大的计算机，选择了北航。</p>
<p>现在我后悔吗？<strong>我不后悔。</strong> 倒是从铁了心读计算机的角度，还是有点后悔的。个人觉得6系开课的质量不如南大。南大的计算机教学我感觉还真优于6。要举例的话我就举南大的计算机系统基础课（PA）吧。<strong>我觉得那个才是我心目中读CS该上的课。</strong></p>
<p><strong>当然，上述仅供吐槽，大家看看乐子就好！千万不要跟着后悔啊23333，况且6系放眼全国而言也很不错了</strong></p>
<h1 id="有关英语"><a href="#有关英语" class="headerlink" title="有关英语"></a>有关英语</h1><p>既然是闲聊，那就多聊点吧233333</p>
<p>我觉得英语这方面我还是可以聊一点的，这里就分享一点我学英语的经历吧</p>
<p><strong>我其实没怎么刻意学过英语。我英语真的全靠打游戏学的。</strong> </p>
<p>这方面要从一个叫未转变者（Unturned）的游戏说起，我在小学四年级-六年级的时候玩得很多。当时这个游戏没有官方中文，<strong>汉化全靠民间汉化补丁。</strong> 但是！这个游戏经常更新新内容（好事），民间汉化自然是更不上更新的进度的，然后就会出现游戏界面<strong>中英掺杂的混乱情况。</strong></p>
<p>这TM能忍？某种意义上，我是有强迫症的，比如中英掺杂我看着就不爽 <em>（可能是这个的原因，我看着导员等天天说ddl这个词就非常的不爽，好好说截止日期会死？）</em> ，于是我一怒之下卸载了汉化，且不管当时的我看得懂不，直接<strong>上英语原版！</strong>影响其实也不大，因为各个功能的布局我都记着的。自此孩子打开了新世界的大门，在眼前看到的英语界面和记忆里汉化界面的中英对照下，我记下了不少有用的词。**</p>
<p>这个习惯延续到了我后面五年级开始打彩6的时候。<strong>某种意义上，是彩6把这个习惯发扬光大的。</strong> 因为当时的彩6中文字体有问题（尤其是数字），看着那叫一个难看；英语的字体就没问题。然后我就顺手把彩6的界面也调成全英了。<strong>欸！彩六这边有旁白且也是英语（旁白甚至还提供多种语言），旁白还带字幕，还有干员小故事，顺手学英语的条件那叫一个优越啊！</strong></p>
<p>后面就成瘾了。能调英语的界面我都尽量调（Windows这边，微软式中文功不可没）。硬要说原理就是创造一个能每天用英语的环境。<em>当然国产软件我不调，以微信等腾讯应用为例，那个英文翻的tm什么玩意</em></p>
<p>由于我复杂的成分，我无聊还有看Linus Tech Tips（加拿大白嫖王，在此顺便向NixieSub致敬一下），LGR，The 8-bit Guy之类的频道，现在想起来也对学英语有帮助？</p>
<p>然后再加上自己看到不认识的词就顺便记一下的习惯，还有看到东西就无聊想想英语对应什么词的神奇习惯，这英语就这么学会了（</p>
<p>说到背单词？初中轶事：当时我们英语课不准上课整英语以外的事情，我手上<strong>恰好有一本牛津高阶词典</strong>，然后我没事干就拿它翻着玩，看到我感兴趣且不认识的词就顺便记一下；某种意义上，这就等于背没难度上限的乱序版词汇书（<em>更直白一点，这不就tm背词典吗？</em>），词汇量确实是这么来的，2333333。当然现在没干了，也没这个时间和机会干了</p>
<p>另有一份写得稍微正式点的主观经验分享，详见博客，欢迎围观&#x2F;吐槽&#x2F;围攻（误）</p>
<p>就写到这吧。 </p>
]]></content>
      <categories>
        <category>梦拓相关</category>
      </categories>
      <tags>
        <tag>梦拓</tag>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>“法律、科技与社会”课后思考题答案 - 2024</title>
    <url>/2025/02/04/%E2%80%9C%E6%B3%95%E5%BE%8B%E3%80%81%E7%A7%91%E6%8A%80%E4%B8%8E%E7%A4%BE%E4%BC%9A%E2%80%9D%E8%AF%BE%E5%90%8E%E6%80%9D%E8%80%83%E9%A2%98%E7%AD%94%E6%A1%88%20-%202024/</url>
    <content><![CDATA[<p>本文记录了本人复习“法律、科技与社会”课程时，对课后思考题给出的答案。</p>
<p>众所周知，本课的期末考试就是从课后思考题中抽集体来考，怎么复习想必大家都知道了。当然，不知道这几个思考题之后会不会变。</p>
<p>以下答案均为本人手搓，在考试获得了95分，当然这个给分可能有玄学成分在里面，仅供参考。</p>
<h1 id="技术是中立的吗？为什么？"><a href="#技术是中立的吗？为什么？" class="headerlink" title="技术是中立的吗？为什么？"></a>技术是中立的吗？为什么？</h1><p>   不是。</p>
<ul>
<li>技术置身于社会中，具有社会性。</li>
<li>技术是占有世界的媒介，同时也是人类活动的一种形式。其背后包含了人类思维结果。</li>
</ul>
<span id="more"></span>

<h1 id="监控资本主义是一个不可避免的趋势吗？还是我们有什么办法改变它？"><a href="#监控资本主义是一个不可避免的趋势吗？还是我们有什么办法改变它？" class="headerlink" title="监控资本主义是一个不可避免的趋势吗？还是我们有什么办法改变它？"></a>监控资本主义是一个不可避免的趋势吗？还是我们有什么办法改变它？</h1><ul>
<li>用户行为数据将为资本带来利益；从资本逐利的本质而言，监控资本主义的趋势不可避免。</li>
<li>这一趋势可以被抑制。</li>
<li>立法与管制</li>
<li>提高公共意识与参与度</li>
<li>探索技术向善路径，减少技术对个人隐私的侵害</li>
</ul>
<h1 id="学校是否有权使用人脸识别对学生进行考勤？为什么？"><a href="#学校是否有权使用人脸识别对学生进行考勤？为什么？" class="headerlink" title="学校是否有权使用人脸识别对学生进行考勤？为什么？"></a>学校是否有权使用人脸识别对学生进行考勤？为什么？</h1><ul>
<li>自隐私方面：若学校方面明确了：1.收集的人脸识别信息仅用于考勤，2.且收集的信息将按照相关法律法规进行处理，3.并在事前提前征得了同学的同意，则这一方案可认为可行；</li>
<li>然而，根据我国目前出台的相关法律法规，此时也需保证人脸识别不作为考勤的唯一方式。</li>
<li>更严格而言，根据《个人信息保护法》，在公众场合所收集的身份信息只能用于维护公共安全目的，此时考勤并不在维护公共安全范围之内，故可以认为学校无权这么做。</li>
</ul>
<h1 id="什么是自动驾驶的电车难题？自动驾驶系统应该如何应对电车难题？"><a href="#什么是自动驾驶的电车难题？自动驾驶系统应该如何应对电车难题？" class="headerlink" title="什么是自动驾驶的电车难题？自动驾驶系统应该如何应对电车难题？"></a>什么是自动驾驶的电车难题？自动驾驶系统应该如何应对电车难题？</h1><ul>
<li>自动驾驶系统在事故不可避免时，是优先保全车上人员安全，还是行人等车外人员的安全。</li>
<li>首先是在技术上，要尽可能减少“不可避免事故”的发生；</li>
<li>其次，在设计自动驾驶系统时，应注意伦理方面的考量，确保系统决策符合人类伦理。</li>
</ul>
<h1 id="是否应该禁止或限制性爱机器人的研发、生产与销售？为什么？"><a href="#是否应该禁止或限制性爱机器人的研发、生产与销售？为什么？" class="headerlink" title="是否应该禁止或限制性爱机器人的研发、生产与销售？为什么？"></a>是否应该禁止或限制性爱机器人的研发、生产与销售？为什么？</h1><ul>
<li>是</li>
<li>存在物化女性的风险</li>
<li>有悖伦理</li>
<li>存在因此引起的技术以来与奴隶问题。</li>
<li>情感与亲密关系的简化。</li>
</ul>
<h1 id="什么是致命性自主武器？是否应该禁止或限制致命性自主武器的研发和使用？为什么？"><a href="#什么是致命性自主武器？是否应该禁止或限制致命性自主武器的研发和使用？为什么？" class="headerlink" title="什么是致命性自主武器？是否应该禁止或限制致命性自主武器的研发和使用？为什么？"></a>什么是致命性自主武器？是否应该禁止或限制致命性自主武器的研发和使用？为什么？</h1><p>   指无需有意义的人类控制即可选择目标并施加武力的系统。</p>
<p>   应该。</p>
<ul>
<li>道义角度：其决策远离了人的判断，在道义上这无法接受。</li>
<li>法律角度：其违背了《国际人权法案》和《武装冲突法》的精神，可能会对非作战人员产生杀伤。</li>
<li>战略角度：研发出的致命自主武器可能会扩散到潜在敌人中。</li>
</ul>
<h1 id="什么是算法歧视？形成的原因是什么？如果解决算法歧视问题？"><a href="#什么是算法歧视？形成的原因是什么？如果解决算法歧视问题？" class="headerlink" title="什么是算法歧视？形成的原因是什么？如果解决算法歧视问题？"></a><strong>什么是算法歧视？形成的原因是什么？如果解决算法歧视问题？</strong></h1><p>   算法歧视是指算法在决策过程中，偏向特定人群或不公平对待某些群体的现象。</p>
<p>   形成原因：</p>
<ul>
<li>数据偏差：算法主要依赖于测试数据；数据不全面，则算法可能会因此产生偏见。</li>
<li>设计偏见：开发者在设计算法时融入了个人偏见。</li>
<li>反馈循环：在一些算法系统中，用户行为会反馈到算法中，这可能扩大原有的偏见</li>
</ul>
<p>   改进方法：</p>
<ul>
<li>改进数据质量</li>
<li>提高算法透明度与解释性</li>
<li>引入公平性评估和偏差测试</li>
<li>用户反馈与持续优化</li>
</ul>
<h1 id="在人工智能和大数据时代，个人隐私还存在吗？如何才能更好地保护隐私？"><a href="#在人工智能和大数据时代，个人隐私还存在吗？如何才能更好地保护隐私？" class="headerlink" title="在人工智能和大数据时代，个人隐私还存在吗？如何才能更好地保护隐私？"></a>在人工智能和大数据时代，个人隐私还存在吗？如何才能更好地保护隐私？</h1><ul>
<li>存在。</li>
<li>个人角度：提高个人隐私意识，以正当手段维护自己的个人隐私</li>
<li>立法角度：完善相关法律法规，自法律角度约束个人敏感信息的使用</li>
<li>数据收集者角度：尊重用户隐私，避免过度收集用户敏感信息；完善技术手段，减少敏感信息的使用，避免敏感信息的泄露</li>
</ul>
<h1 id="作为计算机专业的学生，你如何看待人工智能的未来？"><a href="#作为计算机专业的学生，你如何看待人工智能的未来？" class="headerlink" title="作为计算机专业的学生，你如何看待人工智能的未来？"></a>作为<strong>计算机专业</strong>的学生，你如何看待人工智能的未来？</h1><ul>
<li>自生产工具的角度而言，人工智能将促进人类社会的生产力发展，从而促进人类社会的进步，我们应继续追求人工智能在技术层面的进步，从而进一步发展社会生产力；同时，我们也应积极接受并利用AI这一生产力工具。</li>
<li>自道德伦理角度而言，人工智能的使用，可能出现潜在的道德伦理问题，当前也出现了深度伪造、AI合成假新闻等问题。这需要我们在技术层面加以防范，；</li>
<li>自社会角度而言，人工智能必然会因人工智能的出现，对已有的部分人工进行替代。同时，人工智能的出现，也为我们带来了新的就业机会。因此，我们需要积极顺应这一变化，积极学习AI相关知识，同时提高自身创新能力与软实力。</li>
</ul>
]]></content>
      <categories>
        <category>课程相关</category>
      </categories>
      <tags>
        <tag>水课</tag>
        <tag>FKS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ReentrantLock，实现更灵活的锁管理策略</title>
    <url>/2025/04/17/%E4%BD%BF%E7%94%A8ReentrantLock%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E9%94%81%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<blockquote>
<p>本文是对OO第二单元总结的一部分。</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>众所周知，我们可以通过<code>synchronized</code>方法，以及<code>synchronized</code>代码块获取对象的锁；但是，你是否发现，这一做法有时并不灵活？</p>
<span id="more"></span>

<p>就以电梯为例，我们现在使用这么一个设计：电梯属性为一个类（Elevator），电梯的运行<strong>由一个排班器线程（ElevatorScheduler）</strong> 管理，乘梯需求的分配<strong>由一个调度器线程（Dispatcher）</strong>，根据电梯当前属性，决定是否分配给当前电梯：</p>
<p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020250331095642.png" alt="Pasted image 20250331095642.png"></p>
<p>两个线程自然会对Elevator产生竞争，我们想到的最简单解决办法，便是用<code>synchronized</code>块&#x2F;方法解决，对吧？这里以排班器为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ElevatorScheduler:</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (elevator) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (elevator.getStatus()) &#123;</span><br><span class="line">		<span class="keyword">case</span> IDLE: </span><br><span class="line">			idleSchedule();</span><br><span class="line">		<span class="keyword">case</span> RUNNING: </span><br><span class="line">			runSchedule();</span><br><span class="line">		<span class="keyword">case</span> WAIT: </span><br><span class="line">			waitSchedule();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dispatcher:</span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">synchronized</span> (elevator) &#123;</span><br><span class="line">		<span class="keyword">if</span> (elevator.canDispatch()) &#123;</span><br><span class="line">			elevator.addRequest(request);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们的电梯进入<code>WAIT</code>状态，执行<code>waitSchedule()</code>开门上下客的时候，我们自然希望：此时<code>Dispatcher</code>也可将能够加入的需求，放入电梯的请求表内。</p>
<p>但是在上面使用<code>synchronized</code>块的实现下，我们的希望会落空：此时<code>Elevator</code>锁被<code>ElevatorScheduler</code>持有，<code>Dispatcher</code>此时无法加入任何请求；为了保证两线程在读取<code>Elevator</code>状态的关键节点不出错，<code>synchronized</code>块似乎也不能去掉，减小<code>synchronized</code>块的颗粒度也不好实现。</p>
<p><strong>那么，有没有什么办法，能在进了<code>WAIT</code>状态后，让<code>ElevatorScheduler</code>暂时释放<code>Elevator</code>的锁，在<code>ElevatorScheduler</code>即将加入待乘需求的时候，又重新取回电梯的锁呢？</strong></p>
<p>是有的，这就需要用到我们今天的主角<code>ReentrantLock</code>。与<code>synchronized</code>类似，它也是一种<strong>互斥锁</strong>。在他的帮助下，我们可以突破<code>synchronized</code>关键字加锁的不少限制，为实现更灵活的锁管理提供可能。</p>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="构建与使用对象锁"><a href="#构建与使用对象锁" class="headerlink" title="构建与使用对象锁"></a>构建与使用对象锁</h2><p>我们在这里只介绍如何使用<code>ReentrantLock</code><strong>对一个对象加锁</strong>这一常见情况，其他情况欢迎各位自行查阅资料探索。</p>
<p>首先，我们需要将<code>ReentrantLock</code>作为对象的一个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elevator</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与<code>synchronized</code>块自动进行锁的获取与释放不同，我们需要<strong>显式通过<code>lock.lock()</code>与<code>lock.unlock()</code>两个方法，获取&#x2F;释放锁。</strong> </p>
<p>显然，我们此时的<code>lock</code>属性的权限是<code>private</code>（<del>你猜这限制哪来的？</del>）。在线程中每一次对其加锁时，都要先<code>ReentrantLock lock = elevator.getLock();</code>再<code>lock.lock();</code>并不美观，我们选择在<code>Elevator</code>类中实现<code>setLock()</code>与<code>setUnlock()</code>两个<code>public</code>方法。这样一来，对象外线程即可由这两个方法，获取该对象的锁。</p>
<p><code>ReentrantLock</code>还支持通过<code>isHeldByCurrentThread()</code>方法，查询当前线程是否持有锁；这为我们后续进行锁的管理提供了方便，建议用上。至于有什么用，请看后面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elevator</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLock</span><span class="params">()</span> &#123;  </span><br><span class="line">	    lock.lock();  </span><br><span class="line">	&#125;  </span><br><span class="line">	  </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUnlock</span><span class="params">()</span> &#123;  </span><br><span class="line">	    lock.unlock();  </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasReentrantLock</span><span class="params">()</span> &#123;  </span><br><span class="line">	    <span class="keyword">return</span> lock.isHeldByCurrentThread();  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与<a href="https://mp.weixin.qq.com/s/xbVZPRuHR_Dl39O4S6ny0w">oolens介绍的ReentrantReadWriteLock</a>类似，由于我们此时锁的获取&#x2F;释放完全手动，我们需要使用<code>try..catch..finally..</code>块，避免出现异常时，锁泄露的问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dispatcher</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">example</span><span class="params">()</span> &#123;</span><br><span class="line">		elevator.setLock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// do something</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			elevator.setUnlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以防各位产生思维定式，我们不一定要在<code>finally&#123;&#125;</code>里释放锁，在<code>catch&#123;&#125;</code>里也是可以的，比如这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">example</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">Elevator</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">for</span> (Elevator elevator : elevators) &#123;</span><br><span class="line">			elevator.setLock();</span><br><span class="line">			<span class="keyword">if</span> (elevator.isOurTarget()) &#123;</span><br><span class="line">				target = elevator;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (Elevator elevator : elevators) &#123;</span><br><span class="line">			<span class="keyword">if</span> (elevator != target) &#123;</span><br><span class="line">				elevator.setUnlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// do something to it</span></span><br><span class="line">			target.setUnlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	<span class="comment">// 全部解锁  </span></span><br><span class="line">	<span class="keyword">for</span> (Elevator elevator1 : elevators) &#123;  </span><br><span class="line">	    <span class="keyword">if</span> (elevator1.hasReentrantLock()) &#123;  </span><br><span class="line">	        elevator1.setUnlock();  </span><br><span class="line">	    &#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们实现<code>hasReentrantLock()</code>方法，用处就在这里；我们可以如上述例子灵活地管理锁的获取与释放，并避免了没获取到锁便释放，会引起的<code>IllegalMonitorStateException</code>。</p>
<h2 id="可重入机制"><a href="#可重入机制" class="headerlink" title="可重入机制"></a>可重入机制</h2><p>正如其名，<code>ReentrantLock</code>是一个<strong>可重入锁</strong>，即一个线程可以多次获取对象的锁，这与<code>synchronized</code>关键字对应的锁是一致的。</p>
<p><code>ReentrantLock</code>实现可重入的方法，可以理解成：</p>
<ul>
<li>有一个计数器，初始值为0；</li>
<li>线程调用一次<code>lock()</code>，计数器+1</li>
<li>线程调用一次<code>unlock()</code>，计数器-1</li>
<li>仅在计数器为0时，才认为线程释放了这一把锁</li>
</ul>
<p>因此，在使用<code>lock()/unlock()</code>时，<strong>请务必保证这二者是成对使用的</strong>，否则锁不会正常释放。</p>
<h2 id="修饰实例方法"><a href="#修饰实例方法" class="headerlink" title="修饰实例方法"></a>修饰实例方法</h2><p>我们如何实现像<code>synchronized</code>关键字修饰实例方法一样，在执行该方法时，就获取该实例对象的锁的效果呢？</p>
<p>只需在执行方法时获取锁，并在完成后释放锁即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">example1</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.setLock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// do sth</span></span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.setUnlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，这种情况怎么办？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">example2</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后的结构仍然与上文一致；<strong>Java此时会暂存return的值，先执行finally{}中的代码，再执行return，也就是说，我们上述的锁仍然可以保证会被释放</strong>。这方面的原理不是本文的重点，欢迎各位自行多加探索。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">example2</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.setLock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.setUnlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程的等待-通知"><a href="#线程的等待-通知" class="headerlink" title="线程的等待&#x2F;通知"></a>线程的等待&#x2F;通知</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>与<code>synchronized</code>关键字使用<code>wait()</code>和<code>notify()/notifyAll()</code>进行<strong>按对象的线程等待&#x2F;通知</strong>不同，<code>ReentrantLock</code>使用另一<code>Condition</code>属性的<code>await()</code>与<code>signal()/signalAll()</code>方法，<strong>进行按条件的线程等待&#x2F;通知。</strong></p>
<p>我们需要将<code>Condition</code>也作为对象的属性；这里先实现<strong>按对象</strong>的等待&#x2F;通知，在这一需求下，我们的对象中只有一个<code>Condition</code>属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elevator</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">cond</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是因为<code>private</code>属性的原因，我们需要给<code>await()/signal()/signalAll()</code>套个壳：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void condHangUp() throws InterruptedException &#123;  </span><br><span class="line">    idleCond.await();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void condCall() &#123;  </span><br><span class="line">    idleCond.signalAll();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难注意到，给<code>await()</code>套壳的时候，我们要<code>throws InterruptedException</code>；这是因为，与<code>synchronized</code>不支持等待时发生中断不同，<code>ReentrantLock</code><strong>支持等待时发生中断</strong>。这一部分就不展开了，各位大可自行探索。</p>
<p>随后，就可以按照仿照<code>synchronized</code>下的<code>wait/notify</code>逻辑，进行线程的等待与通知了。</p>
<p>同样，没有获取到锁就<code>await/signal</code>，一样是会引起<code>IllegalMonitorState</code>的，注意。（笑）</p>
<h3 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h3><p>上面提到，<code>ReentrantLock</code>进行的是<strong>按条件的线程等待&#x2F;通知</strong>；我们可不可以绑定多个条件呢？</p>
<p><strong>是可以的，这也是其区分于<code>synchronized</code>的一大方面。</strong> 而且，我们可以借用这一机制，指定唤醒一个正在等待的程序，解决掉<code>notifyAll()</code>选取等待线程的随机性的问题！</p>
<p>具体例子可以观摩<a href="https://zhuanlan.zhihu.com/p/146445537">这篇文章</a> 中“ReentrantLock和Synchronized比较”部分，受限于篇幅，这里就不搬过来了。</p>
<h1 id="公平锁支持"><a href="#公平锁支持" class="headerlink" title="公平锁支持"></a>公平锁支持</h1><p><code>synchronized</code>关键字对应的锁是非公平的；也就是说，线程调度会<strong>随机选取一个被阻塞的线程执行</strong>。</p>
<p>在我们上面的样例中，我们实例化的<code>ReentrantLock</code>也是非公平的。但，<code>ReentrantLock</code>是支持实例化为公平锁的，我们只需调用实例化方法时，传入一个<code>true</code>布尔变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock(true);</span><br></pre></td></tr></table></figure>

<p>公平锁会<strong>将被阻塞的线程进行排队；选取要执行的线程时，会选取队列中第一个被阻塞的线程。</strong></p>
<p>这有什么影响呢？考虑这样一种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread1 &#123;</span><br><span class="line">	@Override </span><br><span class="line">	public void run &#123;</span><br><span class="line">		synchronized (obj1) &#123;</span><br><span class="line">			foo();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread2 &#123;</span><br><span class="line">	@Override </span><br><span class="line">	public void run &#123;</span><br><span class="line">		synchronized (obj1) &#123;</span><br><span class="line">			bar();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在非公平锁的情况下，<strong>“有可能”</strong> 出现<strong>Thread1一直获得<code>obj1</code>锁，而Thread2一直被阻塞的情况</strong>，而公平锁的排队机制，可以保证这种事情不会发生。</p>
<p>不过使用公平锁，可能会对整体性能产生影响，这就见仁见智了。</p>
<h1 id="警示"><a href="#警示" class="headerlink" title="警示"></a>警示</h1><h2 id="谨慎与synchronized-多把锁混用"><a href="#谨慎与synchronized-多把锁混用" class="headerlink" title="谨慎与synchronized&#x2F;多把锁混用"></a>谨慎与<code>synchronized</code>&#x2F;多把锁混用</h2><p>本人在HW5中，我在已经实现了<code>synchronized</code>块的锁机制后，才决定换成<code>ReentrantLock</code>；但在修改代码的过程中，我<del>出于偷懒的目的</del>尝试<code>synchronized</code>与<code>ReentrantLock</code>两把锁混用，以期实现与原有代码的兼容性。</p>
<p>然后，<code>Elevator</code>类中出现了这样的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">example2</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.setLock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.setUnlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>随后就不会出意外地出意外了</strong>，程序中出现了多个死锁点，直到作业提交截止前我都没有找完，然后…<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020250331120759.png" alt="Pasted image 20250331120759.png"></p>
<p>最后我还是决定，去掉电梯有关所有的<code>synchronized</code>。这样改以后，既方便维护，也顺便解决了所有的死锁问题。</p>
<p><strong>最后，再次告诫诸位：<br>！！谨慎对一个对象加多把锁！！，这是血的教训……</strong></p>
<h2 id="加-放锁要谨慎"><a href="#加-放锁要谨慎" class="headerlink" title="加&#x2F;放锁要谨慎"></a>加&#x2F;放锁要谨慎</h2><p>使用<code>ReentrantLock</code>后，加&#x2F;放锁操作全部手动，这就要求我们处理加&#x2F;放锁格外谨慎。</p>
<p>建议回顾上面的“可重入机制”。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>ReentrantLock</code>用好的话，不仅能实现<code>synchronized</code>块做不到的灵活锁管理，更能因此做到程序效率的提升。</p>
<p>欢迎大家对此多加尝试，也预祝大家顺利通过U2的所有作业…</p>
]]></content>
      <categories>
        <category>课程相关</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>图床测试</title>
    <url>/2023/11/30/%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/%7B433FA560-1033-4134-A91E-3F4E0C6D3AC2%7D.png" alt="{433FA560-1033-4134-A91E-3F4E0C6D3AC2}.png"></p>
<p>通过阿里云OSS+PicGo的方案，本博客成功实现了图床功能。</p>
<p>Github在国内访问速度太慢，为了实现图片快速加载，只能加点钱上阿里云了 :(</p>
<p>不过一个月也就6块钱，也就约等于一个月少喝一瓶东方树叶嘛😋</p>
]]></content>
      <categories>
        <category>建站历程</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>建站第一日</title>
    <url>/2023/11/28/%E5%BB%BA%E7%AB%99%E7%AC%AC%E4%B8%80%E6%97%A5/</url>
    <content><![CDATA[<p>今天做成的事情不多，主要是做了一下侧边栏的结构，改了个色，加了个favicon，然后基本就没了。</p>
<p>上述工作的确很简单，但为何忙了一天，却只完成了这几件事呢？问题出在评论区功能和图床的实现上。</p>
<span id="more"></span>

<p>先说图床。<br>这个Blog显然不会是一个纯文字的博客，后续放图进文章的问题肯定要考虑到。<br>Github Pages没记错的话，库大小似乎是有限制的（1GB？），把所有文章的图片直接存库里固然不现实。找了一天，暂时还没有找到一个成本为0或接近0的方案，基本都要涉及到买域名&#x2F;配置云服务。目前看到一个PicGo + Github的方案似乎可行，之后有空再试。</p>
<p>再说评论系统。<br>为了和各位读者相互交流，评论区肯定是少不了的。<br>但是，正是在评论区实现的方案选择上，我近乎浪费了一整个早上。为什么呢？还请继续往下看：</p>
<p>NexT主题集成了几个评论系统：disqus, 畅言，livere，gitalk和utterances。<br>disqus在国内访问速率堪忧，甚至大概率打不开，不在考虑范围内；<br>livere在国内倒是能用，但是必须要社交平台账号登录，不大符合我允许匿名留言的想法；<br>gitalk和utterances必须要求Github登录后才能评论，门槛之高不言而喻，且同样无法实现匿名评论。<br>那畅言呢？要求登录是其一，其美观程度之差是其二，本着不妥协的原则，这个方案也行不通。</p>
<p>在上述方案都不符合预期的情况下，只得求助各路教程，而各路教程都不约而同地指向了valine。valine允许匿名，外观简洁，看起来就是最佳之选了。在一番了解后，发现valine原本被集成在NexT内，但出于不再开源和安全问题的原因被移除，以单独插件形式存在。安装并配置好后，却发现其无法正常使用：起初是出现401报错，后变为不报错，但评论无法正常发表，点下发表后毫无反应。</p>
<p>一番折腾后，评论区的建设仍毫无进展，只得暂时作罢。</p>
<p>Blog的基本框架现在已经成型。接下来的建设任务，我想就是攻克下这两个难题了。至于小细节，留到日后吧。</p>
]]></content>
      <categories>
        <category>建站历程</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>在IDEA内部，进行更高效的死锁调试</title>
    <url>/2025/04/17/%E5%9C%A8IDEA%E5%86%85%E9%83%A8%EF%BC%8C%E8%BF%9B%E8%A1%8C%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E6%AD%BB%E9%94%81%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p>本文是对OO第二单元总结的一部分。</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://mp.weixin.qq.com/s/xbVZPRuHR_Dl39O4S6ny0w">oolens最近发的多线程文章中</a>介绍了两套调试工具，但个人认为二者功能相互独立，且二者使用起来都不大方便。<strong>这两个工具还是太吃操作了，有没有什么更简单又强势的工具推荐一下呢？</strong></p>
<p><strong>有的兄弟，有的！</strong> 使用IDEA本身就够了！我们主要利用的，是它的<code>Dump Threads（获取线程转储）</code>功能。</p>
<span id="more"></span>
<h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><p>这个Community版本也能用，没搞到Ultimate版的同学不用担心。</p>
<p>在你使用IDEA运行程序的时候，你是否好奇过，这个照相机是个什么玩意？这其实就是我们今天的主角<code>Dump Threads</code>了。</p>
<p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Screenshot%202025-03-30%20233738.png" alt="Screenshot 2025-03-30 233738.png"></p>
<p>直接左键选中，会进入一个菜单。<strong>这个选项可以抓取当前时刻程序运行状态的快照</strong>，记录了当前程序下所有线程：</p>
<ul>
<li>是否等待</li>
<li>等待类型</li>
<li>在代码运行到何处等待</li>
<li>调用栈<br>等详尽的信息，为我们的调试带来了极大的便利。</li>
</ul>
<p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020250330234106.png" alt="Pasted image 20250330234106.png"></p>
<p>直接点开超链接，甚至可以直接定位到代码处：</p>
<p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020250330234144.png" alt="Pasted image 20250330234144.png"></p>
<p>妈妈再也不用担心我找不到死锁了！</p>
<p>Debug处也有这个入口，在更多选项里：</p>
<p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Screenshot%202025-03-30%20235054.png" alt="Screenshot 2025-03-30 235054.png"></p>
<p>要这么做有一个局限性，<strong>就是当前程序必须在IDEA内运行</strong>，可能需要配合<a href="http://oo.e2.buaa.edu.cn/assignment/621/discussion/1673">更好用的数据投喂器</a>使用。当然，如果能用下面提到的方法，这个局限就不存在。</p>
<h1 id="更进一步-使用IDEA-Profiler"><a href="#更进一步-使用IDEA-Profiler" class="headerlink" title="更进一步 - 使用IDEA Profiler"></a>更进一步 - 使用IDEA Profiler</h1><p><em>（需要IDEA Ultimate，如果手上没有，获取方法还请自行探索 :D）</em></p>
<p>显然，我们一般跑程序，不可能全部放在IDEA里面跑；有没有什么像oolens里介绍的工具一样，找出当前运行的所有Java程序，并选取要分析的程序进行分析的方法呢？</p>
<p><strong>是有的，要用到IDEA Profiler。就是上个单元，我们分析运行时间接触到的那个IDEA Profiler。</strong> 他除了分析运行时间以外，还可以查看选中进程的运行状态。</p>
<p>要打开它，我们需要点开菜单栏中这个仪表盘图标：<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Screenshot%202025-03-30%20231301.png" alt="Screenshot 2025-03-30 231301.png"></p>
<p>点开之后，菜单里会列出正在运行的所有Java程序。如果我们此时的程序正在运行的话，我们可以在下面的选单里找到我们的程序：</p>
<p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Screenshot%202025-03-30%20231405.png" alt="Screenshot 2025-03-30 231405.png"></p>
<p>随后直接左键选中，发现里面有个选项叫”Get Thread Dump”，跟我们上面的<code>Dump Threads</code>得到的效果是一样的。</p>
<p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Screenshot%202025-03-30%20231410.png" alt="Screenshot 2025-03-30 231410.png"></p>
<p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020250330232124.png" alt="Pasted image 20250330232124.png"></p>
<p>如果我们此时拥有上述调用的源码，我们一样可以点开超链接，直接定位到代码对应位置；没有的话，IDEA甚至会帮你反编译：<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020250330232231.png" alt="Pasted image 20250330232231.png"></p>
<p>整体效果跟oolens提到的<code>jconsole</code>基本一致，甚至比它还好用。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>没什么好总结的，大家手上有IDEA的快去试试吧！:D</p>
]]></content>
      <categories>
        <category>课程相关</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>技术演示 - 并发执行的多测试数据对拍脚本</title>
    <url>/2025/02/04/%E6%8A%80%E6%9C%AF%E6%BC%94%E7%A4%BA%20-%20%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E7%9A%84%E5%A4%9A%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%8B%8D%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<blockquote>
<p>归档于250204，供后来者参考。</p>
</blockquote>
<p>读前须知：本文针对Windows环境；Linux仙人参考思路即可…</p>
<h1 id="需求：针对多组测试数据的评测"><a href="#需求：针对多组测试数据的评测" class="headerlink" title="需求：针对多组测试数据的评测"></a>需求：针对多组测试数据的评测</h1><p>为尽可能追求测试覆盖率，且方便测试程序的编写，我们往往会选择构造多组测试数据进行测试。</p>
<p>回顾本人先前构造，且至今一直使用的对拍脚本，每次仅可对拍一组测试数据。要进行多组数据的测试，需要每次对待测数据进行手动替换，效率实在太低。</p>
<p>因此，我决定对我的对拍脚本进行完善，使之支持多组数据的评测。</p>
<span id="more"></span>

<h1 id="已有评测机存在的问题-效率太低"><a href="#已有评测机存在的问题-效率太低" class="headerlink" title="已有评测机存在的问题 - 效率太低"></a>已有评测机存在的问题 - 效率太低</h1><p>考察了当前已有的<code>COKiller</code>等支持多数据评测的评测机，发现存在以下问题：</p>
<ul>
<li>对多组测试数据的测试均是<strong>串行进行</strong></li>
<li>有重复编译的现象产生</li>
</ul>
<p>上述两个问题会大幅降低评测效率。</p>
<p>我们都知道，我们的Verilog代码是由fuse编译成iSim实例来运行的；对于一次对拍，我们只需要编译一次。</p>
<p>串行评测多组数据就不用说了，效率低自是当然。</p>
<h1 id="本方法的实现"><a href="#本方法的实现" class="headerlink" title="本方法的实现"></a>本方法的实现</h1><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>以支持延迟槽对拍的脚本为例。P7的除了多加几个.py处理.ktext外，没啥区别…</p>
<p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Pasted_image_20241211212224.png" alt="Pasted_image_20241211212224.png"></p>
<ul>
<li><code>!make.bat</code>：对拍程序入口；</li>
<li><code>atom.bat</code>：对一个测试数据进行对拍；</li>
<li><code>clear.bat</code>：清理临时文件；</li>
<li><code>/code</code>：存放各组测试数据</li>
<li><code>/src</code>：存放Verilog源码</li>
<li><code>/temp</code>：临时存放编译结果</li>
<li><code>result</code>：存储各数据的对拍结果：输出与波形</li>
<li><code>*_filter.py</code>：过滤输出，避免输出出现版权信息&#x2F;向<code>$0</code>写入的信息</li>
<li><code>mips.tcl</code>：配置是否产生波形&#x2F;仿真上限时间用；具体见教程自动化测试相关内容</li>
<li><code>mars.jar</code>：<strong>带输出的MARS</strong>。需要注意的是，各版本MARS运行时需要的参数可能不同，需要手动进入<code>atom.bat</code>进行修改；这个当然可以通过造接口解决，我图省事没做…</li>
</ul>
<h2 id="make-bat"><a href="#make-bat" class="headerlink" title="!make.bat"></a><code>!make.bat</code></h2><p>完成Verilog代码的编译工作，同时开始调度，让<code>atom.bat</code>对每组数据进行处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">%运行前，先清一遍临时文件，以防没清干净%</span><br><span class="line">	rmdir /s /q result <span class="number">2</span>&gt; nul</span><br><span class="line">	rmdir /s /q temp <span class="number">2</span>&gt; nul</span><br><span class="line"></span><br><span class="line">%开始编译%</span><br><span class="line"></span><br><span class="line">	md temp</span><br><span class="line">	cd temp</span><br><span class="line"></span><br><span class="line">	%根据src下源码，自动生成.prj文件%</span><br><span class="line">	<span class="keyword">for</span> /f %%i <span class="title function_">in</span> <span class="params">(<span class="string">&#x27;dir /b ..\src&#x27;</span>)</span> <span class="keyword">do</span> echo verilog work &quot;..\src\%%i&quot; &gt;&gt; mips.prj </span><br><span class="line">	</span><br><span class="line">	%xilinx%\bin\nt64\fuse.exe -nodebug -prj mips.prj -o mips.exe mips_tb &gt;nul</span><br><span class="line">	IF ERRORLEVEL 1 <span class="params">(</span></span><br><span class="line"><span class="params">	    echo An error occurred when compiling.</span></span><br><span class="line"><span class="params">	    pause</span></span><br><span class="line"><span class="params">	    <span class="built_in">exit</span></span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line"></span><br><span class="line">%编译结束，退回上级目录%</span><br><span class="line">	cd ..</span><br><span class="line"></span><br><span class="line">%创建result文件夹，方便组织输出% </span><br><span class="line">	md result</span><br><span class="line">	cd result</span><br><span class="line"></span><br><span class="line">%开始调度：以result为工作目录，对每个测试数据调用atom.bat进行处理%</span><br><span class="line">	<span class="keyword">for</span> /f %%i <span class="title function_">in</span> <span class="params">(<span class="string">&#x27;dir /b ..\code&#x27;</span>)</span> <span class="title function_">do</span> <span class="params">( </span></span><br><span class="line"><span class="params">	</span></span><br><span class="line"><span class="params">	start ..\atom.bat %%i</span></span><br><span class="line"><span class="params">	</span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line">%处理完成，退回上级目录%</span><br><span class="line">	cd ..</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%输出提示：只有在所有测试都完成，即上面start指令弹出的窗口都关闭时，才可按键继续，开始比较；否则会出现找不到文件的情况%</span><br><span class="line"></span><br><span class="line">	echo Please <span class="keyword">continue</span> only when EVERY TEST IS DONE.</span><br><span class="line">	pause</span><br><span class="line"></span><br><span class="line">%进行对拍比较%</span><br><span class="line"></span><br><span class="line">	echo Performing comparison...</span><br><span class="line">	</span><br><span class="line">	cd result</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> /f %%i <span class="title function_">in</span> <span class="params">(<span class="string">&#x27;dir /b ..\code&#x27;</span>)</span> <span class="title function_">do</span> <span class="params">( </span></span><br><span class="line"><span class="params">	</span></span><br><span class="line"><span class="params">	echo %%i</span></span><br><span class="line"><span class="params">	</span></span><br><span class="line"><span class="params">	cd %%i</span></span><br><span class="line"><span class="params">	fc /<span class="number">3</span> isim_out.txt mars_out.txt</span></span><br><span class="line"><span class="params">	cd..</span></span><br><span class="line"><span class="params">	</span></span><br><span class="line"><span class="params">	)</span></span><br><span class="line"></span><br><span class="line">%比较结束，退回上级目录，方便后面clear.bat执行%	</span><br><span class="line">	cd ..</span><br><span class="line"></span><br><span class="line">%暂停，方便查看输出%</span><br><span class="line">	pause</span><br><span class="line"></span><br><span class="line">%结束时，清除一下编译产生的临时文件%</span><br><span class="line">	clear.bat</span><br></pre></td></tr></table></figure>




<h2 id="atom-bat"><a href="#atom-bat" class="headerlink" title="atom.bat"></a><code>atom.bat</code></h2><p>每组数据的实际处理程序。</p>
<p>由于iSim的运行限制，为了实现并发执行，<strong>我们不得不把编译好的程序，复制到每个测试数据的输出目录下，在得到输出后再将其删除。这显然会带来存储空间带来压力，但真的没有更好的办法了。</strong></p>
<p>我对P7的编译结果进行了查看，总大小是3mb左右；正常测试点数量规模下，占用还是能控制到1gb以下的；况且我们最后还是要给它删掉的嘛…</p>
<p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Pasted_image_20241211213111.png" alt="Pasted_image_20241211213111.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">%提示在处理哪组数据%</span><br><span class="line">	echo %<span class="number">1</span></span><br><span class="line">%在result目录下建立各组数据的输出文件夹%</span><br><span class="line">	md %<span class="number">1</span></span><br><span class="line">	cd %<span class="number">1</span></span><br><span class="line">%获取机器码和mars输出%</span><br><span class="line">	java -jar ..\..\mars.jar db mc CompactDataAtZero a dump .text HexText code.txt ..\..\code\%<span class="number">1</span> &gt; nul</span><br><span class="line">	java -jar ..\..\mars.jar db mc CompactDataAtZero nc ig coL1 ..\..\code\%<span class="number">1</span>  &gt; mars_out.temp</span><br><span class="line"></span><br><span class="line">%复制编译结果%</span><br><span class="line">	md temp</span><br><span class="line">	call xcopy /s /e /y ..\..\temp\ .\temp &gt; nul</span><br><span class="line"></span><br><span class="line">%获取行为仿真结果%</span><br><span class="line">	cd temp</span><br><span class="line">	copy ..\code.txt code.txt &gt; nul</span><br><span class="line">	call mips.exe -nolog -tclbatch ..\..\..\mips.tcl &gt; ..\isim_out.temp</span><br><span class="line">	%获取波形（如果有必要...）%</span><br><span class="line">	copy isim.wdb ..\isim.wdb &gt; nul</span><br><span class="line">%完事，退回上一级%</span><br><span class="line">	cd ..</span><br><span class="line">	</span><br><span class="line">%过滤输出%</span><br><span class="line">	python ..\..\isim_filter.py &gt; nul</span><br><span class="line">	python ..\..\mars_filter.py &gt; nul</span><br><span class="line">	</span><br><span class="line">%删除输出临时文件%</span><br><span class="line">	del *.temp</span><br><span class="line">	</span><br><span class="line">%删除复制的编译结果%</span><br><span class="line">	rmdir /s /q temp</span><br><span class="line"></span><br><span class="line">%完成，退回result%</span><br><span class="line">	cd ..</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>


<h2 id="clear-bat"><a href="#clear-bat" class="headerlink" title="clear.bat"></a><code>clear.bat</code></h2><p>只用清掉最开始的编译结果就行了。结果在下次执行时自动删除。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">rmdir /s /q temp</span><br></pre></td></tr></table></figure>



<p>其余的就不必说明了。</p>
<h1 id="本方法未完善之处"><a href="#本方法未完善之处" class="headerlink" title="本方法未完善之处"></a>本方法未完善之处</h1><h2 id="不大好解决的"><a href="#不大好解决的" class="headerlink" title="不大好解决的"></a>不大好解决的</h2><ul>
<li><p><strong>在数据组数较大的情况下，生成的临时文件总大小过大。</strong> 这个在上面已经说过了，<em>欢迎有解决办法的朋友积极指出，在此本人感激不尽！</em></p>
</li>
<li><p><strong>start一次，开一个窗口。</strong> 这好像也可以算特性了？</p>
<p>我对这个结果不大满意。在我的设想里，并行调用<code>atom.bat</code>时<strong>应该没有任何反应</strong>。在所有并发任务都结束之后，再自动进入比较环节。<strong>在座的各位一定有更好的办法。</strong></p>
</li>
<li><p><strong>调度策略过于鲁莽。</strong> 在本实现中，我们运用批处理的<code>start</code>来实现并行；读了上面的实现，我们不难发现，我们此时**有多少个测试点，就会同时开多少个<code>atom.bat</code>；若测试规模足够大，恐怕没有电脑能吃得消（看下面的分析，甚至8个就够呛）…</p>
<p>我的优化想法，是在<code>make.bat</code>里调用<code>atom.bat</code>的时候，不直接用<code>start</code>+循环调用，而是<strong>调用一个任务分配程序</strong>，由它按照配置好的最大并行数，进行数据测试任务的分配。<em>再次，欢迎有解决办法的朋友积极指出，在此本人感激不尽！</em></p>
<p>同时，由于我对Windows的批处理并行稍微熟悉，这部分我选择用.bat来写；<strong>相信<code>python</code>等在并行方面有更好的办法。</strong></p>
</li>
</ul>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>这里，我选择同时测试3组P7的测试点来进行性能分析。</p>
<p>我的电脑配置如下：<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Pasted_image_20241211214558.png" alt="Pasted_image_20241211214558.png"></p>
<p>在CPU占用上，<strong>每一个</strong><code>mips.exe</code>的CPU占用<strong>就已在10~20%左右波动</strong>；这也是为什么我上面说，现在的调度策略行不通：<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Pasted_image_20241211214616.png" alt="Pasted_image_20241211214616.png"></p>
<p>内存占用其实还好，算上命令行和mips.exe的，总体还在可接受范围：<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Pasted_image_20241211214957.png" alt="Pasted_image_20241211214957.png"></p>
<h1 id="好解决的"><a href="#好解决的" class="headerlink" title="好解决的"></a>好解决的</h1><ul>
<li><strong>必须人为判断各测试是否已完成（即start调用的窗口是否已经全部关闭）后，才能进行比较。</strong> 各路仙人的评测机已经有不少解决方案了。</li>
<li><strong>比较方法较为原始。</strong> 这个可以用python的difflib等解决，不赘述了。</li>
</ul>
<h1 id="演示下载"><a href="#演示下载" class="headerlink" title="演示下载"></a>演示下载</h1><p>技术演示 - <a href="https://bhpan.buaa.edu.cn/link/AA86CF06932380478FBD0AB8D9A22178D8">https://bhpan.buaa.edu.cn/link/AA86CF06932380478FBD0AB8D9A22178D8</a><br>文件名：experiment_parallel.zip<br>有效期限：永久有效<br>提取码：9eXL</p>
<p><strong>！！在运行前，请先配置好xilinx用户环境变量，具体见：<a href="http://cscore.buaa.edu.cn/#/discussion_area/1461/1777/posts">http://cscore.buaa.edu.cn/#/discussion_area/1461/1777/posts</a> ！！</strong></p>
<p>点击<code>!make.bat</code>运行，运行前先在<code>/src</code>里放好Verilog源码，在<code>/code</code>里放好待对拍<code>.asm</code>。</p>
]]></content>
      <categories>
        <category>课程相关</category>
      </categories>
      <tags>
        <tag>心得</tag>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次尝试</title>
    <url>/2023/11/27/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95/</url>
    <content><![CDATA[<pre><code>万事开头难。
</code></pre>
<p>有关建设个人博客这件事，本人其实早在2022年5月，就已按各路教程，用Hexo和Github Pages搭好了环境。苦于当时的学业压力，加上后续也没有任何写随笔的时间和欲望，这一项目就此搁浅，主页上也只留着默认的“hello world”。</p>
<p>转眼，过了一年半，这个想法又被提上了日程。主要的推动力，我想是高宁老师在几周前《大国领袖》课程上的点醒。的确，写作使人深刻。思想在矛盾中产生进步，而若不以文字记录下所思所想，任何进步所获，都将被时间冲淡，最后终将导致自己寸步未进。听得此话，如醍醐灌顶。也许，真的是时候认真记录一下自己的所思所想了。</p>
<p>初入大学数月，感受颇丰——无论是学业上，还是这几个月来自己学余的所见所闻。这几个月，有看完MyGo!!!!!、补完少歌之后的感动，有学业繁重、认识到自己与各路大神差距的压力，有对自己选择信息类，而非三年前自己所热爱的航空学的怀疑，更有初中以后，自己的精神支柱长期空缺的反思。上述种种，我想，绝非只是自己心里想想，然后任其随时间逝去就能过去的。用文字记录下自己的感受，并在写作中反思，我想才是正解。</p>
<p>当然，自己搭建Blog，也绝非易事。在您观看这篇文章时，本人可能还在潜心研究NexT主题的各类复杂设置，这个博客也大概率还只是一个刚搭好的毛胚房。这也算是我第一次真正使用Github开发自己的项目，要学习的东西自然也是很多。</p>
<p>写到这里，已然词穷。本人Blog的第一篇文章，就到此草草作结吧。</p>
<p>但愿写完这篇文章之后，我还能记得继续写吧（笑</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>航砖祭祖后日谈</title>
    <url>/2025/02/04/%E8%88%AA%E7%A0%96%E7%A5%AD%E7%A5%96%E5%90%8E%E6%97%A5%E8%B0%88/</url>
    <content><![CDATA[<p>本文将对BUAA_CO_2024进行简要回顾，并给出自己的一些主观建议，仅供参考。</p>
<span id="more"></span>

<h1 id="预习建议"><a href="#预习建议" class="headerlink" title="预习建议"></a>预习建议</h1><p>主要针对实验部分进行预习。理论部分听课&#x2F;考前看408资料即可。有简单&#x2F;复杂两个预习方法。</p>
<p>简单玩法，我推荐游玩图灵完备（Turing Complete）。玩到汇编之前基本就差不多了，当然能打完是最好，2333</p>
<p>复杂玩法（<strong>地狱难度！！</strong>），我力推<a href="https://ysyx.oscc.cc/">“一生一芯”项目</a>。做到B阶段，在体系结构方面的理解就足够薄纱课程组给的实验方案了；课上测试另说（笑）</p>
<p>要完成“一生一芯”，请预留至少两个月时间。<strong>难度真的很高，做之前做好思想觉悟！！</strong></p>
<p>只不过，一生一芯用的指令集是RISC-V，跟课程组选用的MIPS有所不同。二者都属于RISC，不过有一些实现细节的不同，我认为影响不大。</p>
<p>哪怕你在大二上上完了计组，如果你对体系结构感兴趣，我还是推荐你抽时间做一做一生一芯这个项目。因为在你上完后（至少我上完后），你会发现，本校的计组在硬件实现方面的知识实在欠缺，想不到吧？</p>
<h1 id="课程概况"><a href="#课程概况" class="headerlink" title="课程概况"></a>课程概况</h1><p>最终目标：要求实现支持数条MIPS指令，以及异常、中断的五级流水线处理器。</p>
<p>要求实现的指令集十分精简，具体可看本人P7的设计文档。</p>
<p>课程分为理论课与实验课两部分。理论课讲述的是正常的计组课程内容。理论课部分的资料，出于课件版权问题，不在此放出。在课程正式开始时，建议咨询各路学长&#x2F;学姐获取资料。</p>
<p>实验课即是各个Project。</p>
<ul>
<li>P0~P1：利用Logisim构建一些简单电路</li>
<li>P2：利用MARS编写MIPS汇编程序</li>
<li>P3：使用Logisim搭建单周期MIPS处理器</li>
<li>P4：使用Verilog实现单周期MIPS处理器</li>
<li>P5：实现五级流水线，处理各类冒险（数据冒险等）</li>
<li>P6：进一步完善P5的设计，主要是添加MDU与新指令</li>
<li>P7：支持异常与中断</li>
</ul>
<p>实验部分，在线上测试平台(cscore.buaa.edu.cn)，对各位的设计进行测试。</p>
<h1 id="细说实验部分"><a href="#细说实验部分" class="headerlink" title="细说实验部分"></a>细说实验部分</h1><p>包含机房上机、课下作业两环节。</p>
<p>对每一Project，需完成课下提交，方有上机测试资格；在完成上机测试之后，该Project才视为通过。各Project实行闯关制，唯有前一Project通过才可进行下一Project。</p>
<p>在本届中，闯关制在P3才正式启动；也就是说，P0-P2课下&#x2F;课上未通过，也不会影响后续进度，到P3开始才影响。<strong>但考虑到实验部分成绩会算入最终成绩，我仍然建议尽力而为。</strong></p>
<p>在学期的第1-3周为Pre阶段；同学在此期间在课程网站的教程部分，学习后续要用到的知识。其中有一些习题，<strong>由于判分标准始终不明，我还是建议尽力而为。</strong></p>
<p>4-15周则是实验正式开始阶段。期间，你需要完成“一周一P，打下计组Project那些事”（P7例外，给了两周）。12周对8个Project（0-7），还包括P0-P2的保送，容错其实还行。</p>
<p>课下测试是<strong>弱测</strong>，仅对你的实现是否基本正确进行测试，在边界条件下的正确性可能不会测试。在线上测试时，除对你的新加指令进行测试外，还会对你的课下提交进行<strong>强测</strong>，覆盖更多的边界条件。</p>
<p>若你课下没考虑周全，看到课下提交通过就认为完事的话，那你很有可能会在课上满脸痛苦的找bug，还找不出，最后喜提再来一次…</p>
<p>这也是为什么，我们需要在课下造评测机，数据生成器等等，自行尽可能全面测试。</p>
<p>机房上机类似于考试，在本届设在每周一晚7点开始，共持续2小时，<strong>闭卷</strong>。</p>
<p>每次上机考三个题，三个过两个记为通过，全过记为优秀。<strong>过两题和过三题的给分区别至今无人明确，我继续建议尽力而为。同时，在时间不够的时候，切勿盲目追求三题全过。</strong></p>
<p>P0-P2就是做一下Pre练习类似的题目，有一定难度；</p>
<p>P3-P6是三个加指令题。<strong>这部分就有意思了</strong>，这里加的不是MIPS指令集中的指令，而是课程组自行编写的新指令。具体题型建议参考往届学长&#x2F;学姐博客。</p>
<p>P7则是对课下提交进行强测，并附带一个异常有关的加指令题。只要课下写得好，P7其实更简单。</p>
<p>在每次上机完成后，还要简要回答一些问题。这部分就是助教挑几个问题问，大家基本都能答上，不用担心。</p>
<h1 id="讨论区"><a href="#讨论区" class="headerlink" title="讨论区"></a>讨论区</h1><p>课程平台设有讨论区。在此鼓励各位积极水帖，积极分享交流经验。</p>
<p>你可以分享：</p>
<ul>
<li>解题思路</li>
<li>架构搭建经验</li>
<li>数据生成思路&#x2F;实现</li>
<li>评测机搭建思路&#x2F;实现</li>
<li>其它可以提高效率的窍门：比如我自己就找到了命令行调用ISE的办法，直接抛弃臃肿的GUI🤤</li>
</ul>
<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="有关硬件实现"><a href="#有关硬件实现" class="headerlink" title="有关硬件实现"></a>有关硬件实现</h2><p>前面有稍微提到，本课程设计在硬件实现方面有所欠缺。何出此言？</p>
<p>在P6时，我们要求加入MDU，以支持乘除操作。但是，课程组给出的要求是用<code>*</code>、<code>/</code>、<code>%</code>行为级描述乘、除、取余操作，其硬件实现在实验教材中并未提及（在我这一届）。在理论课那边呢？这要看老师，有些老师可能会提，也有不提的，这是一点。</p>
<p>第二点，自2023年（我的上一届），课程设计去掉了P8 - FPGA实验。自此，实验设计中唯一跟硬件沾边的部分被砍没了。</p>
<p>因此，只看实验教程，你不会知道：</p>
<ul>
<li>怎么把自己的设计搬上FPGA</li>
<li>时序约束文件怎么写</li>
<li>FPGA上怎么调用IP核，用上板载DRAM&#x2F;SRAM</li>
<li>自己设计的时序情况如何，怎么进行时序优化</li>
</ul>
<p>第三点，课上测试。有一些指令逻辑对应的电路设计很难实现，且需要搭建专门模块，在我看来不大符合“通用处理器”的设计初衷。有些题目，在我看来，考察的其实是面向过程编程能力和读题能力，跟体系结构没什么关系。但从考察对自己架构的熟悉程度而言，这种设计也合理。</p>
<p>因此，如果你实在对体系结构感兴趣，我推荐你课下自己多花时间了解，不要窘于课程设计。当然，如果你对体系结构不感兴趣，这种课程设计也确实足够了。</p>
<h2 id="和理论课的脱节"><a href="#和理论课的脱节" class="headerlink" title="和理论课的脱节"></a>和理论课的脱节</h2><p>这个情况主要对2306。对于高工的同学（2318）是另外一个故事，我看他们的实验性实验设计挺不错的。</p>
<p>主要是，理论课讲了Cache，实验课没有考察实现。这个问题在高工部分的新版实验解决了，那个实验有考察Cache部分的内容，不知道这个实验2406会不会采用。</p>
<p>还有就是，理论课进度取决于老师。比如，P5实验开始，有的老师可能已经讲完了流水线和冒险有关知识，而有的老师还没开始，这就会导致实验进度与理论课进度的脱节。这问题没啥好解法，自己看往年课件吧。</p>
<p>在这两点以外，其实就没什么好吐槽的了，挺好的。</p>
]]></content>
      <categories>
        <category>课程相关</category>
      </categories>
      <tags>
        <tag>心得</tag>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>本人背单词的粗劣经验</title>
    <url>/2024/08/08/%E6%9C%AC%E4%BA%BA%E8%83%8C%E5%8D%95%E8%AF%8D%E7%9A%84%E7%B2%97%E5%8A%A3%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<blockquote>
<p>写在前面：本文本来是写给本人一位英语学着有些吃力的好友的一篇私货；但由于自己在给梦拓学弟们写闲聊的时候扯到了我自己学英语的经历，索性就把我自己写的这篇烂文发出来给各位参考（或公开处刑）吧。<br>如果本文有不足&#x2F;误导&#x2F;错误之处，欢迎您在本文的评论区中直接指出（更是欢迎语言学相关的朋友给予专业的指导），小弟必感激不尽！</p>
</blockquote>
<span id="more"></span>

<p>本文将对本人背英语单词的粗劣经验进行简单分享。</p>
<p>由于本人表述能力极差，加上我（自己觉得我自己）是个话痨，本文可能充斥着大量没必要的废话。如果这对您的阅读理解造成了极大的不便，本人在此深表歉意（）</p>
<p>希望下面这些内容，对你背单词有所帮助！</p>
<h1 id="奇怪的习惯"><a href="#奇怪的习惯" class="headerlink" title="奇怪的习惯"></a>奇怪的习惯</h1><h2 id="自言自语"><a href="#自言自语" class="headerlink" title="自言自语"></a><em>自言自语</em></h2><p>  其实，我非常喜欢自言自语，就假装自己在跟身边一位好兄弟聊天。</p>
<p>  考虑到本人自言自语频率实在太高，容易被人当成疯子，且自己说了什么，被人听到过于尴尬，我喜欢用英语自言自语。虽说学过英语的也能听懂，但这应该够阻止大部分人理解我在说什么了，2333</p>
<p>  有这样一个需求之后，自然引起了一个问题。比如，欸！我要吐槽说，电梯又坏了，怎么维护做得这么差！？用英语自言自语，好，“电梯”和“维护太差”怎么说？为了将就这个怪癖，只能查一查了。一查，哦！电梯是elevator，维护是maintenance。</p>
<p>  终于，我可以顺畅地自言自语出：”Why is the elevator not working again? How poor the maintenance is!” 嗯，终于吐槽出来了，爽了（笑）</p>
<p>  这个办法理论上还能顺便练练口语？</p>
<p>  当然，除非你自己非常感兴趣，不要刻意这么做。一是容易被人当疯子，二是会损失自言自语本身的乐趣。自言自语本身也是一个不用麻烦别人，就能说出自己内心想法的好方法；有些话，哪怕是对自己说，也总比一直闷着好，至少我是这么觉得的（）</p>
<h2 id="“这个用英语怎么说？”"><a href="#“这个用英语怎么说？”" class="headerlink" title="“这个用英语怎么说？”"></a><em>“这个用英语怎么说？”</em></h2><p>  就算不用英语自言自语，主动找身边物体&#x2F;概念对应的英语表述也是值得一试的。问就是，“以备不时之需”！</p>
<p>  那么，怎么查呢？词典是英汉，肯定不行；这就必须要借助一点网络的力量了。我认为这个要分两步。</p>
<p>  第一步，先在网上查一下：对有道词典之类的网络词典，直接输中文应该就找得到；对于百度嘛，按“XX 英语”去搜也可以。但是，无论哪种方法，查出来都难免有偏差，尤其是词组！这就是第二步的必要性。</p>
<p>  第二步，用词典再查一遍单词的释义，看看跟查到的能不能对得上号。就当是检验一遍，保险起见。具体查词典的操作，详见后文（）</p>
<h2 id="背词典…？"><a href="#背词典…？" class="headerlink" title="背词典…？"></a><em>背词典…？</em></h2><p>   相信你以前看到过，也听别人说过，我抱着词典背这种事？</p>
<p>   个人认为，这个说法欠妥。某种意义而言，我是把英语词典当成没有难度上限的乱序单词书在用的，23333</p>
<p>   当时，我也没刻意这么用词典过。只不过，在查词的的时候，我注意力一般都不大集中。查着查着，就看到了一个有意思的释义；然后，在查一个词的过程中，我就顺便记了不少和我查的词毫不相干的其他词（）</p>
<p>  ”有意思“又指什么呢？可能是我觉得会用得上的吧（考虑到我自言自语的奇怪嗜好，2333）</p>
<p>  在要查的词周围，一般也会出现由这个词变出来的其他词，这也算是符合用词根法背词的需求了</p>
<p>  然后，鉴于当时英语课不能干其他事，翻字典就成了我消磨时间的一个好方法（）。基本做法是，随便翻一页，看到我感兴趣的就记一下，嗯。</p>
<p>  这也是我不喜欢电子词典或者词典笔之类东西的原因。查不准之类的另论，主要是因为它们每次只能查一个词，完全就没有这种发现新词，或者一次背一连串词的快感了！！</p>
<h2 id="把手机或者电脑的语言设成英语"><a href="#把手机或者电脑的语言设成英语" class="headerlink" title="把手机或者电脑的语言设成英语"></a><em>把手机或者电脑的语言设成英语</em></h2><p>  直到现在，我也是这么干的（）</p>
<p>  最开始的动机，还是强迫症！看到中文掺英语，我就不爽！恰好，我用的一些软件没有中文，这是其一。其二是，系统的有些中文翻译，我觉得很别扭，比如Windows 10系统著名（这里应该用notorious？哈哈）的“坐和放宽”（笑）。然后，我就把系统语言设成英语了。</p>
<p>  反正常用的功能我记得怎么开、在什么位置，开英语不仅没有什么问题，反而在中英对照之下，我多记了几个词。（）</p>
<p>  硬要说这么做有什么道理的话，我想，就是创造了一个自己能天天用上英语的环境吧，嗯。</p>
<h1 id="查词"><a href="#查词" class="headerlink" title="查词"></a>查词</h1><h2 id="用词典查单词"><a href="#用词典查单词" class="headerlink" title="用词典查单词"></a><em>用词典查单词</em></h2><p>  *这个栏目是在假设你不会的情况下写的。如果你会的话，请立即跳过这一部分</p>
<p>  众所周知，英语词典没有检字表。那怎么找词呢？</p>
<p>  首先，英语词典的单词是从左到右，按字母顺序排序的。其次，跟中文字典类似，英语词典每一页的侧面，都有这一页可查单词的首字母标记；在词典的侧面看，这些标记组成了各个色块，呈V字排列。</p>
<p>  这样一来，我们就可以快速找到每个首字母对应的区域，这是第一步。第二步，就是顺着字母顺序找词了？词那么多，怎么找？我一般是这么办的：比如查blame，我先在b开头的区域随便抽一页，然后看看这一页的词长啥样：如果第二个字母是e，在l前面，那就往后翻；如果是r，在l后面，那就往前翻。翻的时候，也不用一页一页地翻，一次多翻几页，然后反复重复上述步骤即可（）</p>
<h2 id="用有道词典等电子词典查单词"><a href="#用有道词典等电子词典查单词" class="headerlink" title="用有道词典等电子词典查单词"></a><em>用有道词典等电子词典查单词</em></h2><p>  这个不是直接输单词就能查了吗，为什么还要单独列出来呢？</p>
<p>  这是因为，电子词典一般都会有“简明释义”“网络释义”。然而，就个人经验而言，这些解释往往都不准确，甚至是错的；在你的拼写是错的情况下，它甚至都能给出意思，极具误导性。更何况，现在还有AI推荐结果，我个人试下来，觉得是靠不住的。</p>
<p>  这里就只以有道词典为例吧。只有在查词界面能看其他词典（如：牛津、柯林斯、韦氏）的释义时，查到的词义解释才能保证是准确的。这个时候，为了绝对准确，还是要点开牛津词典的释义界面看看，不要看了默认的简明释义界面就跑（）</p>
<p>  最后，尽量不要用百度查单词！！！！！</p>
<blockquote>
<p>2024&#x2F;08&#x2F;08补充：这部分是为不愿意折腾的同学写的。愿意折腾的话，不妨了解一下<code>欧路词典</code>，我现在就在用，可以解决有道词典查词不能由衍生词查原词等一些小问题</p>
</blockquote>
<h2 id="查词组"><a href="#查词组" class="headerlink" title="查词组"></a><em>查词组</em></h2><p>  众所周知，无论是用词典，还是在网上查，直接按词组整体查，一般是查不到的。哪怕查到，能查的解释也不详细，有的时候甚至是错的。</p>
<p>  这里查词组的办法，主要是针对词典的情况。为方便理解，我们认为词组都有一个“中心词”。一般情况，在这一中心词的字典释义下有一词组版块，在那里我们就能查到要查的词组。</p>
<p>  那么，如何确定“中心词”呢？“中心词”一般是动词或名词，只有在极少数情况是介词，代词基本不会出现。比如，for instance的中心词就是名词instance，而不是for；stumble upon（意外遇见）的中心词就是动词stumble。</p>
<p>  在要查的词组有多个中心词，比如同时有动词和名词的时候，可以大致猜一猜意思集中在动作还是在名词上。如果意思集中在名词上，那就可以把名词当中心词，然后去查。可以与其他很多次组成词组的，一般也不会是中心词。比如：take place里面，take可搭配的词实在太多了；只有在place的注释里才查得到take place的释义。</p>
<p>  在实在拿不准的情况下，那就逐个词地查吧，总有一个词能找到这个词组的意思。如果还是查不到，那基本就证明：这不是什么有特殊意义的词组，直接逐词理解就可以了（）</p>
<h2 id="查词要讲基本法"><a href="#查词要讲基本法" class="headerlink" title="查词要讲基本法"></a><em>查词要讲基本法</em></h2><p>  这又是什么意思？</p>
<p>  看了上面用有道词典查词的办法，也许你会奇怪，为什么有些词明明拼对了，也不会显示出牛津等其他词典的释义界面？假如你手机上正好有有道词典，你可以试着搜一下sustainability，正好就会发生这种情况。</p>
<p>  这是因为，sustainability是sustainable的派生词。如果你这个时候去查sustainable，你会在其释义里发现，sustainability是被归在sustainable的派生词一栏的。</p>
<p>  在用词典查词的时候，派生词（比如：加-ly变出来的副词，加后缀变出来的名词）一般是查不到的。这个时候，我们就要查他变之前的原词。在原词的注解下面，往往才会出现我们要查的派生词。</p>
<p>  用纸质词典会简单一点：因为，原词和派生词往往长得很像，且派生词一般只在原词的基础上加后缀；在你按字母顺序翻词典的时候，你往往能在派生词理论所在位置的附近找到原词，并在原词的派生词栏目下，找到要查的派生词。</p>
<p>  但用有道字典查的话，就没有上下文可参考了。这个时候，就只能猜他是怎么变化的了。这就需要记住一些常见的变法（比如，加什么后缀），有点难度。</p>
<h1 id="背词的办法"><a href="#背词的办法" class="headerlink" title="背词的办法"></a>背词的办法</h1><h2 id="对单词本身"><a href="#对单词本身" class="headerlink" title="对单词本身"></a><em>对单词本身</em></h2><p>  这个最好说！先讲这个。</p>
<p>  不知道你现在怎么记单词的拼写？是逐个字母记吗？虽说从追求准确性的目的出发，这个办法没什么问题；但是，如果要大量背词的话，私以为这样效率有一点低。</p>
<p>  现有一我自认为效率高一点的办法，就是按发音来记。</p>
<p>  <em>读前注意！这个办法只能记住拼写的“大概”；用这种方法记了之后，强烈建议不时用词典等工具，检验一下自己记对没有!!</em></p>
<p>  一个单词的发音，是可以拆成几个音节的。如information就可以拆成in·for·ma·tion。按各部分的发音，可以大致推出音节的拼写，进而把整个词都拼出来。</p>
<p>  音节怎么断？能发得出一次音的就能断，会发出两次音的证明断少了，发不出的就不能断。仍然用information举例，如果第一个部分断成”inf”，那么就会出现”in”和”f(u)”两个音；如果断出一个“rm”，这怎么都发不出音，自然也就有问题。能不能发出音，也可以作为检查拼写的一个手段。读着太奇怪，或者直接读不出来，有可能就是拼错了。（仍然建议查词典，以防特例存在）</p>
<p>  按发音记的话，可以回避一个有关冠词选用的坑。比如“university”，按“AEIOU”的规则，看似冠词该用an，但他用的实际应该是a。为什么呢？因为他的”U”发音是”iu”，而不是unknown等其他U开头词的”ang”（抱歉，我打不出音标符号，只能这样示意一下）。据老师所说，”iu”这种叫半元音，故不能按元音规则加冠词。</p>
<pre><code>e.g. a usual occurrence （一件常事）
</code></pre>
<p>  这样背还有一个好处，就是记重读在哪会简单一点：只用记重度在哪个音节就可以了。</p>
<p>  在拆词的基础上，有一个能解构单词并猜意思的办法。当然，在背单词的时候，也可以用这种办法把词拆成几个小部分，然后再记下来。详见下文“说文解字”栏目，虽说我解释的也不一定准确（笑）</p>
<h2 id="对一个词衍生出的其他词"><a href="#对一个词衍生出的其他词" class="headerlink" title="对一个词衍生出的其他词"></a><em>对一个词衍生出的其他词</em></h2><p>  相信你也听说过所谓“词根法”吧？即以一个词作为词根，顺路记下它的反义词，还有动词、形容词等其他词性下的形式。</p>
<p>  用这个办法就可以了。 </p>
<p>  由于这类变化一般不是太难，一般只对单词的前后动手（是为前缀与后缀），记住词根之后，其它衍生词只用记怎么由词根变化就行。效率还是很高的。</p>
<p>  除此以外，词典（以牛津词典为例）一般在释义里附有“SYN”和“OPP”；前者是synonym，表示同义词；后者是opposite，表示反义词。牛津词典对有些词，还有”Word finder”和”Word family”等介绍其他有关词的栏目。查词的时候，如果碰到且感觉有用的话，就顺便记一下吧。</p>
<h1 id="“说文解字”"><a href="#“说文解字”" class="headerlink" title="“说文解字”"></a>“说文解字”</h1><p><em>读前声明：这个办法是用来猜意思的，真要知道是什么意思，还是得查！</em></p>
<p>英语不是拼音文字吗，这怎么解？其实，这里的“说文解字”，道理跟所谓“词根法”是相通的。</p>
<p>跟作为象形文字的中文一样，语言的发展，必定需要新的表述。对象形文字，这个新的表述是新的字，或新的词；而对拼音文字，新的表述就只能是词了。英语的很多词，其实都是造出来的，有一定规律可循。</p>
<p>除了对背单词有帮助，这个办法在做阅读题，碰到不会的词时也有用处。用这种办法，可以大致猜一猜不会的词的意思。</p>
<p>英语造词的现象，在医学、化学术语上的体现最为明显。比如说，医学上的低血钾，英语表述是hypo·kal·emia。hypo是低的意思，kal意为钾（potassium），即kalium，这是元素周期表内的正式写法；而emia表示在学业中的含量。*参考自一个叫Chubbyemu的医学UP主</p>
<p>换个简单的词？比如mistake，mis-一般表示错误的（e.g. mis·inform，在inform前面加个mis，表示误报），take就不说了，“拿错了”不就是“过失”了吗？</p>
<p>最简单的一种解构办法，从一个词的前缀和后缀入手。</p>
<p>就用前缀（prefix）和后缀（suffix）这两个词举例吧。可以发现，他们都有”fix”这一共同的部分，只是前缀不同。”fix”作动词有固定的意思，前缀的“pre”是常见表示“在……之前”的前缀；这么一来，词义就很好理解了，不是吗？</p>
<p>同时也要注意，不要什么都解构一番。能简单记住意思的，就别浪费精力了，这样反而容易影响对词义的理解。比如说，inform（告知）还要解构，就成”in”和”form”了；form是表格，这怎么理解？与其猜这么细致，还不如直接记意思来的快。</p>
<p>还有一类词拆不出来，那就是外来词。英语的外来词里面，来自法语和拉丁语的很多，比如restaurant来自法语，常见表省略的etc.（全写是 et cetera）来自拉丁语。</p>
<p>说起法语外来词：genre（（音乐等）流派）这个词怎么读？它的发音跟“g”根本不沾边，查了之后，想必你会大吃一惊，23333</p>
<p>当然，来自其他语种的外来词也很多，比如说koi来自日语的罗马音，是锦鲤的意思（笑）</p>
<p>文末附一些常见的前后缀，主要是针对一个词的不同形式变换的，欢迎参考；但是也只能是参考，不要全盘照搬！！</p>
<p>*这里可以来个笑话轻松一下：为什么开头我一定要强调“猜了要查”？<br>众所周知，听写的英文是dictation；嗯，想必它对应的动词词根是dictate吧！好，是老师在弄听写，表示“做……的人”在后面加个er&#x2F;or就行；那么，我这个时候，是不是可以称老师为dictator？<br>查词典之后，你会惊奇的发现，dictator的意思是独裁者&#x2F;专横霸道的人！！假设你的班主任恰好是英语老师，这个笑话的杀伤力更会成倍的上涨，蛤蛤蛤蛤</p>
<p>基本就分享到这里了。<br>常见前后缀，由于实在太多太杂，就不一起放进来了。<br>也感谢你能一直看到这里，祝你在英语这门学科上，也能取得优异的成绩！</p>
<h1 id="附：常见的前后缀"><a href="#附：常见的前后缀" class="headerlink" title="附：常见的前后缀"></a>附：常见的前后缀</h1><p>全凭印象写的，不保全（<strong>因此，如果你对此感兴趣，可以尝试上网搜“形容词后缀”等关键词自行参考，别人整理的可能比我全得多</strong>），不保严谨，乃至不保真。不要尝试全部记下来，有个印象即可，<strong>刻意记会变得不幸！</strong><br><strong>请务必以词典确切查到的单词为准。</strong><br>全是经验所得，没有经过任何正式文献的查证，**仅供参考，切勿滥用！</p>
<h2 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h2><p>   这里的后缀，主要是针对词性间转换的；-ing甚至都算一种<br>   有具体意义的（如：-meter表示“……计”，thermometer就是温度计），由于实在太多，且不一定用得上，这里就不列出了。<br>   下面的后缀，有的时候可以多种一起用，比如civil - civilize - civilization</p>
<ul>
<li><p>名词<br>· -tion &#x2F; -sion<br>多出现于动词的名词形式。-tion出现于大多数情况，而-sion的形式多出现于动词以s结尾时。<br>如：object（作动词表反对） - objection, possess（拥有）- possession<br>需要注意的是，视单词不同，在加这一后缀之前，单词往往会出现多加一个a&#x2F;去e&#x2F;把e变成i等变化（注意“等”字）；伴随着这一变化，单词的重读往往也会移到tion前的一个音上。其他后缀也可能出现这种情况，下文不再重复提及。<br>有时也会出现”-cion“的情况。如：suspect - suspicion<br>如：pose - position, define -definition, apply - application</p>
<p>· -ment<br>常见于动词的名词形式。<br>如：employ - employment</p>
<p>· -ty<br>多出现于形容词的名词形式。<br>如：sane（有理智的）- sanity, able - ability, real - reality, sensitive - sensitivity, electric - electricity<br>提到able变ability，大部分以-able作结的形容词，变名词都可以直接把-able变成-ability。<br>如：sustainable（可持续性的） - sustainability</p>
<p>· -ness<br>常见于形容词的名词形式。<br>如：shy-shyness， happy - happiness</p>
<p>· -ce<br>常见于形容词的名词形式。一般用于-ant&#x2F;-ent结尾的形容词。<br>如：significant - significance, important - importance</p>
<p>· -er&#x2F;-or&#x2F;-r<br>多加在动词后，表示做某事的人或物<br>在大部分情况下加-er即可。但在少数情况，尤其是加在t之后时，用的是-or，虽说t后加-er的情况也有。猜了之后，请务必对其进行查证。<br>如：cook - cooker（注意，是厨灶！厨师对应的英文就是cook）, simulate - simulator （模拟器）staple - stapler（订书机）</p>
<p>· -ist<br>加在某些具有特征的词背后，表示专业人士&#x2F;信仰某种主义的人<br>对于”信仰某种主义的人“，一般可以把”-ist“粗暴地换成“-ism”，得出这一主义的英语表述<br>如：scientist，communist - communism</p>
<p>· -an<br>同样指做……的人。<br>如：librarian（图书管理员），physician（医生！！物理学家是physicist）</p>
<p>· -ceive（动词）→ -ception（名词）<br>如：receive - reception</p>
<p>需要注意的是，由动词变化所得的名词，描述的一般是动作本身，而非动作对应的具体物品。这一规律对前文类似的变化也适用。<br>比如，reception常见的解释是”接待“这一动作，receipt（凭条）才指的是动作对应的具体物品。类似的还有conceive - conception - concept，conception偏向于”设想“这一动作，而concept则偏向于指”概念“这一实物。</p>
<p>· 表述某些研究领域<br>这种情况，一般是-logy结尾。更有甚者，直接加个s完事<br>如：aerodynamics（空气动力学），physics，psychology（心理学；psycho是疯子，那么这就是研究疯子的学问，嗯！2333）</p>
</li>
<li><p>动词<br>· -ize &#x2F; -ise 或 -ze &#x2F; -se<br>常见于其他词性单词对应的动作，意思可理解为“……化”。-ize为美式英语用法，-ise为英式英语用法。考虑到我们学的基本是美式英语，用-ize就好了<br>如：emphasis - emphasize（强调）, real - realize, civil - civilize（开化）<br>又如：analysis - analyze （分析）</p>
<p>· -fy(等以y结尾的？这个我真的无法确定，仅供参考)<br>更偏向于一个动词的特征，而非后缀。也可以理解成“……化”。<br>如：specify（具体说明），quantify（量化）</p>
<p>· -en<br>一般加形容词后，表加重某种性质。<br>如：deepen，soften，sharpen</p>
</li>
<li><p>形容词<br>· -ble<br>多表示“能够……的”，“值得……的”。<br>如 remark - remarkable, value - valuable , sense - sensible</p>
<p>· -ful<br>可以理解成（……很多的）<br>如：beautiful，grateful</p>
<p>· -y<br>多出现于非正式的口语化形容词上。<br>如stick - sticky（粘（乎乎）的），chubby（胖乎乎的）</p>
<p>· -ous<br>也是可以表示”…….很多”的<br>如：spacious（空间宽敞的）</p>
<p>· -ish<br>一般指含有某种贬义性质。<br>如：foolish，selfish</p>
<p>· -less<br>表示少的，没有的<br>如：homeless，selfless（无私的）</p>
<p>· -al<br>怎么说呢？可能表示“属于某个概念”吧。<br>如：space - spatial（空间上的，可以跟spacious区分一下），biology - biological，physical，nation- national</p>
<p>· -ic<br>解释不出来，直接举例吧（悲）<br>后续没有解释的，也是出于同样的原因（悲）<br>如：specific，electric</p>
<p>· -ive<br>如：<br>· expense - expensive, sensitive, creative, object - objective<br>说到objective，object不是有反对的意思吗？<br>但是，objective只能被用于表示“客观的”之义，不能表示“反对的”，可以注意一下。</p>
<p>· -ory &#x2F; -ary<br>如：satisfactory，complimentary（有赞美性质的），compulsory</p>
<p>说到complimentary，有一个一字之差的词，叫complementary（互补的）。<br>两词发音相似的这种情况，我背的时候，一般会把其中一个音稍微处理一下，方便记忆。比如，这里的e和i，我会选择”i”的音发短一点，”e”的音发长一点。</p>
<p>手机拍照依靠的组件，不是叫CMOS吗？它的全称叫互补金属氧化物半导体，对应英语就是Complementary Metal Oxide Semiconductor（semi-表示“半”）。闲来无事的话，你也可以猜猜身边英语缩写的全称？</p>
</li>
</ul>
<h2 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h2><p>能用上前缀的地方，除了造合成词，基本就是转反义词了。</p>
<ul>
<li><p>反义前缀<br>· un-<br>最常见的一个反义前缀。如：unknown<br>填空题实在想不出反义词的时候，可以<strong>试试</strong>直接加-un蒙一下。能记住到底加什么当然是最好的</p>
<p>· in- &#x2F; im-<br>如：insignificant（不重要的），impossible<br>但是！有一个很常见的反例，叫invaluable；它表示的不是没有价值（那是valueless），而是无法用价值衡量的，珍贵的。</p>
<p>· dis-<br>如： dissatisfaction，disconnect（断开连接），discontinue（中止）</p>
<p>· ir- 或（i+首字母）<br>一般是首字母为r的用。<br>如：irregular, irrational（不理智的）<br>又如：immature，illegal</p>
<p>· ab-<br>我只见过abnormal一个。</p>
<p>· a-<br>直接加个a甚至都行！<br>如：asymmetric（不对称的）</p>
</li>
<li><p>表示特定意思的</p>
<p>· over-<br>超过。<br>如：overpriced（价格太高的）</p>
<p>· under-<br>低于。常跟上面的over-互为反义<br>如：underestimate（低估）- overestimate（高估）</p>
<p>· out-<br>在…….之外的。<br>如：outdated（过期的）</p>
<p>· pre-<br>在……之前。<br>如：precaution（预防）</p>
<p>· post-<br>在……之后。常见于合成词。<br>如：post-war（战后的）</p>
<p>· sub-<br>低于，在……之下。<br>如：subway（地下铁嘛），sub-zero（零度以下），submarine（<strong>潜</strong>艇）</p>
<p>· fore-<br>提前。<br>如：forecast（预报），foresee（预见）</p>
<p>· re-<br>重新，返回。<br>如：review，renew（翻新）</p>
<p>· inter-<br>表示”相互……的“。<br>如：Internet（互联网），interact</p>
<p>· trans-<br>跨…….的。<br>如：transplant，transport</p>
<p>等等等等，不再一一枚举。实在太多了！！有兴趣欢迎自行上网查阅（晕）<br>前缀甚至还能表示数（如：mono-表单个，tri-表三个）和单位量度（如nanometer, millimeter等）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>心得</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>通过命令行，更优雅地利用ISE进行开发</title>
    <url>/2025/02/04/%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%8C%E6%9B%B4%E4%BC%98%E9%9B%85%E5%9C%B0%E5%88%A9%E7%94%A8ISE%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<blockquote>
<p>归档于250204，供后来者参考。</p>
</blockquote>
<p>众所周知，在使用ISE进行开发的时候，您可能会遇到以下问题：</p>
<ul>
<li>每次开干，都要手动创建一个新项目</li>
<li>创建文件的操作极为繁琐</li>
<li>仿真一次需要多次操作鼠标</li>
<li>ISE项目文件内文件繁多，文件管理堪称灾难</li>
</ul>
<p>但在本文的方法下，以上问题均可一一化解！</p>
<p>本文是教程中<a href="http://cscore.buaa.edu.cn/tutorial/verilog/verilog-6/verilog-6-6/">ISE、VCS 与自动化测试</a>的一小点拓展。</p>
<span id="more"></span>

<h1 id="摆脱ISE的项目文件夹"><a href="#摆脱ISE的项目文件夹" class="headerlink" title="摆脱ISE的项目文件夹"></a>摆脱ISE的项目文件夹</h1><p>在教程中，我们发现：在通过命令行使用ISE时，我们实际需要的只有<code>.prj, .tcl, （模块名）.v</code>这些文件；</p>
<p><strong>也就是说，我们完全可以在ISE项目文件夹外新开一个文件夹，存储我们的源代码，并利用命令行调用ISE！</strong></p>
<p>观察<code>.prj</code>的内部结构，发现它其实是支持相对路径的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilog work &quot;./src/NPC.v&quot;</span><br><span class="line">verilog work &quot;./src/IFU.v&quot;</span><br><span class="line">verilog work &quot;./src/GRF.v&quot;</span><br><span class="line">verilog work &quot;./src/EXT.v&quot;</span><br><span class="line">verilog work &quot;./src/DM.v&quot;</span><br><span class="line">verilog work &quot;./src/CTRL.v&quot;</span><br><span class="line">verilog work &quot;./src/CMP.v&quot;</span><br><span class="line">verilog work &quot;./src/ALU.v&quot;</span><br><span class="line">verilog work &quot;./src/mips.v&quot;</span><br><span class="line">verilog work &quot;./src/mips_tb.v&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意！在ISE自动生成的<code>.prj</code>中，是没有将testbench包含在内的；若想使用本文中方法进行开发，请务必如上文所示，将testbench顺路包含在<code>.prj</code>文件内！</p>
</blockquote>
<p>于是，我们就可以把所有的<code>.v</code>源代码统一放进工作目录下的一个文件夹内进行管理。</p>
<p>在工作目录下，我们必须放好<code>.prj, .tcl</code>文件，以及读入<code>IFU</code>的机器码<code>code.txt</code>。 最后结构如下所示。</p>
<p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Screenshot_2024-10-30_225602.png" alt="Screenshot_2024-10-30_225602.png"></p>
<p>这样就实现了项目目录的有效管理，开新模块的时候也不会有烦人的对话框了。</p>
<p>这也为我们纯使用VSCode+插件等外部编辑器方案提供了极大的便利。</p>
<h2 id="241103更新：自动生成-prj"><a href="#241103更新：自动生成-prj" class="headerlink" title="241103更新：自动生成.prj"></a>241103更新：自动生成<code>.prj</code></h2><p>自己手动敲<code>prj</code>还是难受，还是自动生成吧！</p>
<p>要做到这点也很简单，利用<code>cmd</code>的<code>dir</code>指令和<code>for</code>指令，在进行编译前生成一下<code>mips.prj</code>即可：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> /f <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;<span class="built_in">dir</span> /b src&#x27;) <span class="keyword">do</span> <span class="built_in">echo</span> verilog work &quot;./src/<span class="variable">%%i</span>&quot; &gt;&gt; mips.prj </span><br></pre></td></tr></table></figure>

<p>实验证明，包含<code>include</code>的宏定义文件包含进去不会出问题，使用了这一写法的各位大可不用顾虑。</p>
<p>但需要注意的是，请确保执行之前，目录之内没有已存在的<code>mips.prj</code>文件。</p>
<h1 id="小事：利用设置好的环境变量"><a href="#小事：利用设置好的环境变量" class="headerlink" title="小事：利用设置好的环境变量"></a>小事：利用设置好的环境变量</h1><blockquote>
<p>此处主要针对Windows用户，相信用Linux看这部分的仙人都知道在Linux上怎么做</p>
</blockquote>
<p>在教程内，我们已经知道了自动化运行的指令了；但是，前面跟一大串目录，不觉得很烦人吗？</p>
<p>恰巧，教程里已经提示过你，要将ISE的安装目录加入环境变量了。我们在这部分不妨再说说，怎么利用设置好的环境变量，简化掉指令前面那一大串难看的安装目录。</p>
<p>在正式开始前，我们不妨先Win+R一下，输入<code>%windir%</code>，发现他会自动跳转到你的Windows系统目录内。<strong>这说明，Windows（至少cmd）是支持由环境变量名进行目录跳转的</strong>！</p>
<p>要做的事情也很简单了；添加一个值为<code>（ISE安装目录，如C:\Xilinx\14.7\ISE_DS\ISE）</code>，名为<code>xilinx</code>的环境变量（系统还是用户环境变量均可，实验下来这里都可以）。</p>
<p>然后，我们就可以把命令改写为<code>%xilinx%\bin\nt64\fuse.exe -nodebug -prj mips.prj -o mips.exe mips_tb</code>，更加美观。</p>
<h1 id="使用命令行生成波形"><a href="#使用命令行生成波形" class="headerlink" title="使用命令行生成波形"></a>使用命令行生成波形</h1><p>教程这部分有所欠缺，实际上是可以通过命令行看波形的。</p>
<h2 id="小事：有关-tcl"><a href="#小事：有关-tcl" class="headerlink" title="小事：有关.tcl"></a>小事：有关<code>.tcl</code></h2><p>正式开始之前，我们先多说一点<code>.tcl</code>相关的事。</p>
<p><strong>教程内提到的<code>.tcl</code>，其实就是给ISE的ISim用的一个脚本;编译出来的<code>mips.exe</code>其实就是ISim的一个实例。</strong></p>
<p>我们不加入任何参数执行<code>mips.exe</code>，会进入iSim的命令行模式：<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Screenshot_2024-10-30_231741.png" alt="Screenshot_2024-10-30_231741.png"></p>
<p><code>.tcl</code>里写入的指令，其实就是在这个命令行程序下执行的！</p>
<p>此时我们自然一头雾水，遂输入<code>help</code>查看帮助：<br>![image.png](.&#x2F;assets&#x2F;Screenshot 2024-10-30 231837.png)</p>
<p>猛然发现，有一条<code>wave</code>指令，可能跟我们生成波形的需求有关！</p>
<p>查询后得知，<code>wave log</code>指令最有帮助，帮助文档说明如下：<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Screenshot_2024-10-30_232153.png" alt="Screenshot_2024-10-30_232153.png"></p>
<p>回顾我们编译时执行的指令：<code>%xilinx%\bin\nt64\fuse.exe -nodebug -prj mips.prj -o mips.exe mips_tb</code>，此时我们实际上是把<code>mips_tb</code>当作了顶层模块。</p>
<p>值得注意的是，此时的<code>object_name</code><strong>是对于模块内（即此时的<code>mips_tb</code>）的实例的</strong>。</p>
<p>众所周知，ISE自动生成的testbench，待测模块实例默认为<code>uut</code>，故我们将其作为<code>object_name</code>传入，同时带上<code>-r</code>参数递归包含所有子模块，我们就可以在波形文件中得到所有子模块的端口，<code>wire</code>等信号的波形。</p>
<p>最后，经修改后的<code>.tcl</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wave log -r uut </span><br><span class="line">run 200us;</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>在执行了<code>mips.exe -nolog -tclbatch mips.tcl</code>后，我们会发现工作目录里多了一个<code>isim.wdb</code>文件，这就是我们仿真所得到的波形。</p>
<h1 id="查看波形"><a href="#查看波形" class="headerlink" title="查看波形"></a>查看波形</h1><p>一番搜索后，使用这一命令即可查看生成的波形：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%xilinx%\bin\nt64\isimgui.exe -view isim.wdb</span><br></pre></td></tr></table></figure>

<p>通过上述操作，我们的确得到了满意的效果：<br><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/Screenshot_2024-10-30_233234.png" alt="Screenshot_2024-10-30_233234.png"></p>
<p>此时，你大可将当前视图内的信号全选，全部删除，然后再在UI左侧的<code>Instances and Processes</code>与<code>Objects</code>里，选择自己感兴趣的信号加入视图。<strong>此时删掉再加信号，并不需要重新仿真才能得到波形，即加即有！！</strong></p>
<blockquote>
<p>你问为什么GUI里不是即加即有？因为我们执行的<code>wave log -r uut </code>实际上记录了所有的信号，而在GUI里，若你不将要观察的特定信号加入视图，iSim是不会记录这个信号的波形的。</p>
</blockquote>
<blockquote>
<p>事实上，不加<code>wave log -r uut</code>也会生成波形文件，不过里面没有记录任何波形</p>
</blockquote>
<h1 id="编写一键仿真脚本"><a href="#编写一键仿真脚本" class="headerlink" title="编写一键仿真脚本"></a>编写一键仿真脚本</h1><blockquote>
<p>小白向，各路仙人可以直接跳过</p>
</blockquote>
<p>要做的事情很简单，写个批处理文件就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%xilinx%\bin\nt64\fuse.exe -nodebug -prj mips.prj -o mips.exe mips_tb</span><br><span class="line">mips.exe -nolog -tclbatch mips.tcl</span><br><span class="line">%xilinx%\bin\nt64\isimgui.exe -view isim.wdb</span><br></pre></td></tr></table></figure>

<p>将我们要执行的这三条指令写入一个.bat文件，双击即可执行，一键完成<code>编译-仿真-查看波形</code>三个步骤。</p>
<p>对于<code>$display</code>输出的文本，此时将在弹出的命令行窗口内显示。</p>
<h2 id="241103更新：更完善的自动化脚本run-bat"><a href="#241103更新：更完善的自动化脚本run-bat" class="headerlink" title="241103更新：更完善的自动化脚本run.bat"></a><del>241103更新：更完善的自动化脚本<code>run.bat</code></del></h2><p><strong>！！请注意，此处除<code>clear.bat</code>外的实现可能存在问题，请看下文241130的更新版本！！</strong></p>
<blockquote>
<p>241110：针对P5以后的输出格式，进行了输出过滤正则表达式的完善，再次感谢姜宇墨同学的提醒</p>
</blockquote>
<p>主要进行了以下完善：</p>
<ul>
<li>考虑到波形查看并不必要，故<code>run.bat</code>默认不打开波形视图，另给出一打开波形试图的<code>run_waveform.bat</code></li>
<li>自动生成<code>mips.prj</code></li>
<li>添加了编译错误的判断（感谢<a href="http://cscore.buaa.edu.cn/#/discussion_area/1474/1732/posts">罗浩宇同学的帖子</a>给出的脚本编写思路）</li>
<li>在运行后自动进行缓存文件的清理。为此，引入了另一脚本<code>clear.bat</code></li>
<li>对输出进行了简单的过滤</li>
<li>在命令行内直接查看输出</li>
</ul>
<p><code>run.bat</code>:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> /f <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;<span class="built_in">dir</span> /b src&#x27;) <span class="keyword">do</span> <span class="built_in">echo</span> verilog work &quot;./src/<span class="variable">%%i</span>&quot; &gt;&gt; mips.prj </span><br><span class="line"><span class="variable">%xilinx%</span>\bin\nt64\fuse.exe -nodebug -prj mips.prj -o mips.exe mips_tb &gt;<span class="built_in">nul</span></span><br><span class="line"><span class="keyword">IF</span> <span class="keyword">ERRORLEVEL</span> <span class="number">1</span> (</span><br><span class="line">    <span class="built_in">echo</span> An error occurred when compiling.</span><br><span class="line">    <span class="built_in">pause</span></span><br><span class="line">    .\clear.bat</span><br><span class="line">    <span class="keyword">exit</span></span><br><span class="line">)</span><br><span class="line">mips.exe -nolog -tclbatch mips.tcl &gt; isim_out.temp</span><br><span class="line"><span class="built_in">findstr</span> &quot;@&quot; isim_out.temp &gt; isim_out.txt</span><br><span class="line"><span class="built_in">type</span> isim_out.txt</span><br><span class="line"><span class="built_in">pause</span></span><br><span class="line">.\clear.bat</span><br></pre></td></tr></table></figure>

<p><code>run_waveform.bat</code>:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> /f <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;<span class="built_in">dir</span> /b src&#x27;) <span class="keyword">do</span> <span class="built_in">echo</span> verilog work &quot;./src/<span class="variable">%%i</span>&quot; &gt;&gt; mips.prj </span><br><span class="line"><span class="variable">%xilinx%</span>\bin\nt64\fuse.exe -nodebug -prj mips.prj -o mips.exe mips_tb &gt;<span class="built_in">nul</span></span><br><span class="line"><span class="keyword">IF</span> <span class="keyword">ERRORLEVEL</span> <span class="number">1</span> (</span><br><span class="line">    <span class="built_in">echo</span> An error occurred when compiling.</span><br><span class="line">    <span class="built_in">pause</span></span><br><span class="line">    .\clear.bat</span><br><span class="line">    <span class="keyword">exit</span></span><br><span class="line">)</span><br><span class="line">mips.exe -nolog -tclbatch mips.tcl &gt; isim_out.temp</span><br><span class="line"><span class="built_in">findstr</span> &quot;@&quot; isim_out.temp &gt; isim_out.txt</span><br><span class="line"><span class="built_in">type</span> isim_out.txt</span><br><span class="line"><span class="built_in">pause</span></span><br><span class="line"><span class="variable">%xilinx%</span>\bin\nt64\isimgui.exe -view isim.wdb</span><br><span class="line">.\clear.bat</span><br></pre></td></tr></table></figure>

<p><code>clear.bat</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">rmdir</span> isim /s /q</span><br><span class="line"><span class="built_in">del</span> mips.exe fuseRelaunch.<span class="built_in">cmd</span> fuse.* isim.wdb isim_out.temp mips.prj</span><br></pre></td></tr></table></figure>

<p>注意，在<code>run.bat</code>意外中断时，若缓存文件未成功清理，请手动点击<code>clear.bat</code>进行清理，以免后续再次仿真时出现问题。</p>
<h2 id="241105更新：上机实践经验"><a href="#241105更新：上机实践经验" class="headerlink" title="241105更新：上机实践经验"></a>241105更新：上机实践经验</h2><p>在上机过程中，孩子对这一方法进行了实验，确定了上机时这一方案的可用性。不过，注意到有同学反馈上机时使用存在问题。一番总结发现，在使用的时候，需要注意以下几点：</p>
<ul>
<li><p><strong>目录中不能出现中文字符或特殊符号</strong>，cmd对其支持可谓极差，出现了会导致找不到当前目录下生成的<code>mips.exe</code>的问题</p>
</li>
<li><p>上机的时候，请先提前手动配置好环境变量。ISE的安装目录，可通过对桌面快捷方式右键-打开文件所在的位置找到。</p>
<p><strong>需要注意的是，快捷方式指向的目录并不是我们最终要找的ISE安装目录。我们要找的安装目录，是快捷方式指向的文件夹内，那个叫ISE的文件夹。</strong></p>
<p>上机环境的环境变量，请使用<code>桌面“此电脑”快捷方式-右键菜单，属性-“设置”页中的“高级系统设置”选项-“高级”选项卡中的“环境变量...”</code>进行编辑。</p>
</li>
<li><p><strong>运行目录请务必放在D盘，切勿放在C盘。</strong> 因为上机环境的C盘有读写权限限制，在C盘运行脚本会导致<code>mips.exe</code>无法生成，导致运行失败；</p>
</li>
<li><p>运行时可能会弹出烦人的SmartScreen弹窗。<del>由于这部分我手上没有Win10环境进行测试，这里可能需要各位自行搜索关闭SmartScreen的方法</del> &#x2F;&#x2F; 上机环境下，由于权限设置，SmartScreen无法关闭。要规避这个问题，建议在打包脚本的时候，先以.txt的格式保存脚本内容，再在上机时，将.txt中脚本，粘贴到<strong>用机房电脑创建的.bat文件里</strong>。你问怎么写？新建.txt，粘贴内容，改扩展名就行了</p>
</li>
</ul>
<h1 id="241110更新"><a href="#241110更新" class="headerlink" title="241110更新"></a>241110更新</h1><blockquote>
<p>感谢姜宇墨同学的提醒…</p>
</blockquote>
<p>在P5开始，输出格式发生了变化，每一行以当前运行的时间数为开头，本文先前使用的正则表达式匹配方法存在问题，现已修正。</p>
<h1 id="241118-两次上机实验发现的问题"><a href="#241118-两次上机实验发现的问题" class="headerlink" title="241118:两次上机实验发现的问题"></a>241118:两次上机实验发现的问题</h1><p>这部分我实在没有头绪，希望各位能给出一些完善的思路。</p>
<p>在本人两次于三号机房肝P5时，我没有一次成功查看波形，但是输出正常。查看未过滤的mips.exe输出，发现在执行波形输出时，出现了FATAL ERROR；</p>
<p>但此前在4号实验室时考P4时，波形输出并没有问题。</p>
<p>初步怀疑是cmd并行执行指令引起的问题；如各位有解决这一问题的办法，欢迎私发本人&#x2F;在评论区提出，万分感谢！</p>
<h1 id="241130：上机遇到问题的临时解法"><a href="#241130：上机遇到问题的临时解法" class="headerlink" title="241130：上机遇到问题的临时解法"></a>241130：上机遇到问题的临时解法</h1><h2 id="bat导致SmartScreen拦截"><a href="#bat导致SmartScreen拦截" class="headerlink" title=".bat导致SmartScreen拦截"></a>.bat导致SmartScreen拦截</h2><p>在上交文件前，把拓展名.bat改成.txt；此后，要么直接把拓展名改回来，要么将.txt中内容，复制到另一份用机房电脑创建的.bat文件中。我个人倾向后者，因为理论而言后者能最稳妥地绕开SmartScreen。</p>
<h2 id="并发执行，导致波形无法查看"><a href="#并发执行，导致波形无法查看" class="headerlink" title="并发执行，导致波形无法查看"></a>并发执行，导致波形无法查看</h2><p>利用<code>call</code>使得各指令顺序执行，尝试避免并行执行引起的问题。<strong>注意，这一改法尚未上机实验，请不要把其作为上机时使用的唯一方法；也欢迎各位上机后反馈使用效果！</strong></p>
<p><code>run.bat</code>:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> /f <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;<span class="built_in">dir</span> /b src&#x27;) <span class="keyword">do</span> <span class="built_in">echo</span> verilog work &quot;./src/<span class="variable">%%i</span>&quot; &gt;&gt; mips.prj </span><br><span class="line"><span class="keyword">call</span> <span class="variable">%xilinx%</span>\bin\nt64\fuse.exe -nodebug -prj mips.prj -o mips.exe mips_tb &gt;<span class="built_in">nul</span></span><br><span class="line"><span class="keyword">IF</span> <span class="keyword">ERRORLEVEL</span> <span class="number">1</span> (</span><br><span class="line">    <span class="built_in">echo</span> An error occurred when compiling.</span><br><span class="line">    <span class="built_in">pause</span></span><br><span class="line">    .\clear.bat</span><br><span class="line">    <span class="keyword">exit</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">call</span> mips.exe -nolog -tclbatch mips.tcl &gt; isim_out.temp</span><br><span class="line"><span class="keyword">call</span> <span class="built_in">findstr</span> &quot;@&quot; isim_out.temp &gt; isim_out.txt</span><br><span class="line"><span class="keyword">call</span> <span class="built_in">type</span> isim_out.txt</span><br><span class="line"><span class="keyword">call</span> <span class="built_in">pause</span></span><br><span class="line"><span class="keyword">call</span> .\clear.bat</span><br></pre></td></tr></table></figure>

<p><code>run_waveform.bat</code>:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> /f <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;<span class="built_in">dir</span> /b src&#x27;) <span class="keyword">do</span> <span class="built_in">echo</span> verilog work &quot;./src/<span class="variable">%%i</span>&quot; &gt;&gt; mips.prj </span><br><span class="line"><span class="keyword">call</span> <span class="variable">%xilinx%</span>\bin\nt64\fuse.exe -nodebug -prj mips.prj -o mips.exe mips_tb &gt;<span class="built_in">nul</span></span><br><span class="line"><span class="keyword">IF</span> <span class="keyword">ERRORLEVEL</span> <span class="number">1</span> (</span><br><span class="line">    <span class="built_in">echo</span> An error occurred when compiling.</span><br><span class="line">    <span class="built_in">pause</span></span><br><span class="line">    .\clear.bat</span><br><span class="line">    <span class="keyword">exit</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">call</span> mips.exe -nolog -tclbatch mips.tcl &gt; isim_out.temp</span><br><span class="line"><span class="keyword">call</span> <span class="built_in">findstr</span> &quot;@&quot; isim_out.temp &gt; isim_out.txt</span><br><span class="line"><span class="keyword">call</span> <span class="built_in">type</span> isim_out.txt</span><br><span class="line"><span class="keyword">call</span> <span class="built_in">pause</span></span><br><span class="line"><span class="keyword">call</span> <span class="variable">%xilinx%</span>\bin\nt64\isimgui.exe -view isim.wdb</span><br><span class="line"><span class="keyword">call</span> .\clear.bat</span><br></pre></td></tr></table></figure>

<p><code>clear.bat</code>不用修改，按上面的实现就可以了。</p>
<h1 id="241209：确认问题解决"><a href="#241209：确认问题解决" class="headerlink" title="241209：确认问题解决"></a>241209：确认问题解决</h1><p>在两次试验241130中的修改后，波形已确保可以稳定生成。本方法自此可确认可靠。</p>
<p>在上机使用时，仍需注意SmartScreen引起的问题，解法见上文。</p>
<h1 id="TL-DR：上机怎么用？"><a href="#TL-DR：上机怎么用？" class="headerlink" title="TL;DR：上机怎么用？"></a>TL;DR：上机怎么用？</h1><p>这里针对直接使用Windows环境，Linux仙人可能需要自己钻研一下（当然用Linux的一般也不用看这个教程吧，笑）…</p>
<h2 id="课下准备"><a href="#课下准备" class="headerlink" title="课下准备"></a>课下准备</h2><p>把脚本改成<code>.txt</code>后缀，再塞进自己的提交里</p>
<h2 id="课上：配置名为xilinx的环境变量"><a href="#课上：配置名为xilinx的环境变量" class="headerlink" title="课上：配置名为xilinx的环境变量"></a>课上：<strong>配置名为<code>xilinx</code>的环境变量</strong></h2><blockquote>
<p>为适应不同ISE安装目录而开发。若觉得配置环境变量太麻烦，建议直接把脚本里的<code>%xilinx%</code>直接换成ISE的安装目录，因为ISE的默认安装目录应该都是一样的。</p>
</blockquote>
<p><code>此电脑-属性-高级系统设置-环境变量-（新建用户环境变量）</code></p>
<p><img src="https://lajipz-blogpics.oss-cn-beijing.aliyuncs.com/image.png" alt="image.png"></p>
<p>其中，ISE的目录在上机时应该也是<code>C:\Xilinx\14.7\ISE_DS\ISE</code>；</p>
<p>最保险的方法是，<code>对着ISE的桌面快捷方式右键-打开文件位置-打开弹出的&quot;ISE_DS&quot;文件夹内的&quot;ISE&quot;文件夹-复制路径</code> 。</p>
<p><strong>注意！ISE快捷方式直接打开的文件夹不是我们要的目标！！要多点进一个文件夹，不要忘了！</strong></p>
<h2 id="课上：用机房电脑创建脚本"><a href="#课上：用机房电脑创建脚本" class="headerlink" title="课上：用机房电脑创建脚本"></a>课上：用机房电脑创建脚本</h2><p><strong>机房电脑由于权限设置，不可能关掉SmartScreen。</strong> 为了绕开这个当前场景无用的安全检查，我们只能这么绕一下。</p>
<p>这里主要针对要双击运行的<code>run.bat</code>。<code>clear.bat</code>由于在<code>run.bat</code>内间接调用，这个安全机制无效，可以不用处理。</p>
<ul>
<li>用机房电脑，创建跟你的脚本同名的<code>.bat</code>（创.txt再改后缀，这里不赘述了）。</li>
<li>等到开始考试时，把你的脚本.txt内容拷贝进刚刚创建的.bat。</li>
<li>把准备好的.bat放进你的源码文件夹（结构见上文），即可绕开SmartScreen，双击即可直接运行。</li>
</ul>
<p>本文就到此结束了，速速实践，摆脱ISE臃肿的GUI吧！🤤</p>
]]></content>
      <categories>
        <category>课程相关</category>
      </categories>
      <tags>
        <tag>心得</tag>
        <tag>计组</tag>
      </tags>
  </entry>
</search>
